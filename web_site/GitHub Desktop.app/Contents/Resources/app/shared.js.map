{"version":3,"sources":["webpack:///webpack/bootstrap 3f3fbf7e8527f5c69fa7","webpack:///external \"path\"","webpack:///external \"fs\"","webpack:///./app/~/source-map/lib/util.js","webpack:///external \"electron\"","webpack:///./app/src/models/account.ts","webpack:///./app/src/lib/api.ts","webpack:///./app/src/lib/source-map-support.ts","webpack:///./app/src/models/repository.ts","webpack:///./app/~/lru-cache/lib/lru-cache.js","webpack:///./app/~/path-key/index.js","webpack:///./app/~/source-map/lib/array-set.js","webpack:///./app/~/source-map/lib/base64-vlq.js","webpack:///./app/~/source-map/lib/source-map-generator.js","webpack:///./app/src/models/github-repository.ts","webpack:///./app/src/models/owner.ts","webpack:///external \"child_process\"","webpack:///external \"crypto\"","webpack:///external \"os\"","webpack:///./app/src/lib/logging/renderer/install.ts","webpack:///./app/src/shared-process/accounts-store.ts","webpack:///./app/src/shared-process/communication.ts","webpack:///./app/src/shared-process/database.ts","webpack:///./app/src/shared-process/repositories-store.ts","webpack:///./app/src/shared-process/token-store.ts","webpack:///./app/src/ui/main-process-proxy.ts","webpack:///./app/~/cross-spawn-async/index.js","webpack:///./app/~/cross-spawn-async/lib/enoent.js","webpack:///./app/~/cross-spawn-async/lib/parse.js","webpack:///./app/~/cross-spawn-async/lib/resolveCommand.js","webpack:///./app/~/deep-equal/index.js","webpack:///./app/~/deep-equal/lib/is_arguments.js","webpack:///./app/~/deep-equal/lib/keys.js","webpack:///./app/~/dexie/dist/dexie.js","webpack:///./app/~/execa/index.js","webpack:///./app/~/file-uri-to-path/index.js","webpack:///./app/~/is-stream/index.js","webpack:///./app/~/isexe/index.js","webpack:///./app/~/isexe/mode.js","webpack:///./app/~/isexe/windows.js","webpack:///./app/~/keytar/lib/keytar.js","webpack:///./app/~/mem/index.js","webpack:///./app/~/npm-run-path/index.js","webpack:///./app/~/object-assign/index.js","webpack:///./app/~/pseudomap/map.js","webpack:///./app/~/pseudomap/pseudomap.js","webpack:///./app/~/source-map-support/source-map-support.js","webpack:///./app/~/source-map/lib/base64.js","webpack:///./app/~/source-map/lib/binary-search.js","webpack:///./app/~/source-map/lib/mapping-list.js","webpack:///./app/~/source-map/lib/quick-sort.js","webpack:///./app/~/source-map/lib/source-map-consumer.js","webpack:///./app/~/source-map/lib/source-node.js","webpack:///./app/~/source-map/source-map.js","webpack:///./app/~/strip-eof/index.js","webpack:///./app/~/username/index.js","webpack:///./app/~/uuid/lib/bytesToUuid.js","webpack:///./app/~/uuid/lib/rng.js","webpack:///./app/~/uuid/v4.js","webpack:///./app/~/which/which.js","webpack:///./app/~/yallist/yallist.js","webpack:///./app/src/lib/2fa.ts","webpack:///./app/src/lib/auth.ts","webpack:///./app/src/lib/equality.ts","webpack:///./app/src/lib/fatal-error.ts","webpack:///./app/src/lib/http.ts","webpack:///./app/src/lib/logging/format-error.ts","webpack:///./app/src/lib/logging/format-log-message.ts","webpack:///./app/src/lib/uuid.ts","webpack:///./app/src/shared-process/index.ts","webpack:///./app/src/ui/lib/app-proxy.ts","webpack:///./app/~/keytar/build/Release/keytar.node","webpack:///external \"module\"","webpack:///external \"url\"","webpack:///external \"util\""],"names":[],"mappings":"sEACA,cAMA,MACA,eAGA,mBACA,GACA,EACA,KAIA,mDAGA,KAGA,OACA,OAIA,IAzBA,iBA4BA,MAGA,iBAA2C,OAAc,EAGzD,qBACA,OACA,8BACA,CACA,gBACA,kBAGA,GAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,OAAe,EAChD,mBACA,GACA,CAGA,mBAAsD,+CAA+D,EAGrH,MAGA,2BChEA,kB,qBCAA,kB,oBCgBA,CAeA,aACA,eACA,SACA,GAGA,UACA,UACA,UACA,UACA,UAEA,IAPA,KAUA,aACA,OACA,YACA,qBAEA,QACA,OACA,iBAEA,OACA,YAEA,QACA,gBAEA,QACA,YAEA,MACA,EAcA,aACA,OACA,MACA,QACA,OACA,WAEA,OACA,IACA,wBAEA,aACA,sBAA8C,IAAQ,KACtD,QACA,GACA,mBACK,GACL,SACK,IACL,MAIA,qBACA,KAEA,eACA,GAIA,sBAEA,KACA,iBAGA,KACA,UACA,IAEA,IACA,EA+GA,aACA,OACA,EAUA,CAmBA,aACA,KACA,EAGA,iBAEA,UACA,IAGA,YACA,wBACA,wBACA,yBACA,yBACA,yBACA,yBACA,yBACA,wBACA,uBAGA,qBAA2B,GAAQ,KACnC,OACA,qBAIA,SACA,QASA,CAsEA,eACA,YACA,EAGA,IACA,EAGA,GACA,CAKA,CAzWA,SATA,eACA,QACA,YACG,MACH,2BAEA,yBAEA,8BAGA,MACA,mFAeA,aAsBA,cAYA,EA4CA,YAiBA,EA0CA,OAzCA,aACA,CACA,WAEA,KACA,WAEA,aACA,OACA,MACA,cAIA,WACA,aACA,gBAEA,UAGA,iBACA,SAIA,qBACA,mBACA,IAGA,SACA,kBACA,6BAEA,SACA,WACA,IAEA,IACA,GAGA,wBACA,oCACA,EAOA,EAiCA,WAhCA,aACA,CACA,WAGA,uBAMA,cACA,0BACA,oBACA,KACA,UAMA,kBACA,WACA,2BAGA,GACA,GAGA,iDACA,IAGA,gBACA,qBACA,2BACA,GAAC,IAsBD,kBAPA,WACA,UACA,OAGA,EACA,GAUA,oBAPA,WACA,UACA,WAGA,GACA,GAuEA,EAUA,2BAtCA,eACA,kBACA,aACA,0BAIA,aACA,MAGA,wBACA,qBACA,GAGA,yBACA,gBACA,MAGA,uBACA,cACA,cAIA,KADA,GApBA,GA6DA,sCA5BA,eACA,yBACA,oBACA,6BAIA,sBACA,GAGA,gBACA,OACA,MAGA,sBACA,aACA,MAGA,wBACA,eACA,cAIA,KADA,GApBA,GAoEA,sCA5BA,aACA,yBACA,oBACA,6BAIA,gBACA,MAGA,kBACA,QACA,OAGA,sBACA,aACA,OAGA,wBACA,eACA,iBAIA,MADA,GApBA,gBC1YA,kB,2FCCA,UAiBG,GACH,OAiBe,OAAuB,YAC5B,OAAC,IAAW,GAAI,EAAM,MAAK,EAAS,SAAK,EAAM,MAAK,EAAO,OAAK,EAAU,UAAK,EAAG,GAAK,EAC9F,KAGY,OAAU,YACf,OAAC,IAAW,GAAG,GAAE,EAAsB,uBAAS,MAAI,GAAE,CAAE,EAC/D,GAED,CAA6I,0BACvI,MAAM,MACN,OAAS,SACT,OAAM,MACN,OAAO,OACP,OAAU,UACV,OAAG,GACH,OAAK,KACV,CAEe,CAAc,YACtB,OAAC,IAAW,GAAK,KAAM,MAAM,KAAS,SAAO,EAAM,KAAO,OAAM,KAAU,UAAM,KAAG,GAAM,KAElG,OAvCD,UAuCC,gCC6E0C,cACzC,MAAgB,IAAW,GAAQ,QAAI,IAEpC,WAAC,CACI,SAGJ,UAAC,KAAU,MAAc,IAAM,MAAM,KAEvC,MAAW,IAAO,GAAM,MAErB,+BAAM,IAAwB,MAAf,MAAG,GACnB,MAAa,IAAM,EAAM,MAAM,GACzB,UAAQ,IAAK,MAEvB,IAAC,CAEK,OACP,KAOE,CACsC,cACjC,OAAK,IAAc,cAAQ,QAAY,YAC9C,IAIE,CAsVH,oDACE,IAAiB,IACjB,aACe,IAAG,KACjB,KAAU,SACN,KAAO,6DAAqF,oBAChG,GAEM,4BAAkC,MAAM,EACjD,UAAC,IAOE,CAgBwC,cAStC,IAAS,KACJ,UAEN,0BAAY,IAAM,EAAM,MACjB,aAAS,GAAS,aAAW,GACtC,QACD,GAaD,YACE,MAAiB,IAAU,QACxB,uBAAY,KACP,CADsB,IAAO,OAI/B,GACP,oZAhkBD,UACA,QACA,QAGA,OACA,QACA,QAEA,IAAc,EAAiC,EAE/C,IAA0C,EAC1C,uBAA8C,EAE3C,2CAAuB,EAAW,MAApB,EAAqC,GAAa,EAC9D,YACL,KAEgC,yHAChC,KAMa,mBA+Ib,QAKe,OAA6B,gBAClC,OAAC,IAAO,IAAQ,GAAS,SAAS,GACzC,MAGD,CAAkD,kBAC5C,MAAS,SACT,QAAM,MACX,EAG2B,CAA4B,8DACtD,IACE,MAAc,IAAG,KAAU,MAAQ,QAAQ,eAAc,MAAW,EAC9D,UAAC,GAAc,eACtB,IAAU,SACN,YAAM,oCAAoC,MAAW,MAClD,IAEV,IAAC,GAGwB,uDACvB,IACE,MAAc,IAAG,KAAU,MAAQ,QAAM,MACzC,QAAY,GAAG,KAAM,GAAc,eAC7B,UACP,IAAU,SACN,WAAM,2CAA0C,KAAW,WAC9D,IAEJ,EAAC,GAGuB,sDACtB,MAAc,IAAO,KAAS,WAK9B,OAEE,MAAa,IAAW,GAAuB,qBAC/C,cAAc,GAAG,KAAU,MAAQ,QAAM,MACzC,IAAY,GAAG,KAAM,GAAc,eAE7B,UAAM,OAAQ,QAAQ,IAG7B,MAAU,SACN,CAGP,WAHa,0CAAyC,KAAW,WACvD,MAET,GAGuB,CAAyC,6DAC/D,IACE,MAAc,IAAG,KAAU,MAAQ,QAAQ,eAAc,MAAQ,cAAkB,EAC7E,UAAC,GAAc,eACtB,IAAU,SACN,YAAM,gCAAgC,MAAQ,MAAU,MACrD,IAEV,IAAC,GAGkC,CAAc,kEAC/C,IACE,MAAY,IAAG,CAAK,KAA+B,EACnD,uBAAS,GAAG,EAAkB,mBAAe,eAC7C,IAAc,GAAG,KAAU,MAAQ,QAAM,MACzC,IAAY,GAAG,KAAM,GAAc,eACnC,IAAW,GAAS,GACjB,YAAM,IAGD,OAAM,GAEN,GAET,KAAU,SACN,YAAM,2CAA8C,MACjD,IAEV,IAAC,GAGqB,oDACpB,IACQ,OAAK,MAAS,SACrB,aAAU,SACN,CAGP,WAHa,wCAAuC,KAAW,WACrD,MAET,GAG4B,CAA2E,qEACtG,IACE,MAAa,IAAS,WAAW,GAAc,cAC/C,aAAc,GAAG,WAAkB,QAAO,OAAS,GAC7C,CACO,QACJ,uBAGH,WAAC,GAAc,eACtB,IAAU,SACN,WAAM,+CAA8C,KAAW,WAClE,IAEJ,EAAC,GAMuB,CAAkF,gEAExG,MAAY,IAAQ,IAAI,CAAM,MAAM,GAAW,WAC3C,CAAO,MAAuB,EAGlC,QAAS,GAAG,EAAmB,4BAAc,MAAiB,YAC9D,OACE,MAAY,IAAG,KAAU,MAAS,SAG5B,UAAO,IAAO,OAAQ,MAAK,CAAE,GACpC,aAAU,SACN,WAAM,2CAA2C,MAAU,KAC9D,IAEJ,EAAC,GASqB,CAAgB,oDACpC,MACA,UAAY,IAEZ,KACE,MAAc,IAAG,KAAU,MAAQ,QAAM,MACzC,IAAW,GAAG,KAAM,GAAc,eAC/B,IACE,OAAK,KAAC,GAEH,OAAkB,EAC3B,UAEK,UACP,KAGc,CAAwE,oBAC/E,OAAC,GAAO,QAAK,KAAS,SAAM,KAAM,MAAQ,GAAM,GAAM,GAC7D,GAMgC,CAA4B,mEAC3D,MAAa,aAAc,MAAc,EACzC,UACE,MAAc,IAAG,KAAU,MAAQ,QAAO,OAC1C,IAAc,GAAW,GAAQ,QAAI,IAClC,sBAAU,GACX,MAAY,IAAW,SAAS,GAC1B,UAAM,OAAQ,IAAO,KAC5B,EACK,OACP,MAAU,SACN,YAAM,yCAAyC,MAAU,KACtD,IAEV,IAAC,GAG6B,CAAiD,mEAE7E,MAIG,4DACM,QAAiB,iBAG1B,OACE,MAAc,IAAG,KAAU,MAAQ,QAAQ,eAAc,MAA6B,EAAW,6BACjG,IAAW,GAAG,KAAM,GAAc,eAClC,IAAkB,GAAW,GAAQ,QAAI,IACnC,cAAC,CAAO,SAAM,KAAc,IACnC,IAAU,SACN,YAAM,sCAAsC,MAAU,KACnD,IAEV,IAAC,CACF,IAlND,MAkNC,GAED,GAQC,IARD,CAAqC,YACnC,qBACA,6BACA,kDACA,oEACA,+DACA,4CACA,kCACD,qBARoC,GAAzB,EAAyB,4BAAzB,EAqBT,+BACH,EAwEiD,oBAxE0E,6DACzH,MAAW,IAAS,OAAM,QAAQ,MAAc,KAAS,QAAS,SAClE,UAAsB,YAAgB,EACtC,GAAe,GAAkB,GAAG,CAAgB,eAEpD,OAAU,GAAG,KAEb,KAAc,GAAG,QAAa,QAAS,GAAM,KAAQ,OAAkB,iBAC7D,QACG,YACI,gBACT,OACI,GACG,SAzRd,0CAyRgB,EAChB,uBACgB,cAAe,IAIhC,QACE,MAAY,IAAG,KAAM,GAAc,eAChC,OAAQ,GACT,MAAW,IAAS,GACjB,SAAM,IAA6B,QAAzB,QAAY,KAAsB,GACvC,aAAC,CAAM,KAA2B,GAAW,WAGzD,SAAC,EAAU,SACN,IAAyB,GAAhB,MAAO,OACjB,MAAiB,IAAW,GAAQ,QAAI,IACrC,mBAAa,GACd,MAAY,IAAc,GAAM,MAC7B,QAAqB,CAAd,MAAO,OACf,MAAU,IAAS,GAAG,GACf,aAEG,QADR,GACS,CAAM,KAA2B,GAAgC,gCAAM,KAAE,EAAkB,mBACpG,KACQ,WAAC,CAAM,KAA2B,GAAgC,gCAAM,KAAE,EAAkB,mBAE5F,KAAC,CAAM,KAA2B,GAAO,OAGvD,YAAC,CAEK,OAAC,CAAM,KAA2B,GAAO,OAChD,YAED,MAAc,IAAI,aAAY,GAAQ,UAAK,GACxC,YAAU,GACR,IAAwB,GAAf,MAAO,QAEX,qEAF+B,MAAQ,cAEtC,CAAM,KAA2B,GACpC,4BAAI,GACL,GADc,MAAO,UACZ,GACN,WAAC,KAAW,MAAY,IAAQ,OAClC,MAAwB,IACxB,aADgC,MAAS,SAAc,cAClC,GAClB,MAD0B,MAAM,MAAc,iBAC9B,IACX,SAAC,CAAM,KAA2B,GAG9C,yBAAM,KAAI,IACF,gDADW,MAAQ,cAClB,CAAM,KAA2B,GAIhD,iBAAC,CAEK,OAAC,CAAM,KAA2B,GAAM,MAC/C,gBAGD,EAYoC,UAZ2B,uDAC7D,MAAS,IAAG,GAAO,IAAS,GAC5B,OACE,MAAU,IAAG,KAAS,IACtB,eAAY,GAAG,KAAS,IAClB,oBAAC,IAAI,GAAO,QAAK,GAAM,MAAU,GAAO,GAAQ,GAAM,GAAW,WAAM,GAAG,GAAM,GACvF,MAAU,SACN,WAAM,wCAA6C,KACtD,IAEJ,EAAC,KAGD,EAoBgD,cApBI,oDAClD,MAAY,OAAkB,EAE9B,WACE,MAAc,IAAG,QAAa,QAAS,GAAM,KAAO,MAIpD,mDAAY,GAAG,KAAM,GAAc,eAChC,UAAQ,GAAP,EAAiB,YACb,mCAIT,GADO,KACG,SACN,YAAO,sDAAoE,oBACxE,IAEV,IAAC,KAoBD,EAcG,yBAdiD,YAClD,MAAY,IAAM,EAAM,MACrB,UACK,YADE,MAAS,SAGV,OAAS,GAAS,aAAW,GACtC,QACD,QAQD,aAqBG,EACH,EAKqC,oBALe,YAClD,MAAY,IAAM,EAAM,MACjB,aAAS,GAAS,aAAW,GACtC,QAAC,WAGD,uBASwC,EACxC,EAEC,sBAFuF,eAChF,OAAS,IAAK,KAAE,MAAK,GAAS,WAAc,KACnD,MAED,EAIC,yBAJuE,eACtE,MAAa,IAAa,EAC1B,IAAW,GAAqB,mBAAO,EAAK,KACrC,eAAU,sCAA4C,WAAe,YAC9E,EAAC,IAED,EAeC,kBAfoF,0DACnF,IACE,MAAa,IAAa,EAC1B,IAAc,GAAG,QAAa,QAAQ,GAAM,KAAQ,OAA4B,2BACnE,WACI,gBACT,OACC,SAET,KAAY,GAAG,KAAM,GAAc,eAC7B,UAAO,IACd,aAAU,SACN,YAAM,gDAAqD,KACxD,IAEV,IAAC,mCC3kBwC,aAGpC,IAAC,CAAwB,EAAK,KAAK,KAAU,EAAS,SACjD,UAIL,MAAO,EAAW,WACb,eAAgB,EAIxB,SAAa,MAAe,CAqBzB,OAAC,GAAG,EAAW,WAIlB,MAEE,MAAS,GAAK,EAAa,aAAK,EAC1B,cAAC,CAAK,IAAM,EAAS,SAAM,GAClC,OAAc,QAGjB,CAAC,CAGD,CAYmE,eACpD,UAAI,IAAM,EAKjB,GAAM,EAAS,EACf,IAAU,iBAAoB,KAC7B,KACR,GAEuD,CA4BZ,aAC1C,IAAU,GAAgB,EAAI,IAE1B,SAOF,MAAM,EAAM,OAAO,IACb,aAAgB,EAAI,IAGxB,IACI,EAG6B,EAAM,EAC5C,GAJe,EAGR,K,kDAtIR,UACA,OAEA,GAAmB,EAAmC,EACtD,IAAsB,EAAU,EAWhC,IAAyE,wCAkDtD,EAAG,GAKnB,SACH,GAKG,GAaH,EAiBG,iBAjBH,UACkB,GAAQ,QACX,aACa,OAExB,4BAEF,2BAAc,GAGgB,QAAW,EACjC,oBAAkB,kBAC3B,GAMD,EAQuD,sBARL,WAC1C,OACA,MAAO,EACJ,aAAO,EACT,cAAwB,EAEhC,oFCjHD,UAEA,OAc0B,IAC1B,OAWe,OAA2B,YACtC,MAAsB,GAAO,EAC1B,uBACM,GAAC,GAAc,GAAK,EAAK,KAAM,EAAG,GAAE,EAAgB,iBAAS,SAAkB,GAAM,EAEtF,SAAC,GAAc,GAAK,EAAK,KAAM,EAAG,GAAM,KAAM,EAEvD,QAED,CAAwG,oBAClG,MAAK,KACL,OAAiB,iBACjB,OAAK,KAAmB,GAAoB,EAAK,MAAQ,EAAS,SAClE,QAAG,GACH,OAAQ,QACb,CAM0B,CAAmC,uBACtD,OAAC,IAAc,GAAK,KAAK,KAAM,KAAG,GAAkB,EAAM,KACjE,QAGiB,CAAiB,cAC3B,OAAC,IAAc,GAAK,KAAK,KAAM,KAAG,GAAM,KAAiB,iBAChE,EAGc,CAAa,WACpB,OAAC,IAAc,GAAK,EAAM,KAAG,GAAM,KAAiB,iBAAM,KAEnE,UA7CD,aA6CC,mBCrCD,iBACA,IACA,YACA,OAEA,QACA,QAEA,GACA,uBAEA,SACA,EAEA,GAEA,YAAyB,SASzB,CACA,aACA,qBACA,iBAGA,GACA,uBAAe,KAGf,IACA,IAGA,2BAEA,KACA,GACA,sBACA,oBAGA,0BACA,EACA,yBAEA,6BAEA,yBACA,qCACA,sBACA,cACA,OAEA,CA8EA,mBACA,SACA,UACA,SACA,QACA,gBAGA,WACA,0BAEA,GAuOA,iBACA,wBACA,QACA,SACA,UACA,QACA,wBAEA,WACA,8BAGA,WACA,MACA,OACA,GAEA,eACA,wBACA,UAEA,YACA,qBACA,eACA,WAEA,4BAEA,UACA,EAEA,aACA,sBACA,gCACA,iCAIA,cACA,SACA,KAGA,EAEA,eACA,MACA,SACA,UACA,6CAEA,oCACA,8BACA,+BACA,EACA,CAEA,CACA,qBACA,UACA,aACA,cACA,WACA,iBACA,EApdA,UAGA,EACA,QACA,QAGA,QAGA,IACA,OACA,0BAEA,IACA,aACA,mBACA,EAEA,aACA,WACA,CACA,EA8DA,wCACA,gBACA,0BACA,UAEA,uBACA,KACA,KACA,gBACA,eACA,MACA,EACC,gBAED,+CACA,gBACA,uBACA,EACA,gBACA,eACA,aACA,EACC,gBAED,2CACA,gBACA,0BACA,SAEA,mBACA,KACA,KACA,gBACA,eACA,SACA,EAGA,gBACA,qDACA,gBACA,CACA,yBAEA,cACA,gDACA,mBACA,wCACA,yDACA,wCACA,OAAO,EAEP,SACA,KACA,gBAAoB,kCACpB,EACC,gBAED,2CACA,eAAoB,wBACpB,EACC,gBAED,8CACA,eAAoB,gCACpB,EACC,gBAED,kCACA,MACA,iCAA+C,OAC/C,cACA,gBACA,KAEA,GAeA,iCACA,MACA,iCAA+C,OAC/C,cACA,gBACA,KAEA,GAEA,2BACA,mDACA,UACA,GAAG,EACH,OAEA,6BACA,mDACA,UACA,KAAG,EACH,OAEA,4BACA,QACA,mBACA,8BACA,6CACA,qCACA,MAAK,EAGL,wBACA,wBACA,oBACA,IAEA,2BACA,yCACA,YACA,SACA,KACA,QACA,yBAGA,GAAG,oCACH,OACA,EACA,IAEA,8BACA,eACA,YAEA,iCACA,OACA,aAEA,cACA,cACA,OACA,uBAGA,mBACA,cACA,WACA,OAEA,gCACA,GAGA,mBACA,UACA,IACA,OAEA,mCACA,GAGA,mBACA,2BACA,IACA,OAEA,kDACA,GAGA,SACA,mDACA,CACA,KAEA,SACA,OAEA,OACA,QAEA,kDACA,WAAe,UACf,mBACA,iBAEA,YACA,iBAEA,eACA,SAGA,8CACA,qBACA,EAEA,OACA,QAEA,SAEA,IACA,GAEA,+BACA,aAEA,6BACA,2CAEA,6BACA,aACA,OAIA,kCAHA,iCAIA,OAGA,MAYA,cAXA,4CAGA,aACA,WACA,UACA,wCACA,kBACA,WACA,KACA,QAGA,qBAGA,0BACA,eACA,0CAKA,2CACA,kCACA,2CACA,QAEA,WAEA,2BACA,4BACA,sCACA,oBAIA,IAEA,2BACA,eACA,OAEA,4BACA,eACA,OAEA,0BACA,yBACA,sBAEA,KACA,OAFA,MAIA,2BACA,4BACA,KAEA,4BAEA,MAEA,uBAEA,iBAA8B,EAAQ,SACtC,SACA,UACA,KAEA,qBACK,OACL,SAEA,EACA,sBAEA,EACA,CACA,GAEA,4BACA,OACA,0CACA,KACA,KACA,iBClZA,aACA,qBACA,GAEA,2BACA,kBAEA,eACA,6CAIA,OACA,wBAAE,OACF,OAHA,wBCNA,CAWA,YACA,MACA,kCACA,KAIA,CAhBA,QACA,sBAOA,eASA,yBACA,cACA,WAAsC,SAAS,EAC/C,eAEA,SACA,EAOA,EACA,2BACA,8CACA,MAMA,EACA,6BACA,qBACA,sBACA,iBACA,YACA,qBAEA,GACA,iBAEA,EAMA,EACA,2BACA,qBACA,2BACA,EAMA,EACA,+BACA,qBACA,uBACA,oBAEA,yBACA,uBAMA,EACA,0BACA,wBACA,0BAEA,4CACA,EAMA,EACA,8BACA,oBACA,SAEA,6BCpEA,CAiCA,aACA,OACA,aACA,SACA,CAOA,CACA,aACA,UAEA,QADA,SAEA,EACA,EACA,CAIA,CArDA,QAcA,MAGA,OAGA,MAGA,IAOA,EAwBA,oBACA,OACA,GAEA,MAEA,GACA,OACA,OACA,EAGA,SAEA,eACG,SAEH,WACA,EAKA,EACA,wBACA,SACA,SACA,IACA,IAEA,IACA,OACA,kBAGA,yEACA,OACA,0DAGA,WACA,MACA,QACA,KACA,CAAG,OAEH,aACA,UACA,mBCtIA,CAeA,aACA,CACA,IAEA,mCACA,+CACA,sCACA,sCACA,kBACA,qBACA,yBACA,KAxBA,QACA,QACA,WACA,iBASA,YAcA,qBAMA,EACA,EACA,yBACA,SACA,mBACA,QACA,gBAEA,oCACA,OACA,WACA,QACA,uBAIA,kBACA,4BACA,OACA,kCAGA,oBACA,QACA,sBAGA,gBACA,wBAIA,oBACA,EACA,gCACA,0BACA,GACA,8BAEA,EACA,GACA,CAWA,EACA,YACA,sBACA,kBACA,qCACA,4BACA,0BAEA,WACA,6CAGA,GACA,YACA,wBACA,sBAIA,IACA,YACA,sBACA,oBAIA,uBACA,iBACA,uBACA,+BACA,+BACA,cACA,OAEA,GAIA,EACA,YACA,8BACA,OACA,EACA,uDAGA,IAGA,aAOA,8DACA,IACA,sEAGA,cAXA,uDAEA,+CACK,EAyBL,EACA,YACA,8BACA,OAEA,aACA,IACA,sBAKA,8JACA,IACA,YAEA,YACA,yBAIA,aACA,QAGA,6CACA,uCAEA,6BACA,QACA,sBAEA,iBAEA,4BACA,OACA,8BAEA,SACA,kCAEA,0BACA,wBACA,OACA,wBAGA,MAEA,SACA,sBACA,UAGA,WACA,oBACA,UAGA,EAAK,EACL,oBACA,cAGA,+BACA,0BACA,GACA,UACA,qBAEA,IACA,yBAEA,4BAEA,GAAK,EACL,KAYA,EACA,YACA,iBACA,iBACA,+BACA,cACA,sBAIA,+BACA,6BACA,cACA,uBACA,aAKA,sDACA,WACA,SACA,WACA,OAGA,IAKA,EACA,YACA,6BACA,WACA,IACA,IACA,IACA,IACA,IACA,IACA,oBAMA,kBAA0C,OAL1C,EACA,EACA,EAEA,IACmD,MACnD,QACA,KAEA,qBACA,QACA,oBACA,MACA,IAIA,gBACA,iDACA,IAEA,YACA,GAGA,eACA,gBACA,OAEA,gBACA,2CACA,sBACA,KAGA,6BACA,EACA,oBAEA,gBACA,eACA,OAEA,eACA,uCACA,oBACA,KAIA,OACA,CAEA,OACA,IAEA,YACA,qCACA,yBACA,UACA,uBAEA,MACA,yBAEA,wBACA,qEACA,yBACA,GACA,IAAK,EACL,KAIA,EACA,YACA,iBACA,OACA,cACA,+BACA,4BACA,wBAEA,4BACA,gCAEA,OACA,2CAEA,kBACA,6EAGA,aACA,CAIA,EACA,YACA,mBACA,4BACA,WAEA,sGCnZA,UAEA,QAc2B,IAC3B,OAkBe,OAAiC,YACtC,OAAC,IAAoB,GAAK,EAAK,KAAE,EAAK,MAAS,SAAK,EAAO,OAAM,EAAK,KAAM,EAAQ,QAAM,EAAK,KAAM,EAAQ,QAAM,EAAc,cAAM,EAC9I,SAED,CAAkE,kBAAE,EAA+B,KAAE,EAA2B,KAAE,EAA6B,KAAE,EAAuC,SAAE,EAA8B,KAClO,MAAK,KACL,OAAM,MACN,OAAK,KACL,OAAQ,QACR,OAAK,KACL,OAAQ,QACR,OAAc,cACd,OAAS,SACd,CAGa,CAA8B,UAC1C,MAAmB,GAAG,GAAoB,GAAK,KAAK,KAAM,KAAM,MAAM,KAAK,KAAe,EAAQ,QAAe,EAAK,KAAe,EAAS,SAAe,EAAe,eAAe,EAErL,iBAAC,GAAgB,iBAAc,EAAO,MAAO,KACpD,CAED,IAAmB,WACX,OAAK,MAAM,MAClB,QAGD,IAAmB,WACV,UAAO,KAAM,MAAM,SAAQ,KACpC,IACD,IAhDD,mBAgDC,oEC3DsC,WACvC,OAKe,OAAsB,YAC3B,OAAC,IAAS,GAAK,EAAM,MAAM,EAClC,SAED,CAAkD,gBAC5C,MAAM,MACN,OAAS,SAEhB,GAbD,QAaC,eCpBD,kB,8BCAA,kB,uBCAA,kB,oCCW4D,iBAC1D,GAAW,YAAK,KAAM,MAAO,EAAE,EAAiB,qBAAoB,aAAc,IACnF,qDAbD,UAEA,OAEA,IAAO,EAMJ,OAKF,EAAI,IACE,CAA+B,UAC/B,GAAQ,QAAS,EACb,WAAM,MAAC,EAAgB,iBAAQ,EACvC,GACG,EAA+B,SAC9B,GAAO,OAAS,EACZ,WAAK,KAAC,EAAgB,iBAAQ,EACtC,GACG,EAA+B,SAC9B,GAAO,OAAS,EACZ,WAAK,KAAC,EAAgB,iBAAQ,EACtC,GACI,EAA+B,UAC/B,GAAQ,QAAS,EACb,WAAM,MAAC,EAAgB,iBAAQ,EAEzC,GAjBuB,oXCdxB,UACA,QAAqD,GAErD,EAyFC,cAzFD,KASE,CAAmE,gBAL3D,MAMF,iBAAU,UACV,OAAY,YACZ,OAAe,eAAO,KAC3B,eAKkB,iDACjB,aAAU,MAEJ,eAAK,KAAS,SACrB,SAKsB,CAAiB,qDACtC,MAAU,MAEV,oBAAU,MAAY,YAAQ,QAAC,EAAgB,iBAAS,GAAS,EAAM,MAAS,EAE5E,YAAS,SAAK,KAEd,QACL,QAKyB,CAAiB,wDACzC,MAAU,MAEV,oBAAU,MAAY,YAAW,WAAC,EAAgB,iBAAS,GAAS,EAEhE,YAAS,SAAO,KAAS,SAAO,OAAE,KAAK,EAAG,KAAY,EAEtD,SACL,QAKe,CAA2C,8CACzD,MAAU,MAEV,oBACI,UAAC,KAAa,KAAQ,MAAU,SAClC,MAAgB,GAAG,KAAQ,GACnB,KAAK,KACd,EAEG,MAAS,SACT,OACL,QAK0B,wDACzB,MAAS,GAAO,KAAU,UAAQ,QAC/B,YAAS,CAAR,EAAY,EAIhB,aAAiB,GAAgC,KAAM,MACvD,GAAwB,IAAkB,IAAc,qCACtD,MAAyB,GAAG,GAAI,GAAO,QAAQ,EAAM,MAAS,EAAS,SAAI,GAAS,EAAO,OAAS,EAAU,UAAS,EAAG,GAAS,EACnI,MAAW,EAAG,KAAU,MAAY,YAAQ,QAAC,EAAgB,iBAAqB,GAAS,EACrF,aAAoB,GAAU,UAAM,GAC1C,GAEE,SAAS,SAAG,KAAa,SAAI,IAClC,KAEW,OACV,MAAwB,GAAO,KAAS,SAAI,IAAQ,KAAW,EAAU,UACrE,UAAU,UAAQ,QAAQ,QAAM,KAAU,UAEjD,oCC/EkC,aACjC,MAAU,GAAU,EACjB,QAAC,CACK,EAKT,eALe,MACN,wDAAM,MAEf,QAEQ,GAAsB,EAC3B,MAAC,CACK,EAKT,eALe,MACN,8CAAM,MAEf,QAEU,GAAU,EACpB,KAAU,EAAU,EACpB,KAAa,EAAK,EACX,KACA,KAAW,MAAC,CAAQ,SAAM,KAAc,YACvC,MAAc,KAClB,MAAe,GACT,MAAO,EACJ,aAAO,EACT,cAAO,EAER,aAAC,CAAO,MAAW,EAAM,KAC/B,WACG,KAAS,KACC,GAAgB,gBAAQ,QAAO,KACpC,GAAY,YAAM,wBAAyB,IAAE,CAEvD,GACJ,EAAC,EAEqE,oVAjDtE,UAKA,GAAM,CAAiB,iBAAG,EAG1B,OAKG,KAqCH,EAIuD,SAJS,aAC3C,GAAM,GAC1B,GAGD,EAOC,gBAPiG,aACnF,GAAgB,gBAAQ,QAAc,qCACjD,MAAkB,GAAG,KAAuB,GAC5C,kBAAc,EAAG,KAAmB,GACzB,WACO,YAAK,KAAoB,oBAAE,CAAE,CAEnD,MAHkB,CAAU,WAClB,kBAET,KAED,EAAW,YAAG,GAAiB,iBAA+C,OACpE,GAAK,EACb,G,kFClEF,UAGqB,IA2BC,eAAQ,GAAK,OAUjC,CAA+B,cACxB,OAED,QAAQ,QAAG,GAAO,OACR,cACM,iCACZ,oBAGJ,qBAAyB,QApBT,GAoBgB,OAC5B,QAGX,6BAvBD,WAuBC,mXCpDD,UACA,QACA,QACA,OAUwC,IACxC,EA0KC,kBA1KD,KAGE,CAA+B,cACzB,MAAG,GACR,CAG2B,0DAC1B,MACA,MAAQ,EAAO,KACf,GAAiB,OAAU,GAAY,YAAI,IAAM,KAAG,GAAa,aAAM,KAAG,GAAmB,mBAAM,KAAG,GAAO,OAAE,WAC7G,MAAW,GAAuC,KAAQ,GAAa,aACnE,cAAC,KAAU,KAAU,GACvB,IAAgB,GACb,QAAK,EAAoB,mBAC1B,MAAsB,GAA8B,KAAQ,GAAmB,mBAAI,IAAK,EACxF,oBAAW,EAAG,KAAQ,GAAO,OAAI,IAAiB,EAClD,SAAgB,EAAG,GAAI,GAAgB,iBAAiB,EAAK,KAAE,GAAI,GAAK,MAAM,EAAM,MAAO,EAAU,UAAkB,EAAI,GAAkB,EAAQ,QAAkB,EAAK,KAAkB,EAAQ,QAAkB,EAAc,cAAkB,EAC5O,YAAG,GAAI,GAAU,WAAK,EAAK,KAAM,EAAI,GAAY,EAAM,EAC/D,QACQ,QAAG,GAAI,GAAU,WAAK,EAAK,KAAM,EAAI,GAAM,KAAM,EAElD,WAAK,KAEtB,EAAE,CAEF,eAEM,GACP,GAGyB,CAAa,wDACrC,IAAc,GAEd,UAAQ,GAAO,KACf,GAAiB,OAAU,GAAY,YAAI,IAAM,KAAG,GAAa,aAAM,KAAG,GAAmB,mBAAM,KAAG,GAAO,OAAE,WAC7G,MAAW,GAA+B,KAAQ,GAAa,aAC/D,UAAc,EAAQ,EAAK,KAAE,KAAK,EAAK,OACpC,MAIH,iBAAQ,GAAW,EAEhB,MAAC,CAAS,EACD,mBAIZ,cAJe,GAAI,GAAU,WAAK,EAAI,EAEtC,eAEY,GAA8B,KAAQ,GAAmB,mBAAI,IAAS,EAClF,oBAAa,EAAG,KAAQ,GAAO,OAAI,IAAO,EAE1C,SAAW,EAAG,GAAI,GAAK,MAAQ,EAAM,MAAS,EAC9C,UAAgB,EAAG,GAAI,GAAgB,iBAAO,EAAK,KAAO,EAAU,EAAmB,mBAAQ,EAAQ,QAAQ,EAAK,KAAQ,EAAQ,QAAQ,EAAc,cAAQ,EACxJ,YAAG,GAAI,GAAU,WAAK,EAAI,EACpC,MAEF,WAEG,GACK,IADM,WAId,QAAQ,GAAG,WAAa,GAAa,aAAI,IACnC,CACc,0BACX,KAEH,mBAAC,IAAI,GAAU,WAAK,EAAI,EAC/B,UAE4B,CAAe,2DAC1C,MAAU,MAAG,GAAa,aAAO,OAClC,IAGmC,CAAyC,oEAC3E,MAAY,GAAa,EACtB,MAAC,CACI,QAAC,GAAU,WAGnB,mHAAuB,GAAa,EAAY,YAChD,GAAwB,EAAoB,EAAiB,iBAAoB,EAAiB,iBAAK,KACvG,iBAAU,MAAG,GAAa,aAAI,qBAAuB,GAAoB,qBAEnE,2BACP,GAGgC,CAAqC,iEACpE,MAAY,GAAa,EACtB,MAAC,CACI,QAAC,GAAU,WAGnB,+GAAuB,GAAa,EAAS,SAC7C,GAAwB,EAAoB,EAAiB,iBAAoB,EAAiB,iBAAK,KACvG,iBAAU,MAAG,GAAa,aAAI,qBAAuB,GAAoB,qBAEnE,2BACP,GAGkC,CAAuB,iEACxD,MAAY,GAAa,EACtB,MAAC,CACI,QAAC,GAAU,WAGnB,4HAAmB,GAAa,EAC7B,oBAAC,CACI,QAAC,GAAU,WAGnB,0FAAsB,GACtB,UAAQ,GAAO,KACf,GAAiB,OAAU,GAAY,YAAK,KAAM,KAAG,GAAa,aAAM,KAAG,GAAmB,mBAAM,KAAG,GAAO,OAAE,WAC9G,MAAe,GAAG,KAAQ,GAAa,aAAI,IAE3C,MAAsB,GACtB,KAAW,EACR,QAAU,EAAoB,mBACb,MAAY,EAEZ,qBAAG,KAAQ,GAAmB,mBAAI,IAAU,EAC3D,oBAAC,CACI,QAAC,GACT,WAEA,wDAAW,GAAG,KAAQ,GAAO,OAAI,IAAmB,EAC7C,WAAQ,EACX,OACJ,MAAW,GAAgB,EAC3B,MAAmB,EAAG,KAAQ,GAAO,OAC7B,MAAoB,oBACnB,OAAC,CAAO,EAAS,SAAO,EAAM,MAAiB,gBAChD,MAAG,GAER,UACM,EAAgB,EAEhB,GAAG,KAAQ,GAAO,OAAI,IAAC,CAAO,MAAO,EAAM,MAAc,cAAU,SAAO,EAEpF,UAED,IAAe,GACN,SAAe,EAClB,aAAe,EACZ,aAAe,EAClB,aAAe,EACZ,aACC,WAAe,EACV,uBAAe,EAG3B,eACU,uBAAmB,GAAI,GAAoB,EAGtC,QAAG,KAAQ,GAAmB,mBAAI,IACpD,QAAQ,GAAa,aAAO,OAAU,EAAG,GAAE,CAC3C,sBAEF,eAEM,GAAW,EAAqB,qBAAC,GAAI,GAAgB,iBAAc,EAAK,KAAe,EAAM,MAAqB,EAAe,EAAQ,QAAe,EAAK,KAAe,EAAQ,QAAe,EAAc,cAAe,EACvO,UACF,oFCzLD,UAAgC,IAEhC,EAEC,QAFgE,eACzD,OAAO,GAAY,YAAI,EAAO,EACrC,IAED,EAEC,QAFiD,aAC1C,OAAO,GAAY,YAAI,EAC9B,IAED,EAEC,WAFoD,aAC7C,OAAO,GAAe,eAAI,EACjC,kCCmFwC,aACjC,OACG,SAAO,EAAY,YAAU,CAChC,QAAO,EAAS,SAAQ,EAAO,IAC9B,SAAO,EAEf,gEArGD,UAKuC,GACvC,EAIwD,gBAJ0B,WAChF,GAAW,YAAK,KAAoB,oBACrC,IAGD,EAIiF,UAJ3C,WACpC,GAAW,YAAK,KAAiB,iBAClC,IAGD,EAOG,gBAPqD,WACtD,GAAW,YAAK,KAAoB,oBAAE,CAAI,GAAM,EACjD,MAMD,EAUG,2BAV0F,aAC3F,GAAW,YAAK,KAAgC,gCAAE,CAAa,cAChE,aASD,EASG,iBATH,UAEE,GAAW,YAAS,SACrB,cAOD,EAuBG,WAvBH,UACE,GAAW,YAAK,KACjB,iBAsBD,GAA8B,GAK3B,KACH,EAcsD,uCAdtD,UACE,GAAW,YAAG,GAAyB,yBAAiD,OACnF,CAAC,GACD,KAAM,GAA8B,EAEvC,cAAU,GAA6B,EACvC,GAAY,EAAO,EAChB,OACO,IACkB,MAGhC,MAAC,IAGD,EAGC,mBAHiE,WACtC,GAC1B,IAAW,YAAK,KAAuB,uBACxC,IAUD,EAEC,wBAFmD,WAClD,GAAW,YAAK,KAAqB,qBAAqB,EAC3D,KAED,EAKC,gBAL2C,WAAwC,KAClF,GAAW,YAAK,KAAoB,oBAC7B,OAAqB,EAG9B,GAAC,4BChHD,aAMA,iBACA,IACA,GAGA,iBAGA,gCAIA,8BAEA,GACA,EAnBA,QACA,QACA,YAmBA,YACA,kBACA,mBACA,iCCxBA,aAsCA,YAKA,OACA,MAEA,2BAlCA,aACA,IAuBA,IAWA,yBACA,wBA9CA,aACA,IAEA,8BACA,0BACA,yBAEA,EACA,oBCZA,aAEA,QACA,OACA,OAGA,YAA4B,QAmE5B,eAqDA,UAnDA,eACA,CAEA,GACA,GAGA,2BACA,OACA,IAGA,kBACA,QACA,QA4BA,KACA,SACA,OACA,UACA,OACA,WAEA,qBC7HA,aAEA,QACA,OACA,QAEA,WAA4B,QAC5B,kCA8BA,UA5BA,aACA,IAIA,aACA,iBAGA,QACA,gBAGA,SACA,gBAGA,MACA,GACA,WACiC,2CACjC,aADA,EACK,SAAY,CAEjB,sBAEA,GACA,oBCNA,aACA,kBACA,WAEA,aACA,+BACA,uDAGA,0CAEA,6BAEA,iBACA,OACA,aACA,GAEA,sCAGA,cACA,aAGA,cACA,YACA,SAEA,YACA,OACA,GAEA,gCACA,eAAe,MAAc,OAC7B,mBAEA,SACA,QACA,IACA,SACA,OACA,EAAG,SACH,CACA,QAGA,gBACA,OAEA,eACA,SAEA,kBAAyB,EAAQ,KACjC,eACA,GAIA,wBAAyB,EAAQ,KACjC,WACA,mBAEA,gCACA,GA7FA,sBACA,UACA,QAEA,+BACA,YAEA,UAGG,mCACH,sBAIG,qCACH,0BAWA,qBAFA,mBClBA,aACA,OACA,wDAGA,aACA,OACA,IACA,oBACA,kEACA,yDAEA,cAnBA,sCACA,uCACA,UAAC,IAED,kBAEA,cAKA,+BCPA,aACA,IACA,4BACA,SACA,GARA,YACA,6CAEA,qBCHA,eACA,WAGA,GAAC,kBAAqB,CAWtB,aAKA,iBACA,uDAEA,WACA,GACA,GACA,IAJA,EAMA,CAEA,iBACA,mBACA,IAEA,iBACA,kCACA,iCACA,YACA,IACA,GAEA,uBACA,0EAAiJ,uBAA2E,iBAAI,0BAA8D,aAC9R,KAEA,cACA,OACA,kBACA,sCACA,wCACA,IACA,uBAEA,WAEA,EAEA,CAEA,iBACA,cACA,IACA,gCACA,GAEA,CACA,oBACA,sBACA,IAEA,iBACA,WACA,IAEA,cACA,mBACA,qBACA,IAEA,cACA,wBACA,oBAEA,cACA,8BAA+C,kBAC/C,EAQA,CACA,iBACA,oCACA,cACA,6BACA,IACA,EACA,MAEA,iBACA,kBACA,IACA,eACA,UAAS,UACT,IACA,GACA,CACA,EAEA,oBACA,IACA,eACA,GAAK,UACL,QACA,GACA,EAEA,iBAEA,uBACA,iBACA,2BACA,QACA,kBAA2C,aAAO,GAClD,gBACA,aAEA,UACA,GACA,mBACA,gBACA,uBACA,iDACA,GAEA,EAEA,oBACA,QACA,oDACA,2CACA,kCACA,wBAA2C,UAAO,GAClD,oBAEA,IAAK,KACL,mBACA,gBACA,oBACA,oBACA,MACA,8BAAoE,WACvD,OACb,WACA,eACA,gBACA,GACA,CACA,4BAAyD,WAEzD,EACA,EAQA,cACA,IACA,oBACA,yBAEA,WACA,IAEA,cACA,mCACA,OACA,cACA,CACA,yBAAuC,UAAO,GAC9C,kBAEA,KAAK,sBACL,YACA,oBAEA,6EACA,cACA,QACA,kBAIA,YACA,IAEA,uBAEA,WACA,cACA,8BACA,oBACA,eACA,WACA,UACA,0EAEA,6BAAiE,4BACjE,IACA,CACA,8BACA,MACA,mBAEA,IACA,GACA,EAGA,CAiBA,cACA,cACA,2BACA,qBACA,iDACA,iBACA,KACA,uBACA,iBACA,OAAa,MACb,GACA,oBACA,aACA,2BACA,cACA,IACA,gBACA,IAAa,MACb,GACA,QACA,GACA,kBACA,gBACA,IACA,uBACA,IAAK,MACL,GAEA,CACA,cACA,oBACA,IAEA,cACA,cACA,OACA,IACA,kBAGA,yBACA,eACA,cACA,IACA,EAEA,kBACA,kBACA,eACA,yBACA,UACA,EAEA,kBAGA,eACA,aACA,sBACA,sCACA,gBAEA,kBACA,uBACA,kBACA,0BACA,2EACA,uDACA,gBACA,KACA,EAEA,kBACA,eACA,aACA,eACA,uBAEA,kBACA,oCACA,mBACA,oEACA,uDACA,GACA,EAEA,kBACA,eACA,eACA,sBACA,gBACA,gBAEA,kBACA,uBACA,kBACA,0BACA,2EACA,uDACA,2CACA,GACA,EAEA,kBACA,eACA,aACA,0BACA,0BACA,UACA,EAIA,kBACA,eACA,aACA,sBACA,6CACA,YACA,kBACA,gBACA,IACA,uBACA,IAAa,yBACb,oBACA,GACA,EACA,sBACA,UACA,CAIA,CAIA,kBACA,IACA,MACA,EAEA,CAMA,aACA,CAEA,sBAMA,UACA,aACA,MAAK,UACL,OACA,GACA,WACA,OAEA,kBACA,WACA,wBAEA,iEACA,4DACA,YACA,EAAK,QACL,KALA,GAOA,kBACA,kBACA,iHACA,kBACA,UACA,CAIA,CAcA,kBAMA,SACA,eACA,gBACA,GAaA,kBACA,2CACA,WACA,UAAK,4BACL,yBACA,EACA,QACA,KAKA,CACA,wBACA,SACA,mBACA,mBACA,qBACA,GAGA,kBACA,SACA,eACA,0BACA,sBACA,IA4EA,eACA,sBAwBA,kCACA,YACA,YAEA,UACA,CACA,oBACA,yBACA,EACA,qDACA,uBAEA,IACA,0BACA,kDACA,aACA,EACA,oCACA,GAEA,wBACA,GACA,EAEA,gBAEA,4BACA,WACA,UACA,2BACa,YAGb,qCAEA,sBACA,gBACA,IACA,uBAEA,uCACA,aACA,eACA,GACA,EACA,EACa,qCACb,uBACA,EACA,IAxEA,yBACA,OAEA,sBACA,mBACA,GACA,yBACA,UAAa,6BACb,IACA,EAAS,OAET,uBAEA,UACA,kBAEA,6BAAyC,UAAO,GAChD,kBAGA,WAEA,GAkFA,CAmGA,eACA,8CACA,6CACA,+BAQA,OAEA,yBAEA,MACA,uBACA,gBACA,mBACA,UAGA,2BACA,gCAGA,kBAIA,6BAHA,yBACA,uCACA,QAGA,aACA,iBACA,UACA,YACA,IAsFA,wBACA,2CACA,8CACA,kBACA,eACA,YACA,EAEA,CAsGA,kBAGA,IACA,gBACA,IACA,iDACA,6DACA,SACA,gDACA,6CACA,GAEA,OACA,oBACA,MAEA,SACA,KAAS,eACT,IAAK,UACL,OACA,GACA,EAEA,kBACA,YACA,IACA,kCACA,WACA,OACA,oBACA,iEACA,aACA,qBACA,gBACA,eACA,qDACA,KAEA,GAEA,MACA,OACA,QACA,MAEA,eAEA,WACA,cACA,iCAA2C,UAAS,GACpD,cAEA,eACA,kBACA,WAMA,QACA,kBACA,UACA,IAEA,OAEA,kBACA,IACA,iBAIA,+BAHA,uCAIA,cAEA,oDAEA,kBACA,SACA,IACA,kBACA,KAEA,qBACA,QACA,SACA,OACA,MAEA,QAMA,OAGA,aACA,OACA,MACA,aAEA,iBACA,aACA,4BAEA,gBACA,GAAK,UAEL,WACA,GAAK,QAEL,MACA,QAGA,OACA,cACA,kBACA,UACA,EAEA,qBACA,yBACA,WACA,qBACA,WACA,OACA,GAEA,GACA,aAKA,MAEA,iBANA,uBACA,YAEA,+BAIA,GACA,OACA,4BACA,oCACA,6BAEA,KACA,GAEA,kBAEA,yBACA,KAEA,cACA,eAEA,GAIA,CACA,aACA,OACA,KAEA,aACA,QACA,SACA,OACA,MACA,EASA,CACA,aACA,WACA,GACA,QACA,oBACA,GACA,YACA,UAAuB,KAAO,QAC9B,WACA,wBACA,GAEK,OACL,aACA,MACA,MAEA,aACA,QACA,GACA,6BACA,yCACA,GACA,uBACA,SACA,OACA,OAEA,QAEA,eACA,cACA,CACA,8BACA,EACA,SACA,IACA,kBACA,UACA,IACA,MAEA,eAIA,qBACA,uBACA,MAAK,YACL,IAEA,eAIA,eACA,OACA,4BAGA,OAIA,yBAHA,EAKA,CAKA,eACA,qBACA,IAEA,kBACA,QACA,oBACA,QACA,QAEA,MACA,aAEA,QAGA,kBACA,UAAS,UACT,QACA,GAAS,QACT,MACA,QAGA,QACA,IACA,CACA,EAEA,wBACA,QACA,oBACA,cACA,UACA,KAOA,eACA,0BACA,gCACA,UACA,wBACA,0BACA,WACA,GAEA,2BACA,QACA,MACA,aAEA,QAGA,aACA,GAAK,QACL,MACA,QAGA,GACA,EAIA,kBACA,IACA,OACA,mBACA,GAAK,WACL,eACA,QACyB,mBACzB,IADA,4BAEA,qCACA,sBACA,eACS,QACT,oCAAyD,QACzD,UAEA,YACA,8BACA,kCAEA,yBACA,yBACA,GAAiB,WAEjB,IAEA,sCAEA,GAAK,WACL,CAqDA,CAWA,kBAEA,kBACA,8BACA,EAaA,CAuBA,kBAEA,gBAoFA,WACA,SACA,gBACA,KACA,YACA,yBAEA,WACA,UAEA,sBAkEA,oCACA,cACA,yBACA,2BACA,iBACA,UACA,GAEA,mCACA,gCACA,QACA,uBACA,4BACA,GAAiB,SACJ,wBACb,GACA,EAEA,sBAGA,cAgEA,kEACA,SAEA,IAlEA,gCACA,0BACA,EAAS,GACT,+BACA,4FACA,YAEA,gCACA,wBACA,EACA,iCAEA,mBACA,QACA,cACA,eACA,UACA,oBACA,gBAEA,kCACA,iCACA,QAEA,iCACA,OACA,8BACqB,gDACrB,0BAEA,iCACA,OACA,GAEA,iCACA,mBACA,YACA,GAEA,8BACA,gBACA,GACA,EACA,CACA,WACA,qBACA,2BACA,wBACA,GAEA,EACA,uBACA,aAEA,gBAEA,eACA,GACA,CACA,EAGA,uBAKA,OACA,GACA,EAEA,mBACA,QACA,CACA,OACA,OAEA,wBACA,wBAEA,iBACA,WACA,UACA,QACA,mBACa,SACb,QACA,MACA,OACA,GACA,YACA,OACA,OAEA,0CAEA,OACA,2BACiB,QAEjB,WACA,gBACA,uBACA,wBAEA,iBACA,WACA,UACA,uCACA,gBAD6D,GAE7D,oCACA,oCAEA,GACA,CACA,CACA,OACA,GAEA,yBAEA,8CAAgF,qCAAwD,MAAI,kBAC5I,qCACA,OACA,GACA,GACA,EAEA,mBACA,4BACA,iCACA,oCAEA,QACA,EAEA,mBACA,YAAuB,+BAAyC,OAChE,+BACA,IACA,sCAGA,GAEA,mBACA,mCAAkD,gCAClD,OAEA,gBACA,yBACA,GAQA,sBAeA,wBACA,QACA,wCACA,oBACA,EACA,0BACA,iBACA,GACA,EACA,oCACA,yCACA,cAEA,UACA,YACA,GACA,EAAa,oBAWb,sCACA,OACA,GACA,EAKA,EAEA,sBAiYA,WACA,eACA,wCACA,cACA,eACA,gBACA,gBAEA,yBACA,EAEA,sBA0HA,wBACA,GAEA,sBACA,8BACA,SACA,QACA,IACA,EAEA,4BAGA,8BACA,WACA,aACA,kBACA,UACA,cAA+B,QAAS,GACxC,qBACA,sBACA,yCACA,OACA,KAEa,QACb,WAEA,UACA,MAFA,eAGA,YAAmC,KAAS,QAC5C,IAAmC,wBACnC,gBACA,2BACA,wBACA,gBACA,cACA,2BAA+F,IAC/F,EACA,CAAiB,cACjB,8BACA,IACA,EACA,EACA,CAAS,YACT,GAEA,yBA6TA,QAOA,aACA,aACA,mBACA,iBACA,wCACA,yBACA,UACA,uBACA,oBACA,OACA,2BACA,oBACA,iBACA,kBACA,4CACA,aACA,cACA,EAAS,YAET,oCACA,gBACA,MAAS,cACT,yBACA,wEACA,WACA,aACA,GACA,EAEA,sBA6IA,WACA,OACA,yBACA,gBACA,cAEA,GAEA,mBAyZA,QACA,QACA,cACA,IACA,IAAS,UACT,IACA,EAEA,WACA,WACA,gBACA,OACA,YACA,mFACA,WACA,GACA,gBACA,cACA,aACA,YACA,kBACA,KACA,qBACA,YACA,QACA,eACA,SACA,+BAEA,KAEA,mBACA,+DACA,aAEA,cAoZA,eACA,UAEA,mBAyOA,gCACA,OAEA,yBACA,wBACA,+BACA,4BACA,mBACA,GACA,EACA,EAEA,gBACA,wBACA,cACA,mCAEA,GACA,EAEA,+BAGA,6BACA,qBACA,GAAS,EAET,YAEA,+BACA,kBACA,eACA,WACA,aACA,kBACA,IACA,UACA,oBACA,IACA,EAAqB,qCACrB,IACA,EACA,GACA,IACA,KAEA,KAAa,EAEb,gBACA,WACA,aACA,kBACA,IACA,UACA,6BACA,IACA,EACA,GACA,IACA,KAEA,KAAa,EAEb,GAEA,gBAGA,IACA,gDACA,OACA,wCAEA,2DAEA,2FACA,KACA,GACA,EAEA,mBACA,kBACA,GAEA,mBACA,uBACA,EAEA,mBACA,uBACA,EAEA,mBACA,kBACA,GAEA,mBACA,kBACA,GAEA,mBACA,2BACA,CAEA,mBACA,2BACA,CAEA,mBACA,wBACA,gDACA,UAAS,KACT,EAEA,cACA,wBACA,gBACA,+BACA,GACA,4CACA,mCACA,2BACA,UACA,qCACA,yFACA,IACA,SAA2B,sBAA6B,YACxD,2BACA,WACA,qCACA,oGACA,YACA,GACA,qBACA,MACA,kCACA,IAEA,mBAMA,kBACA,oBAAuB,QAAuB,YAC9C,WACA,sBACA,iBACA,eAA2B,mBAA6B,YACxD,sBACA,oBACA,sDACA,cACA,yBACA,iBACA,GACA,CACA,CACA,CAEA,gBACA,uBAEA,0BACA,wCACA,QAAS,mBACT,oCACA,GACA,EAEA,WA1pFA,kBAEA,WACA,OACA,yBACA,yBACK,aACL,UACA,aACA,eACA,gBAEA,oBACA,aACA,MACA,MAEA,SACA,QACA,KACA,MACA,SACA,cACA,eACA,2BAEA,IACA,EACA,4BAEA,IACA,EACA,GACA,cACA,IATA,GAIA,GAOA,4BAkCA,+BACA,2EACA,iCACA,0BACA,EAAS,GACT,aACA,cACA,YACA,YACA,IACA,GAEA,iBAYA,oBAeA,4EAGA,MACA,8BAEA,cACA,aAEA,oBACA,4CAGA,oBACA,gBACA,+DACA,UACA,IACA,IACA,sBAEA,QACA,yBACA,0DACA,UACA,4BACA,GACA,IACA,kCACA,4BACA,kBACA,IACA,gBACA,WACA,wCACA,+EACA,gCACA,gCACA,2FACA,6GACA,OACA,EAAyB,GACzB,GACA,0BACA,GACA,CACA,EAGA,oBAwLA,qCAEA,kCAA2F,mBAC3F,GAEA,+CACA,wBACA,GAIA,8BAwCA,uDACA,QACA,KACA,GAGA,sBAFA,gCAGA,EACA,mBACA,OACA,GACA,EAAS,YACT,GAWA,aAEA,sBACA,oCACA,qBACA,EACA,wBACA,MACA,SACA,KAGA,aAGA,MAEA,8CACA,gBACA,OACA,KAGA,iBAQA,wBAEA,oOACA,6CACA,gDACA,qBACA,sCACA,UACA,kCAKA,YACA,MAEA,kBACA,iCACA,yCACA,yCACA,iBACA,EAAiB,KACjB,kBACA,mDACA,0BACA,GACA,CAAa,EAEb,8BAEA,OACA,WACA,eAEA,OAAmD,aACnD,gCACA,8CACA,IAAqB,UAErB,CAGA,mCACA,IACA,wCACA,GAEA,GAEA,mBACA,uCACA,GAGA,GACA,IAAa,EACb,GAAS,oBAKT,2BACA,KAAS,kBAET,OACA,OACA,EAAS,qBACT,IAEA,QACA,OAAa,WACb,OACA,UAEA,WACA,SACA,GAAS,qBACT,CACA,MACA,IACA,EAEA,uBACA,mBACA,2BACA,MACA,IACA,IACA,OAAa,WACb,IACA,IACA,CACA,gBACA,sBAEA,0BACA,IACA,EACA,4BACA,IACA,EACA,EAEA,wBACA,QACA,gDACA,cAOA,IACA,iCACA,8BACA,CACA,mBACA,mBACA,iCACA,EAEA,GACA,IACA,oBACA,kBACA,EACA,oCApBA,wCACA,WAEA,IAEA,IAeS,YACT,GAEA,2BACA,OACA,GAEA,wBACA,OACA,UACA,2BACA,OACA,UACA,mCACA,OACA,GAKA,YAGA,mBACA,eAEA,+BACA,WACA,GACA,EAMA,iEAA6E,WAC7E,+DACA,mFAEA,2EACA,uBACA,kBACA,CAEA,2BAEA,WAGA,SAEA,yBACA,yBACA,4BACA,GAEA,GACA,EACA,CAEA,gBACA,oDACA,4BACA,OAEA,sCASA,gBA2DA,QACA,kCACA,qBAEA,4BAGA,yCAEA,aAEA,GAEA,kBAEA,YAIA,mCACA,WACA,GACA,WAEA,OACA,+BAEA,mBACA,IACA,kCAEA,kCAC6B,8CAC7B,kKAGA,WAAqB,+BACrB,eACA,cACA,WAAqB,kBACrB,OACA,GAAqB,qBAErB,mBACA,OACA,GAEA,EACA,EACA,GACA,kBA5GA,4CAGA,yCACA,GACA,yBAEA,UACA,eACA,UAEA,gDACA,cACA,sDAEA,OAIA,2BACA,iCACA,8CACA,yFACA,GAKA,yBAAiE,+BAA6D,kEAE9H,UAEA,uBACA,MAEA,MACqB,sCAErB,0FACA,2BACA,SACA,iCAEA,MAC6B,kDAE7B,uCAEA,EACA,CAAS,UACT,2CACA,IACA,GAAa,SACb,GAEA,mDAEA,GAqDA,yBAEA,yBACA,aACA,0CAEA,6BACA,GASA,iBAmBA,0BACA,WACA,oEACA,GACA,8BACA,sBAIA,sCACA,GACA,qBALA,cACA,cACA,mEAIA,GAKA,qBACA,QACA,gDACA,kBACA,gCACA,kBACA,8BACA,4BACA,QAAiB,EACjB,GAAa,QACb,GACA,oBACA,oBACA,GACA,oBACA,kCACA,GACA,qBACA,mCACA,GACA,oBACA,kCACA,GACA,oBACA,4BACA,SACA,qBACA,gCACA,GACA,mBACA,iCACA,GACA,sBACA,oCACA,GACA,sBACA,wCACA,IAEA,yBACA,mCACA,MAEA,4BAQA,yBACA,2BACA,WAEA,UAEA,iCAIA,sBACA,cAEA,4BAEA,wBACA,mBACA,WACA,GAAqB,WACrB,CAAiB,MACjB,GAEA,qBACA,oDAEA,+BACA,uBACA,IACA,EACA,0BAOA,2CACA,GAUA,0BAiDA,wBACA,kCACA,yCACA,mBACA,GAEA,wDAEA,EACA,yBACA,QAEA,gDACA,2EACA,yHACA,0HACA,+EACA,yBACA,kBAAgE,8EAChE,IACA,EAEA,YAEA,UACA,GAJA,GAEA,2DAMA,OACA,uBAAuD,UAAO,GAC9D,2CACA,gBAIA,oBACA,oBACA,GAAiB,KACjB,2CACA,gBACA,QAEA,8BACA,yBACA,IACA,MAGA,+CAKA,OACA,SAAqB,qBACrB,oBACA,0BACA,IAAqB,wBACrB,OACA,QAAqB,kBAErB,QACA,UAEA,oBAA8D,KAAQ,MACtE,WACA,kBACA,kBACA,iBACA,sBAOA,iBACA,iBACA,wBACA,GAAqB,oBAErB,qBACA,mBACA,KAEA,cAjCA,qCAmCA,iBACA,UACA,IAAqB,SACrB,GACA,CAAa,EACb,SACA,yBACA,QACA,2BACA,mDACA,gBAKA,kBAAgE,8EAChE,IACA,2EANA,yHACA,0HACA,+EACA,SAKA,aAGA,OAJA,GAEA,GACA,aAMA,WACA,QACA,YACA,eAEA,kBACA,oBAA2D,UAAO,QAClE,IAAuC,wBACvC,oBACA,UACA,qBACA,+BACA,cACA,WACA,SACA,YAEA,QAGA,uBACA,8BACA,SACA,eACA,+BAEA,IACA,CAAqB,cACrB,8BACA,IACA,EAEA,oBACA,uBACA,GAAiB,KAIjB,OACA,uBAAuD,UAAO,GAC9D,2CACA,gBAIA,oBACA,oBACA,GACA,CACA,EACA,qBAMA,2BACA,mDACA,QAA+B,wBAC/B,gBACA,oCACA,uCACA,cAEA,sCAA4F,OAE5F,GACA,IACA,wBACA,8BACA,iBACA,gCAGA,WACA,oBACA,OACA,GACA,EAAiB,UACjB,8BACA,IACA,EACA,CACA,EAEA,qBAMA,QACA,2BACA,2BACA,yBAKA,mCAEA,sEACA,YAGA,4BAGA,QAEA,aACA,gDAGA,YACA,EAAyB,oBACzB,OAGA,kBAEA,IAEA,EAAyB,qBACzB,IACA,SAAyB,WAEzB,IAGA,uCACA,2BACA,gCACA,6BACA,WACA,8BACA,cACA,OACA,CAEA,EAEA,uBAEA,uCAGA,oCAGA,6CACA,kBACA,kBACA,2BACA,OACA,OACA,CAEA,EAEA,kBACA,uCAGA,2BAEA,6CACA,WACA,sBACA,2BACA,OACA,OACA,CAEA,EAEA,wBACA,6DACA,oEAEA,4BACA,YACA,IACA,mCACA,uGACA,wCACA,GAEA,4CAEA,GAUA,mBAyCA,iBACA,cAEA,eACA,0DACA,MACA,IACA,oBACA,UACA,QACA,oDACA,oDACA,2BACA,WACA,aACA,GAAqB,WACrB,CAEA,OACA,KACA,oBAWA,0CACA,IACA,qBACA,QAEA,gBACA,gBACA,iBACA,UAEA,kDACA,QAEA,qDACA,IAEA,gCAGA,kCACA,6BAEA,6FACA,gCACA,IACA,kBACA,MACA,6BACA,IACA,iCACA,UACA,8BACA,GACA,8BACA,IACA,aACA,UACA,GACA,IACA,6BACA,QACA,WAEA,gCACA,kCACA,+BACA,GAAiB,EACjB,IAAa,gBACb,wCACA,gDACA,gDACA,gBACA,iBACA,GAAiB,aACjB,gEACA,IACA,SACA,GACA,EAEA,aACA,oBACA,GAKA,kBACA,kCACA,YACA,SAEA,SACA,uCACA,sCACA,cACA,IACA,EAAa,EAGb,qEACA,2BACA,GAEA,8CACA,wBACA,GAEA,8CACA,2EACA,iCACA,GAWA,8BAgBA,sBACA,mDAEA,oDACA,IACA,EAEA,gBACA,2CACA,gBACA,GAAa,SACb,EAEA,gBACA,+BACA,WACA,aAAa,cACb,WACA,aACA,CACA,gBACA,+BACA,WACA,aAAa,cACb,WACA,aACA,CACA,+BACA,kCACA,YACA,KAA2B,QAAY,QACvC,UACA,YACA,mEACA,2DACA,6CACA,GAEA,0BACA,GACA,kDACA,iDACA,sDACA,EAEA,yBAEA,gBAcA,OACA,UACA,sBACA,6BACA,OAA4B,uBAC5B,IAAiB,uBACjB,uBACA,MACA,yBACA,WACA,KACA,yBACA,WACA,KACA,MACA,qBACA,EACA,WAvBA,OAPA,GACA,GACA,GACA,GACA,GACA,GACA,4BAEA,OACA,mBACA,gBAEA,OAoBA,kDACA,gCACA,GAEA,qCAEA,IACA,GAEA,SAEA,4CAIA,WACA,2BACA,mBACA,gBACA,IAEA,oBACA,QAAqD,SAAgB,GACrE,kCACA,8BAA0G,aAC1G,kBAGA,IASA,MARA,cAMA,iBALA,gBACA,GAEA,KAKA,GACA,EAKA,OACA,8BASA,IACA,WACA,WACA,2DACA,6CACA,4BACA,GACA,EAAiB,UACjB,gBACA,GACA,CACA,qBACA,+CACA,gBACA,GACA,EACA,oBACA,+CACA,sBACA,MACA,EACA,2BACA,+CACA,sBACA,GACA,EACA,oBACA,+CACA,sBACA,MACA,EACA,2BACA,+CACA,sBACA,GACA,EACA,yBAEA,8CAEA,kBADA,GAEA,mCAEA,+BACA,2BACA,OACA,sBAAiB,OACjB,GACA,+BAEA,+BACA,gBACA,EAAiB,OACjB,GACA,4BACA,mBACA,mCACA,6BACA,QACA,kBAAiB,KACjB,GACA,sCACA,mBACA,mCACA,6BACA,4BACA,OACA,mBACA,EAAiB,KACjB,GACA,kBACA,mBACA,cACA,MACA,SACA,GAAiB,UACjB,gBACA,GACA,4BACA,oDACA,oCACA,GAEA,qCACA,mBACA,WACA,GACA,SACA,4CACA,eACA,IAEA,oBACA,aAEA,OAIA,UAHA,aAQA,kCACA,gBACA,IAGA,MACA,GACA,EAEA,uBACA,iDAA+E,kBAC/E,kBAEA,mBACA,mBACA,2DACA,SACA,SACA,GAAiB,UACjB,gBACA,GAEA,iCACA,4DACA,IAAiB,EACjB,sCACA,wBAAgD,kBAChD,kBAUA,4BACA,mBAWA,oBAAsD,aAAO,GAC7D,cACA,yCACA,mBACA,sBACA,IACA,KAEA,yBACA,IACA,EAEA,mBAEA,oBACA,GAGA,gBAsBA,oBACA,GAEA,aArDA,gCACA,+BACA,wCACA,kBACA,kJAEA,qCACA,6BAEA,iBAcA,GAMA,MACA,cACA,eACA,GAAiB,UACjB,gBACA,GAEA,QACA,oBACA,OACA,mBAAiB,cACjB,OACA,oBAEA,oBACA,OACA,mBAAiB,cACjB,OACA,oBAEA,KAMA,sCACA,kDACA,GAEA,4CACA,CACA,gBACA,MAEA,QACA,MAEA,YACA,GAEA,qCACA,eACA,OAEA,QACA,aAEA,OAIA,UAHA,kBAMqB,4BAMrB,sCACA,4BAAwF,uBACxF,GAGA,OACA,GACA,EACA,4BACA,mBAEA,uCACA,OACA,mBACA,oBAIA,yCACA,cACA,GACA,YALA,4CAOA,EASA,4BA+CA,mBACA,wBACA,GAEA,sBACA,WACA,0CACA,gBACA,KAAa,EACb,qBACA,EAEA,mBACA,0BACA,GASA,mBACA,uBACA,wCACA,kFACA,sCACA,KAWA,mBACA,cACA,sIACA,OAEA,4BACA,2DACA,UACA,aAEA,cAIA,UACA,IAEA,sBACA,yBACA,sBACA,gBACA,SACA,gBAEA,IACA,CAEA,IAhBA,UAEA,0BAeA,wDACA,YACA,+DArBa,YAsBb,gBACA,wBACA,gBAEA,OAMA,sBACA,aACA,yDACA,OACA,MAAmB,kCACnB,GACA,qBACA,aACA,yDACA,OACA,MAAmB,4BACnB,SACA,4BACA,aACA,kCACA,GAEA,gCACA,8BACA,GAEA,oBACA,uCACA,iCACA,sBACA,YACA,GACA,EAEA,gBACA,8BACA,KACA,IAMA,mBACA,aAEA,WACA,WACA,+BACA,qEACA,YACA,UAA8B,mBAC9B,IAEA,qCACA,gBACA,GACA,EAEA,oBACA,iCACA,gBAEA,WAEA,2CACA,cACA,sCACA,sBACA,6BACA,iCACA,OACA,CAAqB,EAGrB,WACA,sCACA,iBACA,CACA,aAAyB,YACzB,IACA,GAAyB,KACzB,GAAqB,EAErB,GAEA,wBAEA,mBAIA,4BACA,MACA,GACA,mBAGA,cACA,aACA,8BACA,CACA,sBAbA,gBACA,gBACA,+BAMA,kCAMA,gBACA,GAAiB,QACjB,GAEA,sBACA,aACA,yCACA,eACA,iDAGA,8BACA,cACA,mEACA,qBACA,iDACA,IACA,WACA,IAA6B,UAC7B,IACA,GACA,CACA,GAAqB,KAErB,IACA,yBACA,SACA,GAAyB,YACzB,IACA,GAAyB,KACzB,GACA,CAAiB,EACjB,GAEA,qBACA,aACA,kBACA,iBACA,MACA,oBACA,QACA,yBACA,OACA,UACA,QAEA,uBACA,YACA,OACA,CAEA,OACA,CAEA,mBACA,QACA,oBACA,OACA,OACA,CAEA,GACA,KAEA,oBACA,iDACA,2BACA,QACA,4BACA,oBACA,IACA,KACA,CACA,MACA,IAEA,uBACA,aACA,sBACA,oCACA,cACA,YACA,IAIA,GACA,GACA,IAEA,oBACA,0CACA,WACA,EAAiB,QACjB,GAEA,mBACA,6BACA,GAEA,qBAEA,uBACA,gCACA,cACA,MAGA,gBACA,IACA,IAEA,kBACA,oBACA,GAEA,iBACA,kCACA,KAEA,oBACA,oDACA,kEACA,KACA,IAEA,iBACA,aACA,SAEA,sBACA,aACA,4BACA,iCACA,WACA,GACA,EAEA,4BACA,yBACA,sBACA,GAEA,6BACA,aACA,4BACA,iCACA,kBACA,GACA,EAEA,mBACA,aACA,qBACA,WACA,uCACA,YACA,IAAiB,kBACjB,OACA,GAAiB,QACjB,GAEA,0BACA,aACA,wCAGA,+CACA,cACA,2EACA,qBACA,oBACA,GAAqB,QAErB,oBACA,WACA,uCACA,YACA,WAAiB,kBACjB,OACA,GAAiB,QACjB,GAEA,yBACA,yBACA,mBACA,GAEA,uBACA,uCACA,WACA,EAAiB,QACjB,GAEA,sBACA,gCACA,GAEA,qBACA,aACA,+CACA,+BACA,SACA,uCACA,sBACA,mBACA,cACA,QACA,EACA,GACA,IAEA,EAOA,yBAUA,oBACA,QACA,aACA,iBACA,oBACA,oBAEA,+CAAmE,uBAA2C,kCAE9G,mDACA,gBA8GA,OACA,cACA,YAEA,2DACA,IAEA,cACA,oBACA,iBAA4D,QAE5D,IACA,IAzHA,OAEA,sCAEA,EAKA,eACA,UACA,kCACA,oBAEA,sCAC6B,QAE7B,kBACA,0CACA,IAEA,aACA,iCACA,YACA,IAEA,GACA,CAEiB,iBAEjB,WACA,UACA,sBACA,QACA,UAAuC,KAAa,QACpD,WACA,UACA,eACA,aACA,IAEA,MACA,OACA,GACA,CAAiB,KAGjB,QACA,QACA,mBACA,IACA,6CACA,oBACA,+BACA,WACA,eACA,aACA,IAEA,MACA,aACA,KACA,EACA,CAEA,QACA,KACA,EACA,MACA,MACA,SAEA,8CACA,gBASA,CAIA,eAHA,eACA,SACA,OAGA,OAdA,kBACA,YACA,iBACA,aACA,aAGA,gCASA,cACA,SACA,iBACA,oCACA,mBACA,iBACA,8BACA,CACA,KACA,IACA,EAAyB,EACzB,GAAqB,SAErB,2BAEA,MAEA,YAcA,CACA,MACA,IAAiB,KACjB,GACA,EAEA,qBACA,QAEA,aACA,WACA,gCACA,aACA,uCAMA,yCAEA,WACA,0BACA,mBACA,0BACA,WACA,mBACA,4BACA,mBACA,0BACA,WACA,GACA,CAA6B,cAC7B,WACA,GACA,EACA,CAOA,UAEA,mDACA,QAEA,cACA,wBACA,KAEA,qBAEA,MAIA,mBACA,kCAGA,2BACA,OAAqB,iBAErB,YACA,WAAqB,kBAErB,kCACA,oBACA,GAAyB,WACzB,mBACA,GAAqB,kBACrB,WACA,kBACA,GACA,eACA,IACA,EAEA,KACA,KACA,EAWA,WA6KA,YACA,SACA,eACA,WACA,eACA,uBACA,kBAGA,eA5nFA,mCAKA,wFAA2J,mHAC3J,uDAOA,OACA,+BACA,oFAA+H,qHAC/H,GACA,EAUA,CAmmFA,0BACA,IACA,GACA,GAKA,eACA,IACA,gCACK,UACL,iBACK,gCACL,IACA,oBACA,IACA,EACA,OAEA,IAEA,kBACA,mCACA,cACA,YACA,EACA,GACA,GAEA,eACA,oBACA,cACA,OACA,EAEA,eAUA,uBACA,WACA,aACA,aAEA,mBACA,iBACA,WACA,GAAK,EACL,IAEA,eACA,oBACA,CAGA,UAFA,iBACA,SAEA,EAEA,eACA,uBAGA,WACA,aACA,YAEA,mBACA,QAIA,cAHA,OACA,OACA,MAEA,GAEA,eACA,IACA,oBACA,qBACA,mBACA,iBAEA,eACA,wBAEA,aADA,gBAEA,WACA,kDACA,KAAK,UACL,CACA,KACA,IACA,qDAEA,KAEA,eACA,gBAUA,oBACA,WACA,UAEA,kEACA,wCACA,CAEA,oBAjBA,gBACA,GACA,QAIA,OAEA,eALA,iBACA,GACA,aAaA,KAIA,CACA,iCAQA,WACA,gBACA,eACA,cACA,aACA,iBACA,eACA,8DACA,kDACA,EAIA,CACA,wBAKA,WACA,uBACA,yBACA,2BACA,oBACA,qCACA,gBACA,GACA,EAIA,CAEA,eACA,4BACA,GAEA,eACA,qCACA,2CACA,GAEA,CA3vIA,cACA,cACA,4FAWA,kBAAgB,uGAqMhB,2BACA,IACA,2CACA,GAAC,YACD,OACA,KAEA,EAQA,sBAuIA,8BACA,8EAQA,CACA,QAEA,0BAwCA,2YAEA,OACA,gBACA,uEACA,iCACA,0CAKA,+CAYA,yBACA,OACA,eACA,yEACA,GAEA,sBACA,4BACA,OACC,IAqBD,eAQA,WASW,IACX,gCACA,0BACA,EAGA,kCASA,mBAEA,SACA,eACA,GACA,GAGA,kCACA,kBACS,MACT,kDACA,mBAEA,0BARA,cACS,KAQT,WAdA,qBAeA,KAvBA,WAwBA,GACA,EAEA,MACA,sBACA,kBACA,oBAEA,gCACA,0BACA,IACA,EAAK,kCAeL,sEACA,KACA,EAAK,MAEL,kBACA,iBACA,gBA6GA,GAGA,UACA,IAUA,YACA,aACA,8BACA,iBACA,UACA,+BACA,sCACA,CACA,QACA,IAAK,cAAsB,CAC3B,oCACA,IAGA,EACA,UACA,eACA,EAOA,oBACA,aACA,KACA,KACA,KAEA,MAEA,EACA,MACA,MACA,MACA,SACA,QAEA,EAiBA,GAhBA,CACA,cACA,EACA,0BAEA,sBACA,qCACA,IACA,aACA,GAAa,WACb,CACA,EAGA,GAGA,SACA,EAwBA,MAwCA,eAEA,qBACA,QAEA,8BACA,uBACA,IACA,uDACA,MACA,EAEA,uBAEA,6BACA,IAEA,oBACA,+CAEA,qBACA,gBACA,0DACA,CAGA,kCAEA,GAAS,8BACT,CAIA,kCAEA,GACA,EAEA,sBACA,8BACA,OACA,MACA,EAAS,cACT,OACA,SACA,GACA,EAGA,uBACA,QAIA,iDAGA,uBAEA,gDACA,uCACA,GAIA,GACA,IAEA,QACA,eACA,4BACA,UACA,CACA,gBACA,QA7MA,eA8MA,6DACA,IACA,EAAa,QACb,CACA,KACA,CAEC,KAWD,KACA,eACA,qBACA,wCACA,gBACA,iBACA,iCACA,wCACA,QACA,YACA,GAAiB,EACjB,GACA,EACA,EAEA,sBACA,yBACA,wDACA,YACA,GACA,gBACA,GAEA,SAEA,kBACA,qBACA,wCACA,oBACA,+BACA,GACA,EACA,EAEA,MACA,eACA,OACA,GACA,kBACA,WACA,EAGA,UAEA,UAEA,aACA,eACA,OACA,GACA,kBACA,IACA,EAGA,mBACA,eACA,OACA,GACA,kBACA,IACA,EAGA,sBACA,8BACA,0BACA,QACA,MACA,6BACA,4BACA,QAKA,kBACA,gDACA,GACA,EAAiB,KACjB,UACA,IAAa,KACb,GACA,EAEA,aAAsB,QAGrB,GAsQD,YACA,iDACA,WAtQA,mBACA,sDACA,yDAOA,aAkUA,4BAsFA,YAEA,mBACA,sBACA,eACA,GAAS,EACT,EACA,CAAC,GAqBD,OACA,QACA,yBACA,IACA,CACA,kCAAK,UACL,OACA,GACA,CACA,OACA,uGACA,mBACA,6EACA,cACA,MACA,kBACA,0CACA,KAEA,UAgrFA,kBACA,EAAiB,qEAwZjB,MA5OA,MAIA,IACA,KAKA,oBACA,eACA,UACA,yCACA,wBACA,IACA,IACA,EACA,EAKA,qBACA,2CACA,CAEA,UADA,UACS,0CACT,CACA,QACA,EAKA,+BACA,8BACA,WACA,iBAEA,QACA,8BACA,uBACA,GACA,gBACA,GACA,qBACA,CAEA,UADA,MAGA,EAAS,QACT,GAEA,0BASA,CAMA,mBAHA,2BACA,GACA,CAGA,iBAEA,iCAsBA,iCACA,IACA,IAEA,kBASA,qBACA,WACA,cACA,IACA,EAEA,oBACA,kBACA,IACA,yBACA,kDAEA,cADA,GACa,UACb,WACA,GACA,CACA,CAEA,0BACA,IACA,uBACA,+CAEA,cADA,GACS,UACT,WACA,GACA,CAGA,qBACA,eACA,kBACA,IAIA,WAMA,SACA,eACA,OACA,GACA,kBACA,8BACA,CACA,QAAa,EACb,GAIA,UACA,SACA,QACA,WAEA,SACA,UAAa,kBACb,OACA,GAEA,iBACA,eACA,EACA,aArxIA,eACA,0BAA2E,qDAC3E,MACA,UACA,iBAkxIA,YACA,gBACA,OACA,SAEA,GAEA,sBAEA,uBACA,gBAGA,aACA,eAUA,gBAEA,mFACA,2DAIA,0BACA,yCACA,iBACA,GAAK,4BACL,0BACA,KACA,oBAKA,WACC,KAED,YAGA,yGACA,iBAEA,GACA,GAEA,gBAn9HA,eACA,4GACA,0CACA,mBAEA,kBAA8B,eAC9B,mBACA,KAEA,IACA,EAEA,EAw8HA,YACA,wBACA,UACA,KAAC,GAID,EACA,oBC3/IA,aAUA,iBACA,IAEA,oBACA,qBACA,aACA,SACA,OACA,UACA,OACA,WAGA,mBAGA,OACA,WACA,EACA,YACA,wBACE,UAEF,WACA,oBAA4B,oBAC5B,gBACA,OACA,eAIA,MACA,OACA,eACA,UAEA,GAEA,eACA,SAEA,gBAIA,eACA,YAEA,mBAEA,IAEA,eACA,UACA,eAGA,IACA,EAEA,iBACA,IACA,GAEA,WAAuB,KAQvB,MACA,kBAGA,MACA,YAGA,aACA,GA1FA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,gBAqFA,yBACA,gCAGA,aAEA,mDACA,OACA,aACA,WACA,aACA,SAIA,WACA,iBACA,mBAEA,IAEA,gCAEA,SACA,KAEA,GAvBA,4BAwBA,wBAEA,GACA,GAEA,2BAEA,wDACA,UACA,MACA,IAEA,2BAEA,wDACA,UACA,MACA,IAEA,6BACA,sBACA,IAEA,+BACA,aACA,4BAEA,0CAEA,GACA,GAEA,8BACA,aAEA,eACA,2BAGA,uFAEA,oBACA,wBACA,qBAGA,SACA,GAEA,iCACA,2BACA,oBCxKA,CAEA,gBAIA,IAEA,EAQA,QAEA,WACA,oBACA,IACA,sCACA,uBAGA,mFACA,gBACA,qBACA,mBAMA,4BAEA,IACA,UAUA,yBAGA,OACA,4BAGA,oBAIA,SAGA,KACA,gBCjEA,aAEA,2BACA,sCACA,2BAEA,sBACA,4DACA,mCAEA,sBACA,2DACA,mCAEA,oBACA,kCACA,IAEA,uBACA,sDACA,qDCTA,iBACA,IACA,yBACA,EAGA,SACA,IACA,+CAGA,yDACA,KAA+B,mBAC/B,CACA,IAEA,KAEA,EACA,EACA,EAEA,KAA0B,mBAE1B,CACA,4BACA,kBACA,KAGA,UACA,EACA,GA3CA,QACA,GACA,WACA,kBAEA,MACA,IAEA,YACA,OAoCA,aAEA,IACA,iBACA,MAAG,SACH,uBACA,kBAEA,cAEA,EACA,oBCnDA,iBACA,uBACA,aACA,GACA,GAMA,eACA,wBACA,GAEA,eACA,SACA,SACA,QAEA,QACA,qCACA,mBACA,qCAEA,gCACA,oBACA,oBACA,GAQA,SALA,YACA,YACA,QAHA,IAKA,MAvCA,YACA,OAUA,aACA,wBACA,IAVA,4BCEA,eACA,kBACA,oBAEA,sBACA,EAGA,sBACA,MACA,kBAEA,mBAAiB,QAAoB,OACrC,cACA,qDACA,EAGA,SACA,SAEA,iBACA,8BAGA,eACA,GAEA,iBACA,uBACA,eACA,GACA,GArCA,YACA,OAsCA,aACA,0BACA,IAtCA,4BCDA,eACA,QACA,8BAEA,iBAEA,aACA,IACA,qDACA,UACA,CACA,IAEA,KAEA,EACA,EAEA,mBAEA,qBAtBA,YAwBA,UACA,0BACA,YACA,eAEA,oCACA,GAEA,6BACA,YACA,eACA,eAEA,uCACA,GAEA,8BACA,YACA,eAEA,uCACA,GAEA,0BACA,YAEA,mCACA,GACA,gBCpDA,aACA,uBACA,GAEA,mCACA,2EACA,oBAGA,iBACA,UAEA,cACA,SACA,yBAEA,uBACA,aAEA,8CACA,gBAEA,IAEA,oBAEA,0BACA,MACA,+BAGA,KACA,CAEA,wCACA,6BAEA,KACA,oBCtCA,aACA,QACA,UAEA,qBACA,GAEA,iCAGA,KAEA,KAJA,MAKA,mBACA,wBACA,gBAIA,sCAEA,qDACA,yBCfA,aAKA,aACA,cACA,+BAGA,uEACA,GAVA,aACA,yCACA,uDAsDA,UA5CA,UACA,IACA,YACA,OAMA,0BACA,eACA,KACA,uCAIA,gBACA,QAAiB,EAAQ,KACzB,kCAEA,qDACA,UACA,EACA,MACA,0BAIA,YACA,gEACA,MACA,CACA,GAMA,4CANkC,mBAClC,GAKE,SAEF,CACA,QACA,8BAGA,aAEA,KAEgB,EAHhB,EAGA,cAAsC,WACtC,iCAEA,IACA,WACA,YAIA,SACA,KACA,aAAkB,MAAoB,OACtC,eACA,kBAGA,IACA,CAEA,OACA,oBCzFA,CACA,4CACA,uEAEA,sDACA,iBAGA,IADA,iBCHA,aACA,qBACA,wBAEA,kDAEA,QACA,iBACA,wCACA,4BACA,YACA,EAAO,EACP,4BACA,wBACA,iBACA,GAAO,EAEP,+BAEA,oBA2DA,eACA,0BACA,EAEA,iBACA,UACA,aACA,cACA,EAEA,eACA,uBACA,WACA,OACA,kBACA,YAEA,GAEA,iBACA,uBACA,WACA,OACA,kBACA,GAIA,uBAHA,KAIA,sBACA,GAhHA,sCAEA,YAuBA,iCACA,MACA,gDACA,CACA,uDACA,IAAG,EACH,OAEA,2BACA,sBACA,IAEA,2BACA,oBACA,eACA,OAEA,6BACA,gBACA,IAEA,8BACA,oBACA,GACA,wBACA,mBAEA,SAEA,4BACA,qBACA,aAEA,qCACA,OACA,EACA,cACA,gBAEA,eAEA,yCACA,eACA,mBACA,IACA,iBACA,EACA,cACC,kBAED,mBACA,iBACA,8BACA,iBACA,gDAEA,mBC5CA,YACA,SAEA,eAEA,2HACA,kCAEA,YACA,iDACA,8BAEA,cACA,oBACA,YAAmB,WAAiB,OACpC,kBACA,IACA,SAGA,UACA,KACA,CAEA,CA6BA,iBACA,cACA,qBACA,8BACA,gBACA,2CACA,IAEA,cACA,IAEA,OACA,OACA,WACA,8BACA,eACA,2CAGA,iCACA,mCACA,kBACA,SAEA,GAAM,UACN,CAIA,OACA,eAGA,+HACA,sBACA,gBAEA,GADA,IAOA,CA6BA,cACA,aACA,eAEA,cACA,QACA,oBACA,QACA,iBAKA,aACA,sDACA,8BACA,UACA,iBACA,UACA,EACA,CAGA,oBACA,KACA,SAGA,KAGA,eACA,mCAOA,OACA,kCACA,YACA,QAEA,EAEA,OACA,GAGA,CACA,cAEA,sDACA,UACA,UACA,WACA,YACA,gBAEA,0CACA,8BACA,GAGA,6CACA,IACA,kCAIA,IACA,EAOA,CACA,YACA,QAEA,GADA,WAEA,cACG,aACH,SACA,qCACA,mBACA,oBAGA,UACA,GAKA,GAEA,0BACA,4BACA,SACA,eACA,kBACA,aAEA,GACA,CAEA,QACA,WACA,kBACA,cACA,wCACA,UACA,aAEA,cACA,4BAEA,oBACA,gBACA,QACA,2BAEA,SACA,+CACA,mBAGA,sBAEA,cAAG,KACH,oBACG,eACH,OAEA,QACA,GAEA,aACA,kBAEA,KACA,GAEA,cACA,IACA,wFACA,yCAA0D,oBAAgC,GAAE,KAC5F,GACA,eACA,EACA,GAEA,cACA,OACA,iBAMA,gCACA,iCACA,WACA,wCAIA,kBACA,eAGA,aACA,QACA,QACA,UAEA,iBACA,6BAAoC,WAAwB,MAC5D,6BAAsC,WAAsB,IAC5D,+BAAwC,kBAA4B,CACpE,wCAAiD,WAAwB,MACzE,EACA,EAGA,wBACA,sBACA,UACA,SACA,+BAAsC,OAAe,GACrD,EAIA,IACA,EAGA,CACA,iBACA,OACA,KACA,KAGA,4BACA,qBACA,GAAG,QACH,GAEA,CACA,cACA,sDACA,aACA,WACA,UACA,UAGA,QAGA,4BACA,2BAIA,YACA,sCACA,MACA,4BACA,yBAEA,GACA,CACA,OACA,MAEA,cACA,UAEA,IACA,aACA,sBAGA,sBACA,oBACA,GAEA,YACA,gBAEA,8BACA,6BACA,mCACA,SAEA,oCACA,sBAEA,GAEA,sBACA,UACA,EA/aA,YACA,sBAEA,KACA,GACA,KACA,mBAEA,iBAEA,KAAC,UAED,CAEA,CACA,GACA,MAGA,KAGA,OAGA,OAGA,KAGA,OAGA,sCACA,qBA4BA,oBAEA,UACA,YACA,YAGA,WACA,WAEA,WACA,8BACA,eACA,aACA,wBACA,wBAEA,aAAG,mBAEH,2BAGA,sBACA,EAGA,GA6CA,aACA,oBACA,UACA,iBAGA,SACA,kBAEA,iCACA,8BACA,cACA,EAEA,cACA,UAGA,UACA,IAIA,KACA,OAEA,IAJA,IAIC,GAiRD,iBACA,mBACA,sBACA,uBAEA,sBACA,OAEA,UACA,mBACA,aACA,2EAMA,mEACA,kBACA,iCAGA,iBAKA,kBACA,uBACA,sCAGA,iBAIA,yCACA,IACA,OACA,MACA,GAAK,UAEL,CACA,qBAEA,YACA,0DACA,cACA,KACA,2BACA,GAEA,wBAEA,sBAGA,IACA,wCACA,SAIA,6BACA,IACA,6BAGA,MACA,sCACA,SASA,6BACA,MACA,KAEA,IACA,iBChgBA,CAEA,+EAIA,IACA,oBACA,cACA,gBAEA,oDACA,EAKA,EACA,oBACA,OACA,KAGA,KAGA,gBAUA,GAdA,KAkBA,QACA,GAhBA,MAoBA,EAbA,SAcA,GAlBA,KAsBA,EAfA,GAgBA,GAtBA,GA0BA,GACA,GAzBA,GA6BA,IACA,iBC7DA,CAkBA,uBAUA,2BACA,UACA,aAEA,OAEA,EAEA,IAEA,kBAKA,QACA,gCAEA,EAKA,EAEA,kBAIA,QACA,kBAEA,SAGA,CAmBA,CAhFA,yBACA,oBAcA,EAkEA,0BACA,IACA,oBAGA,wBACA,SACA,yBACA,WAMA,OACA,UAGA,wBAGA,UACA,oBCzGA,CAQA,eAEA,SACA,kBACA,kBACA,oBACA,qCACA,GACA,6CAMA,CACA,YACA,MACA,eAEA,uBAAgB,iCAChB,EAOA,CAjCA,QAKA,GA6BA,YACA,6BACA,uBACA,EAMA,EACA,2BACA,cACA,eACA,mBAEA,UACA,4BAEA,GAUA,EACA,8BACA,aACA,6BACA,0CAEA,iBACA,QAEA,8BCpDA,CACA,iBACA,SACA,UACA,QACA,CASA,CACA,eACA,sCACA,GAaA,CACA,mBAKA,QAYA,WACA,OAEA,QACA,eAQA,KAAmB,IAAO,EAC1B,IACA,kBACA,QAIA,YACA,WAIA,YACA,aACA,EACA,CASA,CACA,yBACA,kBACA,oBC5GA,CAQA,aACA,OACA,QACA,4CAAsD,WAGtD,MACA,uBAEA,SADA,GAoQA,aACA,OACA,EACA,4CAAsD,WAGtD,uBACA,wBAGA,wBACA,sCACA,oCACA,mBACA,gCAIA,iBACA,iDAGA,KACA,MAIA,cAKA,0BACA,yCACA,gBACA,GACA,CAMA,iCACA,sCAEA,sBACA,sBACA,iBACA,YACA,EA6EA,YACA,oBACA,uBACA,cACA,uBACA,yBACA,eACA,IAMA,CAkZA,aACA,OACA,EACA,4CAAsD,WAGtD,uBACA,wBAEA,uBACA,iDAGA,oBACA,kBAEA,SACA,OACA,SAEA,mCACA,MAGA,oBAEA,uEACA,uBACA,qBAEA,iBACA,sBACA,uBAEA,iEAEA,EACA,iBAGA,iBACA,oBAEA,6BAEA,QACA,GA71BA,QACA,OACA,YACA,aACA,sBAaA,2BACA,wBACA,EAIA,EACA,qBA8BA,EAEA,qCACA,uDACA,eACA,aACA,6DAGA,iBACA,mBACC,IAED,oCACA,sDACA,eACA,aACA,4DAGA,iBACA,kBACC,IAED,YACA,qCACA,gBACA,SAAmB,SACnB,OAMA,EACA,YACA,yBACA,iBACA,6CAEA,oBACA,mBAEA,yBACA,oBAiBA,EACA,YACA,2BACA,YAGA,gBACA,SACA,UACA,uBACA,mBACA,aACA,sBACA,kBACA,MACA,wBAGA,2CACA,4BACA,+CACA,wBACA,qBAEA,IACA,QACA,kBACA,gCACA,+BACA,8BACA,wDAEA,MAAK,gBACL,KA7BA,KAiDA,EACA,YACA,oCACA,kBAMA,UACA,mBACA,uBACA,qCAGA,OACA,8DAEA,8BACA,QAEA,0CAEA,WAEA,0BACA,OACA,kBACA,eACA,mBACA,6BACA,2BACA,8BAEA,iBACA,mBAMA,iCACA,UACA,iCACA,0CACA,kDAGA,iCAGA,sBAMA,eACA,oBACA,qBACA,UACA,iCACA,0CACA,kDAGA,iCAGA,IAEA,OACA,IAEA,oBA+BA,EAoDA,uCACA,qBAQA,EACA,EACA,yBACA,uBAEA,2CACA,kDACA,6BACA,kEACA,YACA,qBAOA,sCACA,YACA,2BAEA,8BAAsD,SAAY,MAClE,SACA,QACA,qBACA,kCAEA,kBACA,8BACA,yBACA,gCAEA,iBACA,0BAGA,cAGA,WACA,EAEA,iCAEA,4BACA,CAIA,EACA,qBAIA,EACA,4CACA,eACA,+CACA,8BACA,2BAAK,EACL,KAKA,IAeA,YACA,0BACA,WACA,IACA,IACA,IACA,IACA,IACA,MACA,SACA,EACA,KACA,KACA,KACA,iBAEA,KACA,MACA,kBACA,IACA,MAEA,UACA,kBAEA,QACA,WACA,oBAOA,KAAyB,KAAc,mCAKvC,IAJA,sBAMA,SACA,IACA,SACS,WACT,KACA,QACA,iBACA,QACA,UACA,aAGA,OACA,8BAGA,6CACA,8BAGA,gDACA,EAGA,yBACA,QAEA,gBAEA,6BACA,SAGA,wBACA,QAEA,8BAGA,yBACA,QAEA,eAEA,2BACA,SAIA,YACA,IACA,yCAEA,GAGA,OACA,8DAEA,QACA,oDACA,CAKA,EACA,YACA,aACA,qBAMA,IACA,4BACA,kDAEA,OACA,2BACA,oDAGA,0BACA,EAKA,EACA,YACA,6BACA,WAAuB,8BAAwC,WAC/D,8BAMA,sCACA,iCAEA,wCACA,yCACA,EACA,QACA,CAGA,uBACA,QACA,CAqBA,EACA,YACA,+BACA,OACA,0BACA,mCAGA,kBACA,aACA,OACA,mBACA,gBACA,oBACA,wDAGA,+BACA,+BAEA,wCACA,2BACA,MACA,8BACA,GACA,iDAGA,6BACA,YACA,6BAEA,IACA,QACA,iCACA,yCACA,WAEA,EACA,CAEA,OACA,QACA,UACA,YACA,UAEA,KAKA,EACA,YACA,kCACA,cAGA,0DACA,6CAA+C,OAAmB,QAClE,EAMA,EACA,YACA,8BACA,UACA,qBAGA,SACA,qDAGA,sBACA,oDAGA,OACA,MACA,uDAKA,8BACA,OACA,oCACA,oDAGA,iBACA,oCACA,wDAEA,GAMA,IACA,QAGA,4BAEA,6BAoBA,EACA,YACA,gCACA,kBACA,aACA,qDAEA,uBACA,SACA,MACA,YACA,gBAGA,8BAEA,SACA,QACA,0BACA,kCAGA,kBACA,aACA,OACA,kBACA,eACA,mBACA,+CAGA,+BACA,8BAEA,mBACA,aACA,iCACA,0CACA,kDAGA,MAEA,OACA,MACA,YACA,gBAEA,OAEA,yBA8CA,EAiDA,uCACA,wBAIA,EACA,qBAIA,EACA,4CACA,eACA,QACA,QAAmB,mBAA2B,OAC9C,cAAqB,uCAA+C,OACpE,8CAGA,UACA,EAiBA,IACA,YACA,+BACA,OACA,0BACA,mCAKA,6BACA,uBACA,yCACA,oBACA,GAGA,IACA,kCACA,eACA,oBAEA,SACA,kCASA,QACA,+CACA,YACA,qDACA,gDACA,EACA,UAEA,OAhBA,QACA,UACA,YACA,UAIA,KAcA,EACA,YACA,kCACA,wCACA,mBACA,yBACA,EAMA,EACA,YACA,8BACA,WAAmB,mBAA2B,WAC9C,sBAEA,iCACA,SACA,QAEA,EACA,IACA,QAGA,4BAEA,6BAeA,EACA,YACA,gCACA,WAAmB,qBAA2B,OAC9C,wBAIA,IAGA,4FACA,QACA,OACA,QACA,sCACA,YACA,4CACA,uCACA,EAEA,UACA,EAGA,QACA,MACA,YAEA,KAMA,EACA,YACA,yBACA,MACA,4BACA,gCAAmB,mBAA2B,OAC9C,6BACA,gBACA,qBAAqB,MAA4B,WACjD,SAEA,8BACA,QACA,8DAEA,sBACA,2BAEA,gCACA,sBACA,yBAMA,SACA,QACA,kBACA,+CACA,qBACA,qDACA,gDACA,EACA,kBACA,8BACA,oBAGA,iCACA,GACA,8DAEA,EAGA,8BACA,iEACA,6BAEA,6CCpjCA,CA6BA,qBACA,MACA,iBACA,yCACA,2BACA,2BACA,yBACA,OACA,wBACA,EASA,CA7CA,YACA,uBAIA,KAGA,YAkBA,qBAoBA,EACA,uCAGA,gBAuFA,yBACA,aACO,OACP,OACA,aACA,UACA,qBACA,eACA,eACA,EACA,IACA,MACA,CACA,UA9FA,aACA,eACA,SAEA,qBACA,YACA,CAGA,QAKA,IAEA,qCACA,IAGA,eAEA,kBACA,KACA,MAES,MAIT,SACA,kBACA,gBACA,GAOA,uBANA,gBACA,OACA,oBAEA,UACA,EAMA,UACA,qBACA,KAEA,2BACA,SACA,sBACA,kCACA,qBACA,eACA,GACA,CAAK,EAEL,MACA,aAEA,OAGA,kBAIA,mCACA,0BACA,GACA,UACA,qBAEA,yBAEA,GAEA,GAEA,CAqBA,EACA,2BACA,kBACA,wBACA,UACA,EAAK,EAEL,oBACA,mBACA,sBAIA,iBACA,yFAGA,SACA,KAOA,EACA,+BACA,kBACA,sBAAiC,EAAQ,KACzC,mBAGA,kBACA,yCAGA,iBACA,yFAGA,SACA,KAQA,EACA,4BACA,6BAC6C,OAA7C,IAAsD,EACtD,oBACA,KACA,UAGA,GACA,YAAoB,aACpB,iBACA,iBACA,iBAIA,MAOA,EACA,4BACA,IACA,GACA,kBACA,cACA,KACA,OAAe,MAAW,EAC1B,yBACA,WAEA,wBACA,kBACA,CACA,OACA,KAQA,EACA,sCACA,0CACA,YACA,oBAEA,GACA,qEAGA,mCAEA,IACA,IAQA,EACA,YACA,8BACA,uCACA,CAOA,EACA,YACA,8BACA,6BAA+C,SAAS,EACxD,qBACA,wCAIA,8BACA,wBAAyC,SAAS,EAClD,kDAEA,IAKA,EACA,+BACA,OACA,+BACA,IACA,CACA,GACA,CAKA,EACA,6CACA,OACA,MACA,QACA,SAEA,WACA,GACA,OACA,OACA,OACA,OACA,mCACA,SACA,EACA,iBACA,eACA,wBACA,cACA,YACA,cACA,oBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAGA,WACA,WACA,SACA,WACA,KACK,MACL,iBACA,WACA,QACA,cAGA,YACA,KAEA,sBAA4C,SAAc,EAC1D,iBACA,KAlWA,MAmWA,gBAEA,QACA,KACA,KACS,MACT,gBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAIA,UAGA,QACA,wCACA,sBACA,EAEA,GAAU,iBACV,IAEA,+BClZA,CACA,8CACA,4CACA,2CCPA,aACA,qBACA,oCACA,4CAEA,oCACA,yBAGA,oBACA,yBAGA,IACA,oBCdA,aAKA,YACA,iBAEA,aACA,aACA,WACA,WACA,QACA,SACA,QAIA,CAEA,cAnBA,UACA,QACA,YAmBA,gBACA,MACA,6CAGA,kBAEA,UACA,mBAIA,6CAMA,EAAC,GAED,qBACA,MACA,6BAGA,iBAEA,OACA,QAGA,MAEA,6BAIA,MAAE,UACF,CAAC,eCxDD,CACA,eAAe,EAAS,MACxB,qCACA,GAeA,UAbA,aACA,UACA,IACA,uBACA,0BACA,wBACA,wBACA,wBACA,kBACA,oBACA,oBACA,uBCnBA,CAEA,wBAMA,UAJA,UACA,UACA,sBCPA,QACA,YA2BA,UAzBA,eACA,aAEA,EACA,6CACA,OAEA,QAEA,8BAGA,aACA,gBAGA,YACA,YAAoB,EAAS,KAC7B,aAIA,eACA,qBCfA,aACA,+BACA,iBAEA,SACA,EAEA,eACA,gBACA,8BACA,GAEA,iBAEA,SACA,SACA,uBACA,yCACA,gCAKA,wBACA,qBAKA,gCACA,SAEA,QACA,KACA,MACA,SAEA,GAEA,iBACA,CACA,yBACA,EAGA,gBACA,OACA,QACA,QACA,OAEA,KAAG,gBACH,QACA,kBACA,cAEA,OAGA,YACA,sBACA,iCAEA,mBACA,wBACA,oBAEA,GAAK,gBACL,uBACA,YACA,UAAsB,SAAsB,kBAC5C,SACA,QACA,aAEA,yBAEA,iBACA,EACA,EAAK,OACL,OAAG,OACH,QA5FA,YACA,OA6FA,aACA,GAEA,oBACA,OACA,QACA,QACA,OAEA,aAAqC,WAAO,MAC5C,KACA,sBACA,iCAEA,mBACA,wBACA,oBAEA,mBAAwC,SAAQ,MAChD,WACA,GACA,KACA,eAA8B,SAC9B,IACA,OACA,WAEA,cAEA,EAAO,UACP,CACA,CAEA,aACA,aAEA,WACA,IAhIA,MAEA,6BADA,EAGA,gCACA,OAA0B,IAC1B,yBCJA,aACA,OACA,oBACA,UAGA,WACA,YACA,cAEA,KACA,kDACA,QACA,EACG,WACH,2CAAyC,SAAO,EAChD,qBAIA,UACA,GAkTA,eACA,4BACA,KACA,gBAEA,QACA,SAEA,eACA,4BACA,KACA,gBAEA,QACA,SAEA,mBACA,uBACA,kBAIA,aAEA,EACA,UACA,eAEA,aAGA,KACA,UACA,eAEA,aAEA,kBAhBA,GAjWA,YAEA,SACA,WAyBA,kCACA,aACA,qBAGA,4DACA,SAEA,KACA,WAGA,GACA,WAGA,YACA,iBAEA,YACA,iBAGA,UACA,gBACA,YACA,YACA,MAEA,mCACA,aAIA,QACA,wBAGA,cACA,YACA,YACA,EACA,WAGA,aACA,OACA,iBAEA,QACA,WAEA,gCACA,aAIA,QACA,wBAGA,cACA,YACA,YACA,EACA,WAGA,aACA,OACA,iBAEA,QACA,WAEA,2BACA,yBAAuC,SAAO,EAC9C,qBAEA,gBACA,QAEA,8BACA,yBAAuC,SAAO,EAC9C,qBAEA,gBACA,QAEA,0BACA,SAIA,sBACA,iCACA,UACA,oBAEA,eAEA,UACA,SACA,IAEA,4BACA,SAIA,sBACA,iCACA,UACA,oBAEA,eAEA,UACA,SACA,IAEA,iCACA,MACA,2BAAqC,EAAiB,SACtD,uBACA,UAEA,MAEA,wCACA,MACA,uCAAmD,EAAiB,SACpE,uBACA,UAEA,MAEA,2BACA,oBAAqC,iBAA0B,EAE/D,QAEA,eACA,kBAEA,OAEA,kCACA,oBAAqC,iBAA0B,EAE/D,QAEA,eACA,kBAEA,OAEA,6BACA,MACA,kBACA,UAA8B,KAC9B,kCACA,WAEA,WACA,IAEA,oCACA,MACA,kBACA,UAA8B,KAC9B,kCACA,WAEA,WACA,IAEA,gCACA,IACA,UACA,QACA,qBACG,eACH,iBACA,iBAEA,+BAGA,wDAAiB,EAAiB,SAClC,kBACA,OAGA,WACA,IAEA,uCACA,IACA,UACA,QACA,qBACG,eACH,iBACA,iBAEA,+BAGA,oEAA+B,EAAiB,SAChD,kBACA,OAGA,WACA,IAEA,8BACA,sBACA,mBAAqC,KAAiB,SACtD,WACA,UAEA,WACA,IAEA,qCACA,sBACA,mBAAqC,KAAiB,SACtD,WACA,UAEA,WACA,IAEA,+BACA,WACA,OACA,cAEA,aACA,EACA,cAEA,iBACA,WACA,UAEA,GACA,QAEA,UACA,gBAEA,2BAAqC,iBAA6B,EAClE,QAEA,KAAQ,iBAA2B,UACnC,cAEA,aACA,IAEA,sCACA,WACA,OACA,cAEA,aACA,EACA,cAEA,iBACA,WACA,UAEA,GACA,QAEA,UACA,gBAEA,qCAA+C,iBAA2B,EAC1E,QAEA,KAAQ,iBAA6B,UACrC,cAEA,aACA,IAEA,8BACA,gBACA,YACA,OAAyB,IAAiB,aAC1C,SACA,cACA,YAEA,mBACA,YACA,EACA,wEC1UiC,WAQjC,GASC,GATD,CAA8B,WAI5B,YAIA,iBACD,QAT6B,EAAlB,EAAkB,qBAAlB,EASX,wBAED,EAIC,kBAJyD,WAClD,OAAK,KAAuB,EAGnC,IAhBE,8HANwB,gJCOuB,aAChD,MACwB,GAGjB,kBAAU,OACnB,CAAC,yCAZoC,WACrC,EAIyC,iBAJQ,WACzC,OAAkB,GAAQ,EACjC,WAGD,oBAMC,iFCdD,KAAgB,GAAqF,EAAc,IAEnH,EAcG,iBAdsE,aACjE,OAAW,GAAO,EAAU,EAAE,CACrC,aAaD,EAyBC,cAzB2C,aACvC,IAAO,OAAG,GAAE,EACP,GAIL,YAAW,IAAT,MAAuB,IAAT,MAAkC,QAArB,QAAQ,IAChC,QADiD,QAAQ,GAIjE,cAAW,GAAS,OAAK,KACzB,GAAW,EAAS,OAAK,KAEtB,MAAM,EAAO,SAAU,EAClB,OAGJ,aAAC,GAAK,GAAI,EAAG,EAAQ,EAAO,OAAK,IACnC,MAAS,GAAQ,EACd,MAAC,CAAO,OAAU,UAAe,eAAK,KAAE,EAAM,IAAI,CAAO,OAAG,GAAE,EAAK,GAAG,EACjE,IAET,QAEK,CACP,4EC1CqB,WACtB,EAgBG,WAhBmC,WACpC,MAAM,IAAS,OAChB,IAeD,EAEC,YAFoD,aACnD,MAAM,IAAS,OAChB,kCCqC+C,qDAC9C,IACE,MAAU,GAAG,KAAc,GACrB,aACP,GAAU,QACN,WAAM,oDAAyD,IAClE,GAEJ,CAAC,GAWE,CA8BH,YACE,MAA2B,GACpB,mCAAyB,EAAa,iBAC/C,CAAC,GAKE,oVAlHH,UA0BmE,IAC7C,eAAa,MAIjC,CAAiE,gBAC/D,IACG,MAAS,GAAY,EAAS,QACxB,GAAW,EAElB,aAAY,GAAW,EACvB,OAAwB,EAAS,GAAU,EAAI,IAAE,KAAK,EAAS,SAAK,KACjE,MACS,SAAU,MACtB,CACI,IACM,qBAAqB,EAAI,QAAa,EAAW,eAAa,EAC1E,MAEK,UAED,QAAS,SAEhB,GAtBD,WA6BG,EAqBH,EA4BkD,QA5ByF,qBACzI,MAAkB,GAAkB,GAAX,KAAG,GAAe,EAAO,OAAG,GACrD,EAAS,EAAa,aAAW,KAAmB,CAEpD,OAAW,GACD,QACM,kEACF,gCAGX,KACM,IAAoB,yBAC7B,CAEO,uBACK,EAIZ,QAAa,GACJ,CACD,UACF,cAAM,KAAU,UAGhB,UAAM,OAAI,EACjB,IAYD,EAqBG,eArBuD,mDACrD,IAAS,EACJ,SAAY,GAElB,MAGA,MACU,GAAG,KAAiB,GAC7B,GAAU,QACT,MAAM,IAAY,GAAS,EAC5B,KAED,MAEH,MAOD,EAcC,mBAdgF,aAC/E,MAAQ,GAAS,OAAK,KAAQ,GACxB,IAAQ,QAAM,KAAsB,mBAAO,EAAS,OACnD,KAEH,WAAG,GACC,OAGiB,CAChB,CADF,KAAQ,QAAK,QACL,KACf,CACS,MAAM,KACf,CACD,GALI,kFClJL,UAKG,GACH,EAYC,YAZuD,aACjD,UAAG,EAAqB,sBAE1B,GAAM,EACD,MACF,KAAQ,MAAU,EAAQ,QACrB,EAAM,MAET,OACF,KAAQ,MAAU,EAAK,SAAU,EACjC,aAAQ,EAAK,SAAU,EAC7B,OACD,mFClBD,UAA4C,IAE5C,EAIC,iBAJ8D,aACvD,OAAM,GACR,EAAW,YAAM,EAAU,GAEhC,iCCgBoC,aAChC,IAAO,OAAQ,OAChB,MAAY,GAAG,GAAc,YACvB,iBAAgB,gBAEhB,GAAO,OAAK,KAAO,EAC1B,OAEK,OAAC,GAAwB,YAChC,EAME,kDArCH,UASA,IAAU,EAAU,EAYjB,IAiBH,EAEC,KAFD,UACQ,OAAK,GAAC,CAAQ,OAAgB,EACrC,qCCCD,oDACE,SAAuB,IAAwB,qCAC7C,MAAS,GAAG,EAAG,IAAY,YAC3B,GAAgB,EAAG,KAAS,GAC5B,eAAY,EAAG,KAAS,GAClB,oBAAC,IAAI,GAAO,QAAQ,EAAM,MAAS,EAAS,SAAS,EAAM,MAAQ,EAAY,EAAW,WAAY,EAAG,GAAY,EAC3H,KAEJ,IAAC,oXAjDD,EAAwC,IAExC,UACA,QACA,QACA,OACA,QACA,QACA,OAUA,QACA,OACA,QAAmF,GAEnF,EAAkB,mBAEX,QAAG,GAAoB,oBAAe,KACtC,GAAG,EAAqB,sBAEtB,WAAM,MAAqB,qBAElC,KAAe,gBACf,KAAuB,wBACvB,KAEF,KAAmB,GAAG,GAAI,GAAa,cAAa,aACpD,GAAc,EAAG,GAAI,GAAQ,SAC7B,YAAuB,EAAG,GAAI,GAAiB,kBAE/C,GAAqB,EAAG,IAAM,EAAgB,gBAAc,EAAoB,GAEhE,IAYhB,EAAQ,SAAO,OAAE,IACT,OAAQ,SAAQ,QACtB,UAEF,EAAQ,SAAe,eAAE,IAAmB,EAAU,UAEtD,EAAQ,SAAc,cAAE,CAAO,CAA8B,0CAC3D,MAAmB,GAAW,WAAC,EAAO,QAAS,SAC/C,SACA,QAEF,EAAQ,SAAiB,iBAAE,CAAO,CAAiC,0CACjE,MAAmB,GAAc,cAAC,EAAO,QAAS,SAEpD,IAAE,OAEF,EAAQ,SAAmB,mBAAE,CAAO,CAAiC,wCACnE,MACI,UAAC,KAAU,KAAU,GACvB,MAAe,GAAG,KAAuB,GAAc,cAC7C,KAAK,KAChB,EAEgB,OACX,KACN,KAEF,EAAQ,SAAsB,sBAAE,CAAO,CAA4C,gDACjF,MACI,UAAC,KAAY,KACf,QAAuB,GAAiB,iBAC1B,KAAK,KAGJ,SACX,KACN,KAEF,EAAQ,SAAmB,mBAAE,IACrB,OAAkB,GACxB,oBAEF,EAAQ,SAA2B,2BAAE,CAAO,CAA6C,6CACvF,MAAwB,GAAG,EAAU,WAAS,SAC9C,GAAuB,EAAG,KAAuB,GAAuB,uBAEvD,SAEX,KACN,KAEF,EAAQ,SAA4B,4BAAE,CAAO,CAAY,aAA2C,0CAClG,MAAwB,GAAG,EAAU,WAAS,SAC9C,GAAuB,EAAG,KAAuB,GAAwB,wBAAmB,EAE3E,SAEX,KACN,KAEF,EAAQ,SAAyB,yBAAE,CAAO,CAAY,aAAqC,uCACzF,MAAwB,GAAG,EAAU,WAAS,SAC9C,GAAuB,EAAG,KAAuB,GAAqB,qBAAmB,EACzF,GAA0B,EAAG,KAAuB,GAAwB,wBAE3D,YAEX,KACN,C,kCC9GF,YACM,OACC,OAAG,EAAM,OAGR,KACP,CAME,kDArBH,UAAiC,GAEjC,GAAO,GACP,KAAW,EACX,KAAQ,EACR,KAAQ,EACR,KAAgB,EAChB,KAAiB,EAAsB,KAevC,EAYG,WAZH,UACM,OACK,OAAW,IAGd,cACP,GAOD,EAYG,QAZH,UACM,OACE,OAAW,IAGX,WACP,GAOD,EAYG,WAZH,UACM,OACE,OAAW,IAGX,cACP,GAOD,EAYG,gBAZH,UACM,OACU,OAAW,IAAQ,QAG3B,aACP,GAOD,EAYC,iBAZD,UACK,IAAC,CAAe,EACjB,MAAS,GACT,OACe,GAAM,EAAQ,QAC5B,aAAW,QAEG,GAAM,EAAQ,QAE/B,OAAC,CAEK,OACP,iBCtFD,kB,8BCAA,kB,uBCAA,kB,oBCAA,kB","file":"shared.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 68);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3f3fbf7e8527f5c69fa7","module.exports = require(\"path\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"path\"\n// module id = 0\n// module chunks = 0","module.exports = require(\"fs\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 1\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/util.js\n// module id = 2\n// module chunks = 0","module.exports = require(\"electron\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"electron\"\n// module id = 3\n// module chunks = 0","import { IEmail } from './email'\nimport { getDotComAPIEndpoint } from '../lib/api'\n\n/** The data-only interface for Account for transport across IPC. */\nexport interface IAccount {\n  readonly token: string\n  readonly login: string\n  readonly endpoint: string\n  readonly emails: ReadonlyArray<IEmail>\n  readonly avatarURL: string\n  readonly id: number\n  readonly name: string\n}\n\n/**\n * A GitHub account, representing the user found on GitHub The Website or GitHub Enterprise.\n *\n * This contains a token that will be used for operations that require authentication.\n */\nexport class Account implements IAccount {\n  /** The access token used to perform operations on behalf of this account */\n  public readonly token: string\n  /** The login name for this account  */\n  public readonly login: string\n  /** The server for this account - GitHub or a GitHub Enterprise instance */\n  public readonly endpoint: string\n  /** The current list of email addresses associated with the account */\n  public readonly emails: ReadonlyArray<IEmail>\n  /** The profile URL to render for this account */\n  public readonly avatarURL: string\n  /** The database id for this account */\n  public readonly id: number\n  /** The friendly name associated with this account */\n  public readonly name: string\n\n  /** Create a new Account from some JSON. */\n  public static fromJSON(obj: IAccount): Account {\n    return new Account(obj.login, obj.endpoint, obj.token, obj.emails, obj.avatarURL, obj.id, obj.name)\n  }\n\n  /** Create an account which can be used to perform unauthenticated API actions */\n  public static anonymous(): Account {\n    return new Account('', getDotComAPIEndpoint(), '', [ ], '', -1, '')\n  }\n\n  public constructor(login: string, endpoint: string, token: string, emails: ReadonlyArray<IEmail>, avatarURL: string, id: number, name: string) {\n    this.login = login\n    this.endpoint = endpoint\n    this.token = token\n    this.emails = emails\n    this.avatarURL = avatarURL\n    this.id = id\n    this.name = name\n  }\n\n  public withToken(token: string): Account {\n    return new Account(this.login, this.endpoint, token, this.emails, this.avatarURL, this.id, this.name)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/models/account.ts","import * as OS from 'os'\nimport * as URL from 'url'\nimport { Account } from '../models/account'\nimport { IEmail } from '../models/email'\n\nimport { request, parsedResponse, HTTPMethod, APIError, urlWithQueryString } from './http'\nimport { AuthenticationMode } from './2fa'\nimport { uuid } from './uuid'\n\nconst username: () => Promise<string> = require('username')\n\nconst ClientID = process.env.TEST_ENV ? '' : __OAUTH_CLIENT_ID__\nconst ClientSecret = process.env.TEST_ENV ? '' : __OAUTH_SECRET__\n\nif (!ClientID || !ClientID.length || !ClientSecret || !ClientSecret.length) {\n  log.warn(`DESKTOP_OAUTH_CLIENT_ID and/or DESKTOP_OAUTH_CLIENT_SECRET is undefined. You won't be able to authenticate new users.`)\n}\n\n/** The OAuth scopes we need. */\nconst Scopes = [\n  'repo',\n  'user',\n]\n\n/** The note URL used for authorizations the app creates. */\nconst NoteURL = 'https://desktop.github.com/'\n\n/**\n * Information about a repository as returned by the GitHub API.\n */\nexport interface IAPIRepository {\n  readonly clone_url: string\n  readonly html_url: string\n  readonly name: string\n  readonly owner: IAPIUser\n  readonly private: boolean\n  readonly fork: boolean\n  readonly default_branch: string\n}\n\n/**\n * Information about a commit as returned by the GitHub API.\n */\nexport interface IAPICommit {\n  readonly sha: string\n  readonly author: IAPIUser | null\n}\n\n/**\n * Information about a user as returned by the GitHub API.\n */\nexport interface IAPIUser {\n  readonly id: number\n  readonly url: string\n  readonly login: string\n  readonly avatar_url: string\n  readonly name: string\n}\n\n/** The users we get from the mentionables endpoint. */\nexport interface IAPIMentionableUser {\n  readonly avatar_url: string\n\n  /**\n   * Note that this may be an empty string *or* null in the case where the user\n   * has no public email address.\n   */\n  readonly email: string | null\n\n  readonly login: string\n\n  readonly name: string\n}\n\n/**\n * Information about a user's email as returned by the GitHub API.\n */\nexport interface IAPIEmail {\n  readonly email: string\n  readonly verified: boolean\n  readonly primary: boolean\n  /**\n   * `null` can be returned by the API for legacy reasons. A non-null value is\n   * set for the primary email address currently, but in the future visibility\n   * may be defined for each email address.\n   */\n  readonly visibility: 'public' | 'private' | null\n}\n\n/** Information about an issue as returned by the GitHub API. */\nexport interface IAPIIssue {\n  readonly number: number\n  readonly title: string\n  readonly state: 'open' | 'closed'\n  readonly updated_at: string\n}\n\n/** The metadata about a GitHub server. */\nexport interface IServerMetadata {\n  /**\n   * Does the server support password-based authentication? If not, the user\n   * must go through the OAuth flow to authenticate.\n   */\n  readonly verifiable_password_authentication: boolean\n}\n\n/** The server response when handling the OAuth callback (with code) to obtain an access token */\ninterface IAPIAccessToken {\n  readonly access_token: string\n  readonly scope: string\n  readonly token_type: string\n}\n\n/** The partial server response when creating a new authorization on behalf of a user */\ninterface IAPIAuthorization {\n  readonly token: string\n}\n\n/** The response we receive from fetching mentionables. */\ninterface IAPIMentionablesResponse {\n  readonly etag: string\n  readonly users: ReadonlyArray<IAPIMentionableUser>\n}\n\n/** The response for search results. */\ninterface ISearchResults<T> {\n  readonly items: ReadonlyArray<T>\n}\n\n/**\n * Parses the Link header from GitHub and returns the 'next' path\n * if one is present.\n *\n * If no link rel next header is found this method returns null.\n */\nfunction getNextPagePath(response: Response): string | null {\n  const linkHeader = response.headers.get('Link')\n\n  if (!linkHeader) {\n    return null\n  }\n\n  for (const part of linkHeader.split(',')) {\n    // https://github.com/philschatz/octokat.js/blob/5658abe442e8bf405cfda1c72629526a37554613/src/plugins/pagination.js#L17\n    const match = part.match(/<([^>]+)>; rel=\"([^\"]+)\"/)\n\n    if (match && match[2] === 'next') {\n      const nextURL = URL.parse(match[1])\n      return nextURL.path || null\n    }\n  }\n\n  return null\n}\n\n/**\n * Returns an ISO 8601 time string with second resolution instead of\n * the standard javascript toISOString which returns millisecond\n * resolution. The GitHub API doesn't return dates with milliseconds\n * so we won't send any back either.\n */\nfunction toGitHubIsoDateString(date: Date) {\n  return date.toISOString().replace(/\\.\\d{3}Z$/, 'Z')\n}\n\n/**\n * An object for making authenticated requests to the GitHub API\n */\nexport class API {\n  private endpoint: string\n  private token: string\n\n  /** Create a new API client from the given account. */\n  public static fromAccount(account: Account): API {\n    return new API(account.endpoint, account.token)\n  }\n\n  /** Create a new API client for the endpoint, authenticated with the token. */\n  public constructor(endpoint: string, token: string) {\n    this.endpoint = endpoint\n    this.token = token\n  }\n\n  /** Fetch a repo by its owner and name. */\n  public async fetchRepository(owner: string, name: string): Promise<IAPIRepository | null> {\n    try {\n      const response = await this.request('GET', `repos/${owner}/${name}`)\n      return parsedResponse<IAPIRepository>(response)\n    } catch (e) {\n      log.warn(`fetchRepository: not found '${owner}/${name}'`, e)\n      return null\n    }\n  }\n\n  /** Fetch the logged in account. */\n  public async fetchAccount(): Promise<IAPIUser> {\n    try {\n      const response = await this.request('GET', 'user')\n      const result = await parsedResponse<IAPIUser>(response)\n      return result\n    } catch (e) {\n      log.warn(`fetchAccount: failed with endpoint ${this.endpoint}`, e)\n      throw e\n    }\n  }\n\n  /** Fetch the current user's emails. */\n  public async fetchEmails(): Promise<ReadonlyArray<IEmail>> {\n    const isDotCom = this.endpoint === getDotComAPIEndpoint()\n\n    // workaround for /user/public_emails throwing a 500\n    // while we investigate the API issue\n    // see https://github.com/desktop/desktop/issues/1508 for context\n    try {\n      // GitHub Enterprise does not have the concept of private emails\n      const apiPath = isDotCom ? 'user/public_emails' : 'user/emails'\n      const response = await this.request('GET', apiPath)\n      const result = await parsedResponse<ReadonlyArray<IAPIEmail>>(response)\n\n      return Array.isArray(result)\n        ? result\n        : []\n    } catch (e) {\n      log.warn(`fetchEmails: failed with endpoint ${this.endpoint}`, e)\n      return []\n    }\n  }\n\n  /** Fetch a commit from the repository. */\n  public async fetchCommit(owner: string, name: string, sha: string): Promise<IAPICommit | null> {\n    try {\n      const response = await this.request('GET', `repos/${owner}/${name}/commits/${sha}`)\n      return parsedResponse<IAPICommit>(response)\n    } catch (e) {\n      log.warn(`fetchCommit: not found '${owner}/${name}@${sha}'`, e)\n      return null\n    }\n  }\n\n  /** Search for a user with the given public email. */\n  public async searchForUserWithEmail(email: string): Promise<IAPIUser | null> {\n    try {\n      const params = { q: `${email} in:email type:user` }\n      const url = urlWithQueryString('search/users', params)\n      const response = await this.request('GET', url)\n      const result = await parsedResponse<ISearchResults<IAPIUser>>(response)\n      const items = result.items\n      if (items.length) {\n        // The results are sorted by score, best to worst. So the first result\n        // is our best match.\n        return items[0]\n      } else {\n        return null\n      }\n    } catch (e) {\n      log.warn(`searchForUserWithEmail: not found '${email}'`, e)\n      return null\n    }\n  }\n\n  /** Fetch all the orgs to which the user belongs. */\n  public async fetchOrgs(): Promise<ReadonlyArray<IAPIUser>> {\n    try {\n      return this.fetchAll<IAPIUser>('user/orgs')\n    } catch (e) {\n      log.warn(`fetchOrgs: failed with endpoint ${this.endpoint}`, e)\n      return []\n    }\n  }\n\n  /** Create a new GitHub repository with the given properties. */\n  public async createRepository(org: IAPIUser | null, name: string, description: string, private_: boolean): Promise<IAPIRepository> {\n    try {\n      const apiPath = org ? `orgs/${org.login}/repos` : 'user/repos'\n      const response = await this.request('POST', apiPath, {\n        name,\n        description,\n        private: private_,\n      })\n\n      return parsedResponse<IAPIRepository>(response)\n    } catch (e) {\n      log.warn(`createRepository: failed with endpoint ${this.endpoint}`, e)\n      throw e\n    }\n  }\n\n  /**\n   * Fetch the issues with the given state that have been created or updated\n   * since the given date.\n   */\n  public async fetchIssues(owner: string, name: string, state: 'open' | 'closed' | 'all', since: Date | null): Promise<ReadonlyArray<IAPIIssue>> {\n\n    const params = since && !isNaN(since.getTime())\n      ? { since: toGitHubIsoDateString(since) }\n      : { }\n\n    const url = urlWithQueryString(`repos/${owner}/${name}/issues`, params)\n    try {\n      const issues = await this.fetchAll<IAPIIssue>(url)\n\n      // PRs are issues! But we only want Really Seriously Issues.\n      return issues.filter((i: any) => !i.pullRequest)\n    } catch (e) {\n      log.warn(`fetchIssues: failed for repository ${owner}/${name}`, e)\n      throw e\n    }\n  }\n\n  /**\n   * Authenticated requests to a paginating resource such as issues.\n   *\n   * Follows the GitHub API hypermedia links to get the subsequent\n   * pages when available, buffers all items and returns them in\n   * one array when done.\n   */\n  private async fetchAll<T>(path: string): Promise<ReadonlyArray<T>> {\n    const buf = new Array<T>()\n    let nextPath: string | null = path\n\n    do {\n      const response = await this.request('GET', nextPath)\n      const items = await parsedResponse<ReadonlyArray<T>>(response)\n      if (items) {\n        buf.push(...items)\n      }\n      nextPath = getNextPagePath(response)\n    } while (nextPath)\n\n    return buf\n  }\n\n  /** Make an authenticated request to the client's endpoint with its token. */\n  private request(method: HTTPMethod, path: string, body?: Object, customHeaders?: Object): Promise<Response> {\n    return request(this.endpoint, this.token, method, path, body, customHeaders)\n  }\n\n  /**\n   * Get the allowed poll interval for fetching. If an error occurs it will\n   * return null.\n   */\n  public async getFetchPollInterval(owner: string, name: string): Promise<number | null> {\n    const path = `repos/${owner}/${name}/git`\n    try {\n      const response = await this.request('HEAD', path)\n      const interval = response.headers.get('x-poll-interval')\n      if (interval) {\n        const parsed = parseInt(interval, 10)\n        return isNaN(parsed) ? null : parsed\n      }\n      return null\n    } catch (e) {\n      log.warn(`getFetchPollInterval: failed for ${owner}/${name}`, e)\n      return null\n    }\n  }\n\n  /** Fetch the mentionable users for the repository. */\n  public async fetchMentionables(owner: string, name: string, etag: string | null): Promise<IAPIMentionablesResponse | null> {\n    // NB: this custom `Accept` is required for the `mentionables` endpoint.\n    const headers: any = {\n      'Accept': 'application/vnd.github.jerry-maguire-preview',\n    }\n\n    if (etag) {\n      headers['If-None-Match'] = etag\n    }\n\n    try {\n      const response = await this.request('GET', `repos/${owner}/${name}/mentionables/users`, undefined, headers)\n      const users = await parsedResponse<ReadonlyArray<IAPIMentionableUser>>(response)\n      const responseEtag = response.headers.get('etag')\n      return { users, etag: responseEtag || '' }\n    } catch (e) {\n      log.warn(`fetchMentionables: failed for ${owner}/${name}`, e)\n      return null\n    }\n  }\n}\n\nexport enum AuthorizationResponseKind {\n  Authorized,\n  Failed,\n  TwoFactorAuthenticationRequired,\n  UserRequiresVerification,\n  PersonalAccessTokenBlocked,\n  Error,\n  EnterpriseTooOld,\n}\n\nexport type AuthorizationResponse = { kind: AuthorizationResponseKind.Authorized, token: string } |\n                                    { kind: AuthorizationResponseKind.Failed, response: Response } |\n                                    { kind: AuthorizationResponseKind.TwoFactorAuthenticationRequired, type: AuthenticationMode } |\n                                    { kind: AuthorizationResponseKind.Error, response: Response } |\n                                    { kind: AuthorizationResponseKind.UserRequiresVerification } |\n                                    { kind: AuthorizationResponseKind.PersonalAccessTokenBlocked } |\n                                    { kind: AuthorizationResponseKind.EnterpriseTooOld }\n\n/**\n * Create an authorization with the given login, password, and one-time\n * password.\n */\nexport async function createAuthorization(endpoint: string, login: string, password: string, oneTimePassword: string | null): Promise<AuthorizationResponse> {\n  const creds = Buffer.from(`${login}:${password}`, 'utf8').toString('base64')\n  const authorization = `Basic ${creds}`\n  const optHeader = oneTimePassword ? { 'X-GitHub-OTP': oneTimePassword } : {}\n\n  const note = await getNote()\n\n  const response = await request(endpoint, null, 'POST', 'authorizations', {\n    'scopes': Scopes,\n    'client_id': ClientID,\n    'client_secret': ClientSecret,\n    'note': note,\n    'note_url': NoteURL,\n    'fingerprint': uuid(),\n  }, {\n    'Authorization': authorization,\n    ...optHeader,\n  })\n\n  try {\n    const result = await parsedResponse<IAPIAuthorization>(response)\n    if (result) {\n      const token = result.token\n      if (token && typeof token === 'string' && token.length) {\n        return { kind: AuthorizationResponseKind.Authorized, token }\n      }\n    }\n  } catch (e) {\n    if (response.status === 401) {\n      const otpResponse = response.headers.get('x-github-otp')\n      if (otpResponse) {\n        const pieces = otpResponse.split(';')\n        if (pieces.length === 2) {\n          const type = pieces[1].trim()\n          switch (type) {\n            case 'app':\n              return { kind: AuthorizationResponseKind.TwoFactorAuthenticationRequired, type: AuthenticationMode.App }\n            case 'sms':\n              return { kind: AuthorizationResponseKind.TwoFactorAuthenticationRequired, type: AuthenticationMode.Sms }\n            default:\n              return { kind: AuthorizationResponseKind.Failed, response }\n          }\n        }\n      }\n\n      return { kind: AuthorizationResponseKind.Failed, response }\n    }\n\n    const apiError = e instanceof APIError && e.apiError\n    if (apiError) {\n      if (response.status === 403 && apiError.message === 'This API can only be accessed with username and password Basic Auth') {\n        // Authorization API does not support providing personal access tokens\n        return { kind: AuthorizationResponseKind.PersonalAccessTokenBlocked }\n      } else if (response.status === 422) {\n        if (apiError.errors) {\n          for (const error of apiError.errors) {\n            const isExpectedResource = error.resource.toLowerCase() === 'oauthaccess'\n            const isExpectedField = error.field.toLowerCase() === 'user'\n            if (isExpectedField && isExpectedResource) {\n              return { kind: AuthorizationResponseKind.UserRequiresVerification }\n            }\n          }\n        } else if (apiError.message === 'Invalid OAuth application client_id or secret.') {\n          return { kind: AuthorizationResponseKind.EnterpriseTooOld }\n        }\n      }\n    }\n  }\n\n  return { kind: AuthorizationResponseKind.Error, response }\n}\n\n/** Fetch the user authenticated by the token. */\nexport async function fetchUser(endpoint: string, token: string): Promise<Account> {\n  const api = new API(endpoint, token)\n  try {\n    const user = await api.fetchAccount()\n    const emails = await api.fetchEmails()\n    return new Account(user.login, endpoint, token, emails, user.avatar_url, user.id, user.name)\n  } catch (e) {\n    log.warn(`fetchUser: failed with endpoint ${endpoint}`, e)\n    throw e\n  }\n}\n\n/** Get metadata from the server. */\nexport async function fetchMetadata(endpoint: string): Promise<IServerMetadata | null> {\n  const url = `${endpoint}/meta`\n\n  try {\n    const response = await request(endpoint, null, 'GET', 'meta', undefined, {\n      'Content-Type': 'application/json',\n    })\n\n    const result = await parsedResponse<IServerMetadata>(response)\n    if (!result || result.verifiable_password_authentication === undefined) {\n      return null\n    }\n\n    return result\n  } catch (e) {\n    log.error(`fetchMetadata: unable to load metadata from '${url}' as a fallback`, e)\n    return null\n  }\n}\n\n/** The note used for created authorizations. */\nasync function getNote(): Promise<string> {\n  let localUsername = 'unknown'\n  try {\n    localUsername = await username()\n  } catch (e) {\n    log.error(`getNote: unable to resolve machine username, using '${localUsername}' as a fallback`, e)\n  }\n\n  return `GitHub Desktop on ${localUsername}@${OS.hostname()}`\n}\n\n/**\n * Map a repository's URL to the endpoint associated with it. For example:\n *\n * https://github.com/desktop/desktop -> https://api.github.com\n * http://github.mycompany.com/my-team/my-project -> http://github.mycompany.com/api\n */\nexport function getEndpointForRepository(url: string): string {\n  const parsed = URL.parse(url)\n  if (parsed.hostname === 'github.com') {\n    return getDotComAPIEndpoint()\n  } else {\n    return `${parsed.protocol}//${parsed.hostname}/api`\n  }\n}\n\n/**\n * Get the URL for the HTML site. For example:\n *\n * https://api.github.com -> https://github.com\n * http://github.mycompany.com/api -> http://github.mycompany.com/\n */\nexport function getHTMLURL(endpoint: string): string {\n  // In the case of GitHub.com, the HTML site lives on the parent domain.\n  //  E.g., https://api.github.com -> https://github.com\n  //\n  // Whereas with Enterprise, it lives on the same domain but without the\n  // API path:\n  //  E.g., https://github.mycompany.com/api/v3 -> https://github.mycompany.com\n  //\n  // We need to normalize them.\n  if (endpoint === getDotComAPIEndpoint()) {\n    return 'https://github.com'\n  } else {\n    const parsed = URL.parse(endpoint)\n    return `${parsed.protocol}//${parsed.hostname}`\n  }\n}\n\n/**\n * Get the API URL for an HTML URL. For example:\n *\n * http://github.mycompany.com -> http://github.mycompany.com/api/v3\n */\nexport function getEnterpriseAPIURL(endpoint: string): string {\n  const parsed = URL.parse(endpoint)\n  return `${parsed.protocol}//${parsed.hostname}/api/v3`\n}\n\n/** Get github.com's API endpoint. */\nexport function getDotComAPIEndpoint(): string {\n  const envEndpoint = process.env['API_ENDPOINT']\n  if (envEndpoint && envEndpoint.length > 0) {\n    return envEndpoint\n  }\n\n  return 'https://api.github.com'\n}\n\n/** Get the account for the endpoint. */\nexport function getAccountForEndpoint(accounts: ReadonlyArray<Account>, endpoint: string): Account | null {\n  return accounts.find(a => a.endpoint === endpoint) || null\n}\n\nexport function getOAuthAuthorizationURL(endpoint: string, state: string): string {\n  const urlBase = getHTMLURL(endpoint)\n  const scope = encodeURIComponent(Scopes.join(' '))\n  return `${urlBase}/login/oauth/authorize?client_id=${ClientID}&scope=${scope}&state=${state}`\n}\n\nexport async function requestOAuthToken(endpoint: string, state: string, code: string): Promise<string | null> {\n  try {\n    const urlBase = getHTMLURL(endpoint)\n    const response = await request(urlBase, null, 'POST', 'login/oauth/access_token', {\n      'client_id': ClientID,\n      'client_secret': ClientSecret,\n      'code': code,\n      'state': state,\n    })\n    const result = await parsedResponse<IAPIAccessToken>(response)\n    return result.access_token\n  } catch (e) {\n    log.warn(`requestOAuthToken: failed with endpoint ${endpoint}`, e)\n    return null\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/api.ts","import * as Path from 'path'\nimport * as Fs from 'fs'\n\nconst fileUriToPath: (uri: string) => string = require('file-uri-to-path')\nconst sourceMapSupport = require('source-map-support')\n\n/**\n * This array tells the source map logic which files that we can expect to\n * be able to resolve a source map for and they should reflect the chunks\n * entry names from our webpack config.\n *\n * Note that we explicitly don't enable source maps for the crash process\n * since it's possible that the error which caused us to spawn the crash\n * process was related to source maps.\n */\nconst knownFilesWithSourceMap = [ 'renderer.js', 'main.js', 'shared.js' ]\n\nfunction retrieveSourceMap(source: string) {\n  // This is a happy path in case we know for certain that we won't be\n  // able to resolve a source map for the given location.\n  if (!knownFilesWithSourceMap.some(file => source.endsWith(file))) {\n    return null\n  }\n\n  // We get a file uri when we're inside a renderer, convert to a path\n  if (source.startsWith('file://')) {\n    source = fileUriToPath(source)\n  }\n\n  // We store our source maps right next to the bundle\n  const path = `${source}.map`\n\n  if (__DEV__ && path.startsWith('http://')) {\n    try {\n      const xhr = new XMLHttpRequest()\n      xhr.open('GET', path, false)\n      xhr.send(null)\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        return { url: Path.basename(path), map: xhr.responseText }\n      }\n    } catch (error) {\n      return\n    }\n    return\n  }\n\n  // We don't have an option here, see\n  //  https://github.com/v8/v8/wiki/Stack-Trace-API#customizing-stack-traces\n  // This happens on-demand when someone accesses the stack\n  // property on an error object and has to be synchronous :/\n  // tslint:disable-next-line:no-sync-functions\n  if (!Fs.existsSync(path)) {\n    return\n  }\n\n  try {\n    // tslint:disable-next-line:no-sync-functions\n    const map = Fs.readFileSync(path, 'utf8')\n    return { url: Path.basename(path), map }\n  } catch (error) {\n    return\n  }\n}\n\n/** A map from errors to their stack frames. */\nconst stackFrameMap = new WeakMap<Error, ReadonlyArray<any>>()\n\n/**\n * The `prepareStackTrace` that comes from the `source-map-support` module.\n * We'll use this when the user explicitly wants the stack source mapped.\n */\nlet prepareStackTraceWithSourceMap: (error: Error, frames: ReadonlyArray<any>) => string\n\n/**\n * Capture the error's stack frames and return a standard, un-source mapped\n * stack trace.\n */\nfunction prepareStackTrace(error: Error, frames: ReadonlyArray<any>) {\n  stackFrameMap.set(error, frames)\n\n  // Ideally we'd use the default `Error.prepareStackTrace` here but it's\n  // undefined so V8 must doing something fancy. Instead we'll do a decent\n  // impression.\n  return error + frames\n    .map(frame => `\\n    at ${frame}`)\n    .join('')\n}\n\n/** Enable source map support in the current process. */\nexport function enableSourceMaps() {\n  sourceMapSupport.install({\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap,\n  })\n\n  const AnyError = Error as any\n  // We want to keep `source-map-support`s `prepareStackTrace` around to use\n  // later, but our cheaper `prepareStackTrace` should be the default.\n  prepareStackTraceWithSourceMap = AnyError.prepareStackTrace\n  AnyError.prepareStackTrace = prepareStackTrace\n}\n\n/**\n * Make a copy of the error with a source-mapped stack trace. If it couldn't\n * perform the source mapping, it'll use the original error stack.\n */\nexport function withSourceMappedStack(error: Error): Error {\n  return {\n    name: error.name,\n    message: error.message,\n    stack: sourceMappedStackTrace(error),\n  }\n}\n\n/** Get the source mapped stack trace for the error. */\nfunction sourceMappedStackTrace(error: Error): string | undefined {\n  let frames = stackFrameMap.get(error)\n\n  if (!frames) {\n    // At this point there's no guarantee that anyone has actually retrieved the\n    // stack on this error which means that our custom prepareStackTrace handler\n    // hasn't run and as a result of that we don't have the native frames stored\n    // in our weak map. In order to get around that we'll eagerly access the\n    // stack, forcing our handler to run which should ensure that the native\n    // frames are stored in our weak map.\n    (error.stack || '').toString()\n    frames = stackFrameMap.get(error)\n  }\n\n  if (!frames) {\n    return error.stack\n  }\n\n  return prepareStackTraceWithSourceMap(error, frames)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/source-map-support.ts","import * as Path from 'path'\n\nimport { GitHubRepository, IGitHubRepository } from './github-repository'\n\n/** The data-only interface for Repository for transport across IPC. */\nexport interface IRepository {\n  readonly id: number\n  /** The working directory of this repository */\n  readonly path: string\n  readonly gitHubRepository: IGitHubRepository | null\n  readonly name: string\n\n  /** Was the repository missing on disk last we checked? */\n  readonly missing: boolean\n}\n\n/** A local repository. */\nexport class Repository implements IRepository {\n  public readonly id: number\n  /** The working directory of this repository */\n  public readonly path: string\n  public readonly name: string\n  public readonly gitHubRepository: GitHubRepository | null\n\n  /** Was the repository missing on disk last we checked? */\n  public readonly missing: boolean\n\n  /** Create a new Repository from a data-only representation. */\n  public static fromJSON(json: IRepository): Repository {\n    const gitHubRepository = json.gitHubRepository\n    if (gitHubRepository) {\n       return new Repository(json.path, json.id, GitHubRepository.fromJSON(gitHubRepository), json.missing)\n    } else {\n      return new Repository(json.path, json.id, null, json.missing)\n    }\n  }\n\n  public constructor(path: string, id: number, gitHubRepository: GitHubRepository | null, missing: boolean) {\n    this.path = path\n    this.gitHubRepository = gitHubRepository\n    this.name = gitHubRepository && gitHubRepository.name || Path.basename(path)\n    this.id = id\n    this.missing = missing\n  }\n\n  /**\n   * Create a new repository the same as the receiver but with the given GitHub\n   * repository.\n   */\n  public withGitHubRepository(gitHubRepository: GitHubRepository): Repository {\n    return new Repository(this.path, this.id, gitHubRepository, this.missing)\n  }\n\n  /** Create a new repository with a changed `missing` flag. */\n  public withMissing(missing: boolean): Repository {\n    return new Repository(this.path, this.id, this.gitHubRepository, missing)\n  }\n\n  /** Create a new repository with a changed path. */\n  public withPath(path: string): Repository {\n    return new Repository(path, this.id, this.gitHubRepository, this.missing)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/models/repository.ts","module.exports = LRUCache\n\n// This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\nvar Map = require('pseudomap')\nvar util = require('util')\n\n// A linked list to keep track of recently-used-ness\nvar Yallist = require('yallist')\n\n// use symbols if possible, otherwise just _props\nvar symbols = {}\nvar hasSymbol = typeof Symbol === 'function'\nvar makeSymbol\n/* istanbul ignore if */\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol.for(key)\n  }\n} else {\n  makeSymbol = function (key) {\n    return '_' + key\n  }\n}\n\nfunction priv (obj, key, val) {\n  var sym\n  if (symbols[key]) {\n    sym = symbols[key]\n  } else {\n    sym = makeSymbol(key)\n    symbols[key] = sym\n  }\n  if (arguments.length === 2) {\n    return obj[sym]\n  } else {\n    obj[sym] = val\n    return val\n  }\n}\n\nfunction naiveLength () { return 1 }\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  if (typeof options === 'number') {\n    options = { max: options }\n  }\n\n  if (!options) {\n    options = {}\n  }\n\n  var max = priv(this, 'max', options.max)\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!max ||\n      !(typeof max === 'number') ||\n      max <= 0) {\n    priv(this, 'max', Infinity)\n  }\n\n  var lc = options.length || naiveLength\n  if (typeof lc !== 'function') {\n    lc = naiveLength\n  }\n  priv(this, 'lengthCalculator', lc)\n\n  priv(this, 'allowStale', options.stale || false)\n  priv(this, 'maxAge', options.maxAge || 0)\n  priv(this, 'dispose', options.dispose)\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity\n    }\n    priv(this, 'max', mL)\n    trim(this)\n  },\n  get: function () {\n    return priv(this, 'max')\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    priv(this, 'allowStale', !!allowStale)\n  },\n  get: function () {\n    return priv(this, 'allowStale')\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0\n    }\n    priv(this, 'maxAge', mA)\n    trim(this)\n  },\n  get: function () {\n    return priv(this, 'maxAge')\n  },\n  enumerable: true\n})\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength\n    }\n    if (lC !== priv(this, 'lengthCalculator')) {\n      priv(this, 'lengthCalculator', lC)\n      priv(this, 'length', 0)\n      priv(this, 'lruList').forEach(function (hit) {\n        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key)\n        priv(this, 'length', priv(this, 'length') + hit.length)\n      }, this)\n    }\n    trim(this)\n  },\n  get: function () { return priv(this, 'lengthCalculator') },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () { return priv(this, 'length') },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () { return priv(this, 'lruList').length },\n  enumerable: true\n})\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = priv(this, 'lruList').tail; walker !== null;) {\n    var prev = walker.prev\n    forEachStep(this, fn, walker, thisp)\n    walker = prev\n  }\n}\n\nfunction forEachStep (self, fn, node, thisp) {\n  var hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!priv(self, 'allowStale')) {\n      hit = undefined\n    }\n  }\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self)\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = priv(this, 'lruList').head; walker !== null;) {\n    var next = walker.next\n    forEachStep(this, fn, walker, thisp)\n    walker = next\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.key\n  }, this)\n}\n\nLRUCache.prototype.values = function () {\n  return priv(this, 'lruList').toArray().map(function (k) {\n    return k.value\n  }, this)\n}\n\nLRUCache.prototype.reset = function () {\n  if (priv(this, 'dispose') &&\n      priv(this, 'lruList') &&\n      priv(this, 'lruList').length) {\n    priv(this, 'lruList').forEach(function (hit) {\n      priv(this, 'dispose').call(this, hit.key, hit.value)\n    }, this)\n  }\n\n  priv(this, 'cache', new Map()) // hash of items by key\n  priv(this, 'lruList', new Yallist()) // list of items in order of use recency\n  priv(this, 'length', 0) // length of items in the list\n}\n\nLRUCache.prototype.dump = function () {\n  return priv(this, 'lruList').map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }\n    }\n  }, this).toArray().filter(function (h) {\n    return h\n  })\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return priv(this, 'lruList')\n}\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {'\n  var extras = false\n\n  var as = priv(this, 'allowStale')\n  if (as) {\n    str += '\\n  allowStale: true'\n    extras = true\n  }\n\n  var max = priv(this, 'max')\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  max: ' + util.inspect(max, opts)\n    extras = true\n  }\n\n  var maxAge = priv(this, 'maxAge')\n  if (maxAge) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts)\n    extras = true\n  }\n\n  var lc = priv(this, 'lengthCalculator')\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  length: ' + util.inspect(priv(this, 'length'), opts)\n    extras = true\n  }\n\n  var didFirst = false\n  priv(this, 'lruList').forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  '\n    } else {\n      if (extras) {\n        str += ',\\n'\n      }\n      didFirst = true\n      str += '\\n  '\n    }\n    var key = util.inspect(item.key).split('\\n').join('\\n  ')\n    var val = { value: item.value }\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge\n    }\n    if (lc !== naiveLength) {\n      val.length = item.length\n    }\n    if (isStale(this, item)) {\n      val.stale = true\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ')\n    str += key + ' => ' + val\n  })\n\n  if (didFirst || extras) {\n    str += '\\n'\n  }\n  str += '}'\n\n  return str\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || priv(this, 'maxAge')\n\n  var now = maxAge ? Date.now() : 0\n  var len = priv(this, 'lengthCalculator').call(this, value, key)\n\n  if (priv(this, 'cache').has(key)) {\n    if (len > priv(this, 'max')) {\n      del(this, priv(this, 'cache').get(key))\n      return false\n    }\n\n    var node = priv(this, 'cache').get(key)\n    var item = node.value\n\n    // dispose of the old one before overwriting\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, item.value)\n    }\n\n    item.now = now\n    item.maxAge = maxAge\n    item.value = value\n    priv(this, 'length', priv(this, 'length') + (len - item.length))\n    item.length = len\n    this.get(key)\n    trim(this)\n    return true\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > priv(this, 'max')) {\n    if (priv(this, 'dispose')) {\n      priv(this, 'dispose').call(this, key, value)\n    }\n    return false\n  }\n\n  priv(this, 'length', priv(this, 'length') + hit.length)\n  priv(this, 'lruList').unshift(hit)\n  priv(this, 'cache').set(key, priv(this, 'lruList').head)\n  trim(this)\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!priv(this, 'cache').has(key)) return false\n  var hit = priv(this, 'cache').get(key).value\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var node = priv(this, 'lruList').tail\n  if (!node) return null\n  del(this, node)\n  return node.value\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, priv(this, 'cache').get(key))\n}\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset()\n\n  var now = Date.now()\n  // A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l]\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      // dont add already expired items\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge)\n      }\n    }\n  }\n}\n\nLRUCache.prototype.prune = function () {\n  var self = this\n  priv(this, 'cache').forEach(function (value, key) {\n    get(self, key, false)\n  })\n}\n\nfunction get (self, key, doUse) {\n  var node = priv(self, 'cache').get(key)\n  if (node) {\n    var hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!priv(self, 'allowStale')) hit = undefined\n    } else {\n      if (doUse) {\n        priv(self, 'lruList').unshiftNode(node)\n      }\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale (self, hit) {\n  if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) {\n    return false\n  }\n  var stale = false\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'))\n  }\n  return stale\n}\n\nfunction trim (self) {\n  if (priv(self, 'length') > priv(self, 'max')) {\n    for (var walker = priv(self, 'lruList').tail;\n         priv(self, 'length') > priv(self, 'max') && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nfunction del (self, node) {\n  if (node) {\n    var hit = node.value\n    if (priv(self, 'dispose')) {\n      priv(self, 'dispose').call(this, hit.key, hit.value)\n    }\n    priv(self, 'length', priv(self, 'length') - hit.length)\n    priv(self, 'cache').delete(hit.key)\n    priv(self, 'lruList').removeNode(node)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.length = length\n  this.now = now\n  this.maxAge = maxAge || 0\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/lru-cache/lib/lru-cache.js\n// module id = 8\n// module chunks = 0","'use strict';\nmodule.exports = function (opts) {\n\topts = opts || {};\n\n\tvar env = opts.env || process.env;\n\tvar platform = opts.platform || process.platform;\n\n\tif (platform !== 'win32') {\n\t\treturn 'PATH';\n\t}\n\n\treturn Object.keys(env).filter(function (x) {\n\t\treturn x.toUpperCase() === 'PATH';\n\t})[0] || 'Path';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/path-key/index.js\n// module id = 9\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = util.toSetString(aStr);\n  var isDuplicate = has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    this._set[sStr] = idx;\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  var sStr = util.toSetString(aStr);\n  return has.call(this._set, sStr);\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  var sStr = util.toSetString(aStr);\n  if (has.call(this._set, sStr)) {\n    return this._set[sStr];\n  }\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/array-set.js\n// module id = 10\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/base64-vlq.js\n// module id = 11\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/source-map-generator.js\n// module id = 12\n// module chunks = 0","import { Owner, IOwner } from './owner'\nimport { IAPIRepository } from '../lib/api'\nimport { structuralEquals } from '../lib/equality'\n\n/** The data-only interface for GitHubRepository for transport across IPC. */\nexport interface IGitHubRepository {\n  readonly dbID: number | null\n  readonly name: string\n  readonly owner: IOwner\n  readonly private: boolean | null\n  readonly fork: boolean | null\n  readonly htmlURL: string | null\n  readonly defaultBranch: string | null\n  readonly cloneURL: string | null\n}\n\n/** A GitHub repository. */\nexport class GitHubRepository implements IGitHubRepository {\n  /**\n   * The ID of the repository in the app's local database. This is no relation\n   * to the API ID.\n   *\n   * May be `null` if it hasn't been inserted or retrieved from the database.\n   */\n  public readonly dbID: number | null\n\n  public readonly name: string\n  public readonly owner: Owner\n  public readonly private: boolean | null\n  public readonly fork: boolean | null\n  public readonly htmlURL: string | null\n  public readonly defaultBranch: string | null\n  public readonly cloneURL: string | null\n\n  /** Create a new GitHubRepository from its data-only representation. */\n  public static fromJSON(json: IGitHubRepository): GitHubRepository {\n    return new GitHubRepository(json.name, Owner.fromJSON(json.owner), json.dbID, json.private, json.fork, json.htmlURL, json.defaultBranch, json.cloneURL)\n  }\n\n  public constructor(name: string, owner: Owner, dbID: number | null, private_: boolean | null = null, fork: boolean | null = null, htmlURL: string | null = null, defaultBranch: string | null = 'master', cloneURL: string | null = null) {\n    this.name = name\n    this.owner = owner\n    this.dbID = dbID\n    this.private = private_\n    this.fork = fork\n    this.htmlURL = htmlURL\n    this.defaultBranch = defaultBranch\n    this.cloneURL = cloneURL\n  }\n\n  /** Create a new copy of the repository with the API information copied over. */\n  public withAPI(apiRepository: IAPIRepository): GitHubRepository {\n    const newRepository = new GitHubRepository(this.name, this.owner, this.dbID, apiRepository.private, apiRepository.fork, apiRepository.html_url, apiRepository.default_branch, apiRepository.clone_url)\n\n    return structuralEquals(newRepository, this) ? this : newRepository\n  }\n\n  public get endpoint(): string {\n    return this.owner.endpoint\n  }\n\n  /** Get the owner/name combo. */\n  public get fullName(): string {\n    return `${this.owner.login}/${this.name}`\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/models/github-repository.ts","/** The data-only interface for Owner for transport across IPC. */\nexport interface IOwner {\n  readonly login: string\n  readonly endpoint: string\n}\n\n/** The owner of a GitHubRepository. */\nexport class Owner implements IOwner {\n  public readonly login: string\n  public readonly endpoint: string\n\n  /** Create a new Owner from a data-only representation. */\n  public static fromJSON(json: IOwner): Owner {\n    return new Owner(json.login, json.endpoint)\n  }\n\n  public constructor(login: string, endpoint: string) {\n    this.login = login\n    this.endpoint = endpoint\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/models/owner.ts","module.exports = require(\"child_process\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"child_process\"\n// module id = 15\n// module chunks = 0","module.exports = require(\"crypto\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"os\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"os\"\n// module id = 17\n// module chunks = 0","import { ipcRenderer } from 'electron'\nimport { LogLevel } from '../log-level'\nimport { formatLogMessage } from '../format-log-message'\n\nconst g = global as any\n\n/**\n * Dispatches the given log entry to the main process where it will be picked\n * written to all log transports. See initializeWinston in logger.ts for more\n * details about what transports we set up.\n */\nfunction log(level: LogLevel, message: string, error?: Error) {\n  ipcRenderer.send('log', level, formatLogMessage(`[${__PROCESS_KIND__}] ${message}`, error))\n}\n\ng.log = <IDesktopLogger>{\n  error(message: string, error?: Error) {\n    log('error', message, error)\n    console.error(formatLogMessage(message, error))\n  },\n  warn(message: string, error?: Error) {\n    log('warn', message, error)\n    console.warn(formatLogMessage(message, error))\n  },\n  info(message: string, error?: Error) {\n    log('info', message, error)\n    console.info(formatLogMessage(message, error))\n  },\n  debug(message: string, error?: Error) {\n    log('debug', message, error)\n    console.debug(formatLogMessage(message, error))\n  },\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/renderer/install.ts","import { IDataStore, ISecureStore } from './stores'\nimport { getKeyForAccount } from '../lib/auth'\nimport { Account, IAccount } from '../models/account'\n\nexport class AccountsStore {\n  private dataStore: IDataStore\n  private secureStore: ISecureStore\n\n  private accounts: Account[] = []\n\n  /** A promise that will resolve when the accounts have been loaded. */\n  private loadingPromise: Promise<void>\n\n  public constructor(dataStore: IDataStore, secureStore: ISecureStore) {\n    this.dataStore = dataStore\n    this.secureStore = secureStore\n    this.loadingPromise = this.loadFromStore()\n  }\n\n  /**\n   * Get the list of accounts in the cache.\n   */\n  public async getAll(): Promise<ReadonlyArray<Account>> {\n    await this.loadingPromise\n\n    return this.accounts.slice()\n  }\n\n  /**\n   * Add the account to the store.\n   */\n  public async addAccount(account: Account): Promise<void> {\n    await this.loadingPromise\n\n    await this.secureStore.setItem(getKeyForAccount(account), account.login, account.token)\n\n    this.accounts.push(account)\n\n    this.save()\n  }\n\n  /**\n   * Remove the account from the store.\n   */\n  public async removeAccount(account: Account): Promise<void> {\n    await this.loadingPromise\n\n    await this.secureStore.deleteItem(getKeyForAccount(account), account.login)\n\n    this.accounts = this.accounts.filter(a => a.id !== account.id)\n\n    this.save()\n  }\n\n  /**\n   * Update the users in the store by mapping over them.\n   */\n  public async map(fn: (account: Account) => Promise<Account>) {\n    await this.loadingPromise\n\n    const accounts = new Array<Account>()\n    for (const account of this.accounts) {\n      const newAccount = await fn(account)\n      accounts.push(newAccount)\n    }\n\n    this.accounts = accounts\n    this.save()\n  }\n\n  /**\n   * Load the users into memory from storage.\n   */\n  private async loadFromStore(): Promise<void> {\n    const raw = this.dataStore.getItem('users')\n    if (!raw || !raw.length) {\n      return\n    }\n\n    const rawAccounts: ReadonlyArray<IAccount> = JSON.parse(raw)\n    const accountsWithTokens = rawAccounts.map(async account => {\n      const accountWithoutToken = new Account(account.login, account.endpoint, '', account.emails, account.avatarURL, account.id, account.name)\n      const token = await this.secureStore.getItem(getKeyForAccount(accountWithoutToken), account.login)\n      return accountWithoutToken.withToken(token || '')\n    })\n\n    this.accounts = await Promise.all(accountsWithTokens)\n  }\n\n  private save() {\n    const usersWithoutTokens = this.accounts.map(account => account.withToken(''))\n    this.dataStore.setItem('users', JSON.stringify(usersWithoutTokens))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/accounts-store.ts","import { remote, ipcRenderer } from 'electron'\nimport { IMessage } from './message'\nimport { AccountsStore } from './accounts-store'\nimport { RepositoriesStore } from './repositories-store'\n\nconst { BrowserWindow } = remote\n\ntype SharedProcessFunction = (args: any) => Promise<any>\nconst registeredFunctions: {[key: string]: SharedProcessFunction} = {}\n\n/**\n * Dispatch the received message to the appropriate function and respond with\n * the return value.\n */\nfunction dispatch(message: IMessage) {\n  const name = message.name\n  if (!name) {\n    console.error('Unnamed message sent to shared process:')\n    console.error(message)\n    return\n  }\n\n  const fn = registeredFunctions[name]\n  if (!fn) {\n    console.error('No handler found for message:')\n    console.error(message)\n    return\n  }\n\n  const guid = message.guid\n  const args = message.args\n  const promise = fn(args)\n  promise\n    .then(result => ({ result, type: 'result' }))\n    .catch((error: Error) => {\n      const errorInfo = {\n        name: error.name,\n        message: error.message,\n        stack: error.stack,\n      }\n      return { error: errorInfo, type: 'error' }\n    })\n    .then(response => {\n      BrowserWindow.getAllWindows().forEach(window => {\n        window.webContents.send(`shared/response/${guid}`, [ response ])\n      })\n    })\n}\n\n/** Register a function to respond to requests with the given name. */\nexport function register(name: string, fn: SharedProcessFunction) {\n  registeredFunctions[name] = fn\n}\n\n/** Tell all the windows that something was updated. */\nexport function broadcastUpdate(accountsStore: AccountsStore, repositoriesStore: RepositoriesStore) {\n  BrowserWindow.getAllWindows().forEach(async (window) => {\n    const repositories = await repositoriesStore.getRepositories()\n    const accounts = await accountsStore.getAll()\n    const state = { accounts, repositories }\n    window.webContents.send('shared/did-update', [ { state } ])\n  })\n}\n\nipcRenderer.on('shared/request', (event: Electron.IpcMessageEvent, args: any[]) => {\n  dispatch(args[0])\n})\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/communication.ts","import Dexie from 'dexie'\n\n// NB: This _must_ be incremented whenever the DB key scheme changes.\nconst DatabaseVersion = 2\n\nexport interface IDatabaseOwner {\n  readonly id?: number | null\n  readonly login: string\n  readonly endpoint: string\n}\n\nexport interface IDatabaseGitHubRepository {\n  readonly id?: number | null\n  readonly ownerID: number\n  readonly name: string\n  readonly private: boolean | null\n  readonly fork: boolean | null\n  readonly htmlURL: string | null\n  readonly defaultBranch: string | null\n  readonly cloneURL: string | null\n}\n\nexport interface IDatabaseRepository {\n  readonly id?: number | null\n  readonly gitHubRepositoryID: number | null\n  readonly path: string\n  readonly missing: boolean\n}\n\n/** The app database. */\nexport class Database extends Dexie {\n  /** The local repositories table. */\n  public repositories: Dexie.Table<IDatabaseRepository, number>\n\n  /** The GitHub repositories table. */\n  public gitHubRepositories: Dexie.Table<IDatabaseGitHubRepository, number>\n\n  /** The GitHub repository owners table. */\n  public owners: Dexie.Table<IDatabaseOwner, number>\n\n  public constructor(name: string) {\n    super(name)\n\n    this.version(1).stores({\n      repositories: '++id, &path',\n      gitHubRepositories: '++id, name',\n      owners: '++id, login',\n    })\n\n    this.version(DatabaseVersion).stores({\n      owners: '++id, &[endpoint+login]',\n    })\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/database.ts","import { Database, IDatabaseGitHubRepository, IDatabaseRepository } from './database'\nimport { Owner } from '../models/owner'\nimport { GitHubRepository } from '../models/github-repository'\nimport { Repository } from '../models/repository'\nimport { fatalError } from '../lib/fatal-error'\n\n// NB: We can't use async/await within Dexie transactions. This is because Dexie\n// uses its own Promise implementation and TypeScript doesn't know about it. See\n// https://github.com/dfahlander/Dexie.js/wiki/Typescript#async-and-await, but\n// note that their proposed work around doesn't seem to, you know, work, as of\n// TS 1.8.\n//\n// Instead of using async/await, use generator functions and `yield`.\n\n/** The store for local repositories. */\nexport class RepositoriesStore {\n  private db: Database\n\n  public constructor(db: Database) {\n    this.db = db\n  }\n\n  /** Get all the local repositories. */\n  public async getRepositories(): Promise<ReadonlyArray<Repository>> {\n    const inflatedRepos: Repository[] = []\n    const db = this.db\n    const transaction = this.db.transaction('r', this.db.repositories, this.db.gitHubRepositories, this.db.owners, function*(){\n      const repos: ReadonlyArray<IDatabaseRepository> = yield db.repositories.toArray()\n      for (const repo of repos) {\n        let inflatedRepo: Repository | null = null\n        if (repo.gitHubRepositoryID) {\n          const gitHubRepository: IDatabaseGitHubRepository = yield db.gitHubRepositories.get(repo.gitHubRepositoryID)\n          const owner = yield db.owners.get(gitHubRepository.ownerID)\n          const gitHubRepo = new GitHubRepository(gitHubRepository.name, new Owner(owner.login, owner.endpoint), gitHubRepository.id!, gitHubRepository.private, gitHubRepository.fork, gitHubRepository.htmlURL, gitHubRepository.defaultBranch, gitHubRepository.cloneURL)\n          inflatedRepo = new Repository(repo.path, repo.id!, gitHubRepo, repo.missing)\n        } else {\n          inflatedRepo = new Repository(repo.path, repo.id!, null, repo.missing)\n        }\n        inflatedRepos.push(inflatedRepo)\n      }\n    })\n\n    await transaction\n\n    return inflatedRepos\n  }\n\n  /** Add a new local repository. */\n  public async addRepository(path: string): Promise<Repository> {\n    let repository: Repository | null = null\n\n    const db = this.db\n    const transaction = this.db.transaction('r', this.db.repositories, this.db.gitHubRepositories, this.db.owners, function*(){\n      const repos: Array<IDatabaseRepository> = yield db.repositories.toArray()\n      const existing = repos.find(r => r.path === path)\n      if (existing === undefined) {\n        return\n      }\n\n      const id = existing.id!\n\n      if (!existing.gitHubRepositoryID) {\n        repository = new Repository(path, id, null, false)\n        return\n      }\n\n      const dbRepo: IDatabaseGitHubRepository = yield db.gitHubRepositories.get(existing.gitHubRepositoryID)\n      const dbOwner = yield db.owners.get(dbRepo.ownerID)\n\n      const owner = new Owner(dbOwner.login, dbOwner.endpoint)\n      const gitHubRepo = new GitHubRepository(dbRepo.name, owner, existing.gitHubRepositoryID, dbRepo.private, dbRepo.fork, dbRepo.htmlURL, dbRepo.defaultBranch, dbRepo.cloneURL)\n      repository = new Repository(path, id, gitHubRepo, false)\n    })\n\n    await transaction\n\n    if (repository !== null) {\n      return repository\n    }\n\n    const id = await this.db.repositories.add({\n      path,\n      gitHubRepositoryID: null,\n      missing: false,\n    })\n    return new Repository(path, id, null, false)\n  }\n\n  public async removeRepository(repoID: number): Promise<void> {\n    await this.db.repositories.delete(repoID)\n  }\n\n  /** Update the repository's `missing` flag. */\n  public async updateRepositoryMissing(repository: Repository, missing: boolean): Promise<Repository> {\n    const repoID = repository.id\n    if (!repoID) {\n      return fatalError('`updateRepositoryMissing` can only update `missing` for a repository which has been added to the database.')\n    }\n\n    const updatedRepository = repository.withMissing(missing)\n    const gitHubRepositoryID = updatedRepository.gitHubRepository ? updatedRepository.gitHubRepository.dbID : null\n    await this.db.repositories.put({ ...updatedRepository, gitHubRepositoryID, gitHubRepository: undefined })\n\n    return updatedRepository\n  }\n\n  /** Update the repository's path. */\n  public async updateRepositoryPath(repository: Repository, path: string): Promise<Repository> {\n    const repoID = repository.id\n    if (!repoID) {\n      return fatalError('`updateRepositoryPath` can only update the path for a repository which has been added to the database.')\n    }\n\n    const updatedRepository = repository.withPath(path)\n    const gitHubRepositoryID = updatedRepository.gitHubRepository ? updatedRepository.gitHubRepository.dbID : null\n    await this.db.repositories.put({ ...updatedRepository, gitHubRepositoryID, gitHubRepository: undefined })\n\n    return updatedRepository\n  }\n\n  /** Update or add the repository's GitHub repository. */\n  public async updateGitHubRepository(repository: Repository): Promise<Repository> {\n    const repoID = repository.id\n    if (!repoID) {\n      return fatalError('`updateGitHubRepository` can only update a GitHub repository for a repository which has been added to the database.')\n    }\n\n    const newGitHubRepo = repository.gitHubRepository\n    if (!newGitHubRepo) {\n      return fatalError('`updateGitHubRepository` can only update a GitHub repository. It cannot remove one.')\n    }\n\n    let gitHubRepositoryID: number | null = null\n    const db = this.db\n    const transaction = this.db.transaction('rw', this.db.repositories, this.db.gitHubRepositories, this.db.owners, function*() {\n      const localRepo = yield db.repositories.get(repoID)\n\n      let existingGitHubRepo: IDatabaseGitHubRepository | null = null\n      let ownerID: number | null = null\n      if (localRepo.gitHubRepositoryID) {\n        gitHubRepositoryID = localRepo.gitHubRepositoryID\n\n        existingGitHubRepo = yield db.gitHubRepositories.get(localRepo.gitHubRepositoryID)\n        if (!existingGitHubRepo) {\n          return fatalError(`Couldn't look up an existing GitHub repository.`)\n        }\n\n        const owner = yield db.owners.get(existingGitHubRepo.ownerID)\n        ownerID = owner.id\n      } else {\n        const owner = newGitHubRepo.owner\n        const existingOwner = yield db.owners\n          .where('[endpoint+login]')\n          .equals([ owner.endpoint, owner.login.toLowerCase() ])\n          .limit(1)\n          .first()\n        if (existingOwner) {\n          ownerID = existingOwner.id\n        } else {\n          ownerID = yield db.owners.add({ login: owner.login.toLowerCase(), endpoint: owner.endpoint })\n        }\n      }\n\n      let updatedInfo = {\n        private: newGitHubRepo.private,\n        fork: newGitHubRepo.fork,\n        htmlURL: newGitHubRepo.htmlURL,\n        name: newGitHubRepo.name,\n        ownerID: ownerID!,\n        cloneURL: newGitHubRepo.cloneURL,\n        defaultBranch: newGitHubRepo.defaultBranch,\n      }\n\n      if (existingGitHubRepo) {\n        updatedInfo = { ...updatedInfo, id: existingGitHubRepo.id }\n      }\n\n      gitHubRepositoryID = yield db.gitHubRepositories.put(updatedInfo)\n      yield db.repositories.update(localRepo.id, { gitHubRepositoryID })\n    })\n\n    await transaction\n\n    return repository.withGitHubRepository(new GitHubRepository(newGitHubRepo.name, newGitHubRepo.owner, gitHubRepositoryID!, newGitHubRepo.private, newGitHubRepo.fork, newGitHubRepo.htmlURL, newGitHubRepo.defaultBranch, newGitHubRepo.cloneURL))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/repositories-store.ts","import * as keytar from 'keytar'\n\nexport function setItem(key: string, login: string, value: string) {\n  return keytar.setPassword(key, login, value)\n}\n\nexport function getItem(key: string, login: string) {\n  return keytar.getPassword(key, login)\n}\n\nexport function deleteItem(key: string, login: string) {\n  return keytar.deletePassword(key, login)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/token-store.ts","import { ipcRenderer } from 'electron'\nimport { ExecutableMenuItem } from '../models/app-menu'\nimport { MenuIDs } from '../main-process/menu'\nimport { IMenuItemState } from '../lib/menu-update'\n\n/** Set the menu item's enabledness. */\nexport function updateMenuState(state: Array<{id: MenuIDs, state: IMenuItemState}>) {\n  ipcRenderer.send('update-menu-state', state)\n}\n\n/** Tell the main process that the renderer is ready. */\nexport function sendReady(time: number) {\n  ipcRenderer.send('renderer-ready', time)\n}\n\n/** Tell the main process to execute (i.e. simulate a click of) the menu item. */\nexport function executeMenuItem(item: ExecutableMenuItem) {\n  ipcRenderer.send('execute-menu-item', { id: item.id })\n}\n\n/**\n * Show the OS-provided certificate trust dialog for the certificate, using the\n * given message.\n */\nexport function showCertificateTrustDialog(certificate: Electron.Certificate, message: string) {\n  ipcRenderer.send('show-certificate-trust-dialog', { certificate, message })\n}\n\n/**\n * Tell the main process that we're going to quit. This means it should allow\n * the window to close.\n *\n * This event is sent synchronously to avoid any races with subsequent calls\n * that would tell the app to quit.\n */\nexport function sendWillQuitSync() {\n  // tslint:disable-next-line:no-sync-functions\n  ipcRenderer.sendSync('will-quit')\n}\n\n/**\n * Ask the main-process to send over a copy of the application menu.\n * The response will be send as a separate event with the name 'app-menu' and\n * will be received by the dispatcher.\n */\nexport function getAppMenu() {\n  ipcRenderer.send('get-app-menu')\n}\n\nexport interface IMenuItem {\n  /** The user-facing label. */\n  readonly label?: string\n\n  /** The action to invoke when the user selects the item. */\n  readonly action?: () => void\n\n  /** The type of item. */\n  readonly type?: 'separator'\n\n  /** Is the menu item enabled? Defaults to true. */\n  readonly enabled?: boolean\n}\n\n/**\n * There's currently no way for us to know when a contextual menu is closed (see\n * https://github.com/electron/electron/issues/9441). So we'll store the latest\n * contextual menu items we presented and assume any actions we receive are\n * coming from it.\n */\nlet currentContextualMenuItems: ReadonlyArray<IMenuItem> | null = null\n\n/**\n * Register a global handler for dispatching contextual menu actions. This\n * should be called only once, around app load time.\n */\nexport function registerContextualMenuActionDispatcher() {\n  ipcRenderer.on('contextual-menu-action', (event: Electron.IpcMessageEvent, index: number) => {\n    if (!currentContextualMenuItems) { return }\n    if (index >= currentContextualMenuItems.length) { return }\n\n    const item = currentContextualMenuItems[index]\n    const action = item.action\n    if (action) {\n      action()\n      currentContextualMenuItems = null\n    }\n  })\n}\n\n/** Show the given menu items in a contextual menu. */\nexport function showContextualMenu(items: ReadonlyArray<IMenuItem>) {\n  currentContextualMenuItems = items\n  ipcRenderer.send('show-contextual-menu', items)\n}\n\nfunction getIpcFriendlyError(error: Error) {\n  return {\n    message: error.message || `${error}`,\n    name: error.name || `${error.name}`,\n    stack: error.stack || undefined,\n  }\n}\n\nexport function reportUncaughtException(error: Error) {\n  ipcRenderer.send('uncaught-exception', getIpcFriendlyError(error))\n}\n\nexport function sendErrorReport(error: Error, extra: { [key: string]: string } = { }) {\n  ipcRenderer.send('send-error-report', {\n    error: getIpcFriendlyError(error),\n    extra,\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/ui/main-process-proxy.ts","'use strict';\n\nvar cp = require('child_process');\nvar parse = require('./lib/parse');\nvar enoent = require('./lib/enoent');\n\nfunction spawn(command, args, options) {\n    var parsed;\n    var spawned;\n\n    // Parse the arguments\n    parsed = parse(command, args, options);\n\n    // Spawn the child process\n    spawned = cp.spawn(parsed.command, parsed.args, parsed.options);\n\n    // Hook into child process \"exit\" event to emit an error if the command\n    // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n    enoent.hookChildProcess(spawned, parsed);\n\n    return spawned;\n}\n\nmodule.exports = spawn;\nmodule.exports.spawn = spawn;\nmodule.exports._parse = parse;\nmodule.exports._enoent = enoent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/cross-spawn-async/index.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nvar isWin = process.platform === 'win32';\n\nfunction notFoundError(command, syscall) {\n    var err;\n\n    err = new Error(syscall + ' ' + command + ' ENOENT');\n    err.code = err.errno = 'ENOENT';\n    err.syscall = syscall + ' ' + command;\n\n    return err;\n}\n\nfunction hookChildProcess(cp, parsed) {\n    var originalEmit;\n\n    if (!isWin) {\n        return;\n    }\n\n    originalEmit = cp.emit;\n    cp.emit = function (name, arg1) {\n        var err;\n\n        // If emitting \"exit\" event and exit code is 1, we need to check if\n        // the command exists and emit an \"error\" instead\n        // See: https://github.com/IndigoUnited/node-cross-spawn/issues/16\n        if (name === 'exit') {\n            err = verifyENOENT(arg1, parsed, 'spawn');\n\n            if (err) {\n                return originalEmit.call(cp, 'error', err);\n            }\n        }\n\n        return originalEmit.apply(cp, arguments);\n    };\n}\n\nfunction verifyENOENT(status, parsed, syscall) {\n    if (isWin && status === 1 && !parsed.file) {\n        return notFoundError(parsed.original, syscall);\n    }\n\n    return null;\n}\n\nmodule.exports.hookChildProcess = hookChildProcess;\nmodule.exports.verifyENOENT = verifyENOENT;\nmodule.exports.notFoundError = notFoundError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/cross-spawn-async/lib/enoent.js\n// module id = 26\n// module chunks = 0","'use strict';\n\nvar fs = require('fs');\nvar LRU = require('lru-cache');\nvar resolveCommand = require('./resolveCommand');\n\nvar isWin = process.platform === 'win32';\nvar shebangCache = new LRU({ max: 50, maxAge: 30 * 1000 });  // Cache just for 30sec\n\nfunction readShebang(command) {\n    var buffer;\n    var fd;\n    var match;\n    var shebang;\n\n    // Check if it is in the cache first\n    if (shebangCache.has(command)) {\n        return shebangCache.get(command);\n    }\n\n    // Read the first 150 bytes from the file\n    buffer = new Buffer(150);\n\n    try {\n        fd = fs.openSync(command, 'r');\n        fs.readSync(fd, buffer, 0, 150, 0);\n        fs.closeSync(fd);\n    } catch (e) { /* empty */ }\n\n    // Check if it is a shebang\n    match = buffer.toString().trim().match(/#!(.+)/i);\n\n    if (match) {\n        shebang = match[1].replace(/\\/usr\\/bin\\/env\\s+/i, '');   // Remove /usr/bin/env\n    }\n\n    // Store the shebang in the cache\n    shebangCache.set(command, shebang);\n\n    return shebang;\n}\n\nfunction escapeArg(arg, quote) {\n    // Convert to string\n    arg = '' + arg;\n\n    // If we are not going to quote the argument,\n    // escape shell metacharacters, including double and single quotes:\n    if (!quote) {\n        arg = arg.replace(/([\\(\\)%!\\^<>&|;,\"'\\s])/g, '^$1');\n    } else {\n        // Sequence of backslashes followed by a double quote:\n        // double up all the backslashes and escape the double quote\n        arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');\n\n        // Sequence of backslashes followed by the end of the string\n        // (which will become a double quote later):\n        // double up all the backslashes\n        arg = arg.replace(/(\\\\*)$/, '$1$1');\n\n        // All other backslashes occur literally\n\n        // Quote the whole thing:\n        arg = '\"' + arg + '\"';\n    }\n\n    return arg;\n}\n\nfunction escapeCommand(command) {\n    // Do not escape if this command is not dangerous..\n    // We do this so that commands like \"echo\" or \"ifconfig\" work\n    // Quoting them, will make them unaccessible\n    return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArg(command, true);\n}\n\nfunction parse(command, args, options) {\n    var shebang;\n    var applyQuotes;\n    var file;\n    var original;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n    original = command;\n\n    if (isWin) {\n        // Detect & add support for shebangs\n        file = resolveCommand(command);\n        file = file || resolveCommand(command, true);\n        shebang = file && readShebang(file);\n\n        if (shebang) {\n            args.unshift(file);\n            command = shebang;\n        }\n\n        // Escape command & arguments\n        applyQuotes = command !== 'echo';  // Do not quote arguments for the special \"echo\" command\n        command = escapeCommand(command);\n        args = args.map(function (arg) {\n            return escapeArg(arg, applyQuotes);\n        });\n\n        // Use cmd.exe\n        args = ['/s', '/c', '\"' + command + (args.length ? ' ' + args.join(' ') : '') + '\"'];\n        command = process.env.comspec || 'cmd.exe';\n\n        // Tell node's spawn that the arguments are already escaped\n        options.windowsVerbatimArguments = true;\n    }\n\n    return {\n        command: command,\n        args: args,\n        options: options,\n        file: file,\n        original: original,\n    };\n}\n\nmodule.exports = parse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/cross-spawn-async/lib/parse.js\n// module id = 27\n// module chunks = 0","'use strict';\n\nvar path = require('path');\nvar which = require('which');\nvar LRU = require('lru-cache');\n\nvar commandCache = new LRU({ max: 50, maxAge: 30 * 1000 });  // Cache just for 30sec\nvar hasSepInPathRegExp = new RegExp(process.platform === 'win32' ? /[\\/\\\\]/ : /\\//);\n\nfunction resolveCommand(command, noExtension) {\n    var resolved;\n\n    // If command looks like a file path, make it absolute to make it canonical\n    // and also to circuvent a bug in which, see: https://github.com/npm/node-which/issues/33\n    if (hasSepInPathRegExp.test(command)) {\n        command = path.resolve(command);\n    }\n\n    noExtension = !!noExtension;\n    resolved = commandCache.get(command + '!' + noExtension);\n\n    // Check if its resolved in the cache\n    if (commandCache.has(command)) {\n        return commandCache.get(command);\n    }\n\n    try {\n        resolved = !noExtension ?\n            which.sync(command) :\n            which.sync(command, { pathExt: path.delimiter + (process.env.PATHEXT || '') });\n    } catch (e) { /* empty */ }\n\n    commandCache.set(command + '!' + noExtension, resolved);\n\n    return resolved;\n}\n\nmodule.exports = resolveCommand;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/cross-spawn-async/lib/resolveCommand.js\n// module id = 28\n// module chunks = 0","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/deep-equal/index.js\n// module id = 29\n// module chunks = 0","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/deep-equal/lib/is_arguments.js\n// module id = 30\n// module chunks = 0","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/deep-equal/lib/keys.js\n// module id = 31\n// module chunks = 0","(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n   typeof define === 'function' && define.amd ? define(factory) :\n   (global.Dexie = factory());\n}(this, (function () { 'use strict';\n\n/*\r\n* Dexie.js - a minimalistic wrapper for IndexedDB\r\n* ===============================================\r\n*\r\n* By David Fahlander, david.fahlander@gmail.com\r\n*\r\n* Version 1.5.1, Tue Nov 01 2016\r\n* www.dexie.com\r\n* Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\r\n*/\nvar keys = Object.keys;\nvar isArray = Array.isArray;\nvar _global = typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : global;\n\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object') return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\n\nvar getProto = Object.getPrototypeOf;\nvar _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\n\nfunction props(proto, extension) {\n    if (typeof extension === 'function') extension = extension(getProto(proto));\n    keys(extension).forEach(function (key) {\n        setProp(proto, key, extension[key]);\n    });\n}\n\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    Object.defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\n\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\n\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\nfunction getPropertyDescriptor(obj, prop) {\n    var pd = getOwnPropertyDescriptor(obj, prop),\n        proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\n\nvar _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\n\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\n\nfunction doFakeAutoComplete(fn) {\n    var to = setTimeout(fn, 1000);\n    clearTimeout(to);\n}\n\nfunction assert(b) {\n    if (!b) throw new Error(\"Assertion Failed\");\n}\n\nfunction asap(fn) {\n    if (_global.setImmediate) setImmediate(fn);else setTimeout(fn, 0);\n}\n\n\n\n/** Generate an object (hash map) based on given array.\r\n * @param extractor Function taking an array item and its index and returning an array of 2 items ([key, value]) to\r\n *        instert on the resulting object for each item in the array. If this function returns a falsy value, the\r\n *        current item wont affect the resulting object.\r\n */\nfunction arrayToObject(array, extractor) {\n    return array.reduce(function (result, item, i) {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue) result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\n\nfunction trycatcher(fn, reject) {\n    return function () {\n        try {\n            fn.apply(this, arguments);\n        } catch (e) {\n            reject(e);\n        }\n    };\n}\n\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    } catch (ex) {\n        onerror && onerror(ex);\n    }\n}\n\nfunction getByKeyPath(obj, keyPath) {\n    // http://www.w3.org/TR/IndexedDB/#steps-for-extracting-a-key-from-a-value-using-a-key-path\n    if (hasOwn(obj, keyPath)) return obj[keyPath]; // This line is moved from last to first for optimization purpose.\n    if (!keyPath) return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\n\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined) return;\n    if ('isFrozen' in Object && Object.isFrozen(obj)) return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    } else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\") {\n                if (value === undefined) delete obj[currentKeyPath];else obj[currentKeyPath] = value;\n            } else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj) innerObj = obj[currentKeyPath] = {};\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        } else {\n            if (value === undefined) delete obj[keyPath];else obj[keyPath] = value;\n        }\n    }\n}\n\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string') setByKeyPath(obj, keyPath, undefined);else if ('length' in keyPath) [].map.call(keyPath, function (kp) {\n        setByKeyPath(obj, kp, undefined);\n    });\n}\n\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m)) rv[m] = obj[m];\n    }\n    return rv;\n}\n\nfunction deepClone(any) {\n    if (!any || typeof any !== 'object') return any;\n    var rv;\n    if (isArray(any)) {\n        rv = [];\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(deepClone(any[i]));\n        }\n    } else if (any instanceof Date) {\n        rv = new Date();\n        rv.setTime(any.getTime());\n    } else {\n        rv = any.constructor ? Object.create(any.constructor.prototype) : {};\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = deepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    // Compares objects a and b and produces a diff object.\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach(function (prop) {\n        if (!hasOwn(b, prop)) rv[prfx + prop] = undefined; // Property removed\n        else {\n                var ap = a[prop],\n                    bp = b[prop];\n                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp && ap.constructor === bp.constructor)\n                    // Same type of object but its properties may have changed\n                    getObjectDiff(ap, bp, rv, prfx + prop + \".\");else if (ap !== bp) rv[prfx + prop] = b[prop]; // Primitive value changed\n            }\n    });\n    keys(b).forEach(function (prop) {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop]; // Property added\n        }\n    });\n    return rv;\n}\n\n// If first argument is iterable or array-like, return it as an array\nvar iteratorSymbol = typeof Symbol !== 'undefined' && Symbol.iterator;\nvar getIteratorOf = iteratorSymbol ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () {\n    return null;\n};\n\nvar NO_CHAR_ARRAY = {};\n// Takes one or several arguments and returns an array based on the following criteras:\n// * If several arguments provided, return arguments converted to an array in a way that\n//   still allows javascript engine to optimize the code.\n// * If single argument is an array, return a clone of it.\n// * If this-pointer equals NO_CHAR_ARRAY, don't accept strings as valid iterables as a special\n//   case to the two bullets below.\n// * If single argument is an iterable, convert it to an array and return the resulting array.\n// * If single argument is array-like (has length of type number), convert it to an array.\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike)) return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string') return [arrayLike];\n        if (it = getIteratorOf(arrayLike)) {\n            a = [];\n            while (x = it.next(), !x.done) {\n                a.push(x.value);\n            }return a;\n        }\n        if (arrayLike == null) return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--) {\n                a[i] = arrayLike[i];\n            }return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--) {\n        a[i] = arguments[i];\n    }return a;\n}\n\nvar concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\n\nfunction nop() {}\nfunction mirror(val) {\n    return val;\n}\nfunction pureFunctionChain(f1, f2) {\n    // Enables chained events that takes ONE argument and returns it to the next function in chain.\n    // This pattern is used in the hook(\"reading\") event.\n    if (f1 == null || f1 === mirror) return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\n\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\n\nfunction hookCreatingChain(f1, f2) {\n    // Enables chained events that takes several arguments and may modify first argument by making a modification and then returning the same instance.\n    // This pattern is used in the hook(\"creating\") event.\n    if (f1 === nop) return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined) arguments[0] = res;\n        var onsuccess = this.onsuccess,\n            // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\n\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n            // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\n\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res); // If f1 returns new modifications, extend caller's modifications with the result before calling next in chain.\n        var onsuccess = this.onsuccess,\n            // In case event listener has set this.onsuccess\n        onerror = this.onerror; // In case event listener has set this.onerror\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess) this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror) this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ? res2 === undefined ? undefined : res2 : extend(res, res2);\n    };\n}\n\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false) return false;\n        return f1.apply(this, arguments);\n    };\n}\n\n\n\nfunction promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this,\n                i = arguments.length,\n                args = new Array(i);\n            while (i--) {\n                args[i] = arguments[i];\n            }return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\n// By default, debug will be true only if platform is a web platform and its page is served from localhost.\n// When debug = true, error's stacks will contain asyncronic long stacks.\nvar debug = typeof location !== 'undefined' &&\n// By default, use debug mode if served from localhost.\n/^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\n\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\n\nvar libraryFilter = function () {\n    return true;\n};\n\nvar NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\n\nfunction getErrorWithStack() {\n    \"use strict\";\n\n    if (NEEDS_THROW_FOR_STACK) try {\n        // Doing something naughty in strict mode here to trigger a specific error\n        // that can be explicitely ignored in debugger's exception settings.\n        // If we'd just throw new Error() here, IE's debugger's exception settings\n        // will just consider it as \"exception thrown by javascript code\" which is\n        // something you wouldn't want it to ignore.\n        getErrorWithStack.arguments;\n        throw new Error(); // Fallback if above line don't throw.\n    } catch (e) {\n        return e;\n    }\n    return new Error();\n}\n\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack) return \"\";\n    numIgnoredFrames = numIgnoredFrames || 0;\n    if (stack.indexOf(exception.name) === 0) numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n').slice(numIgnoredFrames).filter(libraryFilter).map(function (frame) {\n        return \"\\n\" + frame;\n    }).join('');\n}\n\nfunction deprecated(what, fn) {\n    return function () {\n        console.warn(what + \" is deprecated. See https://github.com/dfahlander/Dexie.js/wiki/Deprecations. \" + prettyStack(getErrorWithStack(), 1));\n        return fn.apply(this, arguments);\n    };\n}\n\nvar dexieErrorNames = ['Modify', 'Bulk', 'OpenFailed', 'VersionChange', 'Schema', 'Upgrade', 'InvalidTable', 'MissingAPI', 'NoSuchDatabase', 'InvalidArgument', 'SubTransaction', 'Unsupported', 'Internal', 'DatabaseClosed', 'IncompatiblePromise'];\n\nvar idbDomErrorNames = ['Unknown', 'Constraint', 'Data', 'TransactionInactive', 'ReadOnly', 'Version', 'NotFound', 'InvalidState', 'InvalidAccess', 'Abort', 'Timeout', 'QuotaExceeded', 'Syntax', 'DataClone'];\n\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\n\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\"\n};\n\n//\n// DexieError - base class of all out exceptions.\n//\nfunction DexieError(name, msg) {\n    // Reason we don't use ES6 classes is because:\n    // 1. It bloats transpiled code and increases size of minified code.\n    // 2. It doesn't give us much in this case.\n    // 3. It would require sub classes to call super(), which\n    //    is not needed when deriving from Error.\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\n\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack || (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () {\n        return this.name + \": \" + this.message;\n    }\n});\n\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + failures.map(function (f) {\n        return f.toString();\n    }).filter(function (v, i, s) {\n        return s.indexOf(v) === i;\n    }) // Only unique error strings\n    .join('\\n');\n}\n\n//\n// ModifyError - thrown in WriteableCollection.modify()\n// Specific constructor because it contains members failures and failedKeys.\n//\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n}\nderive(ModifyError).from(DexieError);\n\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\n\n//\n//\n// Dynamically generate error names and exception classes based\n// on the names in errorList.\n//\n//\n\n// Map of {ErrorName -> ErrorName + \"Error\"}\nvar errnames = errorList.reduce(function (obj, name) {\n    return obj[name] = name + \"Error\", obj;\n}, {});\n\n// Need an alias for DexieError because we're gonna create subclasses with the same name.\nvar BaseException = DexieError;\n// Map of {ErrorName -> exception constructor}\nvar exceptions = errorList.reduce(function (obj, name) {\n    // Let the name be \"DexieError\" because this name may\n    // be shown in call stack and when debugging. DexieError is\n    // the most true name because it derives from DexieError,\n    // and we cannot change Function.name programatically without\n    // dynamically create a Function object, which would be considered\n    // 'eval-evil'.\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        } else if (typeof msgOrInner === 'string') {\n            this.message = msgOrInner;\n            this.inner = inner || null;\n        } else if (typeof msgOrInner === 'object') {\n            this.message = msgOrInner.name + ' ' + msgOrInner.message;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\n\n// Use ECMASCRIPT standard exceptions where applicable:\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\n\nvar exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\n\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name]) return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        // Derive stack from inner exception if it has a stack\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\n\nvar fullNameExceptions = errorList.reduce(function (obj, name) {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1) obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\n\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            // Subscribe. If additional arguments than just the subscriber was provided, forward them as well.\n            var i = arguments.length,\n                args = new Array(i - 1);\n            while (--i) {\n                args[i - 1] = arguments[i];\n            }evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        } else if (typeof eventName === 'string') {\n            // Return interface allowing to fire or unsubscribe from event\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n\n    return rv;\n\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object') return addConfiguredEvents(eventName);\n        if (!chainFunction) chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction) defaultFunction = nop;\n\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) {\n                    return fn !== cb;\n                });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n\n    function addConfiguredEvents(cfg) {\n        // events(this, {reading: [functionChain, nop]});\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            } else if (args === 'asap') {\n                // Rather than approaching event subscription using a functional approach, we here do it in a for-loop where subscriber is executed in its own stack\n                // enabling that any exception that occur wont disturb the initiator and also not nescessary be catched and forgotten.\n                var context = add(eventName, mirror, function fire() {\n                    // Optimazation-safe cloning of arguments into args.\n                    var i = arguments.length,\n                        args = new Array(i);\n                    while (i--) {\n                        args[i] = arguments[i];\n                    } // All each subscriber:\n                    context.subscribers.forEach(function (fn) {\n                        asap(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            } else throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\n//\n// Promise Class for Dexie library\n//\n// I started out writing this Promise class by copying promise-light (https://github.com/taylorhakes/promise-light) by\n// https://github.com/taylorhakes - an A+ and ECMASCRIPT 6 compliant Promise implementation.\n//\n// Modifications needed to be done to support indexedDB because it wont accept setTimeout()\n// (See discussion: https://github.com/promises-aplus/promises-spec/issues/45) .\n// This topic was also discussed in the following thread: https://github.com/promises-aplus/promises-spec/issues/45\n//\n// This implementation will not use setTimeout or setImmediate when it's not needed. The behavior is 100% Promise/A+ compliant since\n// the caller of new Promise() can be certain that the promise wont be triggered the lines after constructing the promise.\n//\n// In previous versions this was fixed by not calling setTimeout when knowing that the resolve() or reject() came from another\n// tick. In Dexie v1.4.0, I've rewritten the Promise class entirely. Just some fragments of promise-light is left. I use\n// another strategy now that simplifies everything a lot: to always execute callbacks in a new tick, but have an own microTick\n// engine that is used instead of setImmediate() or setTimeout().\n// Promise class has also been optimized a lot with inspiration from bluebird - to avoid closures as much as possible.\n// Also with inspiration from bluebird, asyncronic stacks in debug mode.\n//\n// Specific non-standard features of this Promise class:\n// * Async static context support (Promise.PSD)\n// * Promise.follow() method built upon PSD, that allows user to track all promises created from current stack frame\n//   and below + all promises that those promises creates or awaits.\n// * Detect any unhandled promise in a PSD-scope (PSD.onunhandled). \n//\n// David Fahlander, https://github.com/dfahlander\n//\n\n// Just a pointer that only this module knows about.\n// Used in Promise constructor to emulate a private constructor.\nvar INTERNAL = {};\n\n// Async stacks (long stacks) must not grow infinitely.\nvar LONG_STACKS_CLIP_LIMIT = 100;\nvar MAX_LONG_STACKS = 20;\nvar stack_being_generated = false;\n\n/* The default \"nextTick\" function used only for the very first promise in a promise chain.\r\n   As soon as then promise is resolved or rejected, all next tasks will be executed in micro ticks\r\n   emulated in this module. For indexedDB compatibility, this means that every method needs to \r\n   execute at least one promise before doing an indexedDB operation. Dexie will always call \r\n   db.ready().then() for every operation to make sure the indexedDB event is started in an\r\n   emulated micro tick.\r\n*/\nvar schedulePhysicalTick = _global.setImmediate ?\n// setImmediate supported. Those modern platforms also supports Function.bind().\nsetImmediate.bind(null, physicalTick) : _global.MutationObserver ?\n// MutationObserver supported\nfunction () {\n    var hiddenDiv = document.createElement(\"div\");\n    new MutationObserver(function () {\n        physicalTick();\n        hiddenDiv = null;\n    }).observe(hiddenDiv, { attributes: true });\n    hiddenDiv.setAttribute('i', '1');\n} :\n// No support for setImmediate or MutationObserver. No worry, setTimeout is only called\n// once time. Every tick that follows will be our emulated micro tick.\n// Could have uses setTimeout.bind(null, 0, physicalTick) if it wasnt for that FF13 and below has a bug \nfunction () {\n    setTimeout(physicalTick, 0);\n};\n\n// Confifurable through Promise.scheduler.\n// Don't export because it would be unsafe to let unknown\n// code call it unless they do try..catch within their callback.\n// This function can be retrieved through getter of Promise.scheduler though,\n// but users must not do Promise.scheduler (myFuncThatThrows exception)!\nvar asap$1 = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\n\nvar isOutsideMicroTick = true;\nvar needsNewPhysicalTick = true;\nvar unhandledErrors = [];\nvar rejectingErrors = [];\nvar currentFulfiller = null;\nvar rejectionMapper = mirror; // Remove in next major when removing error mapping of DOMErrors and DOMExceptions\n\nvar globalPSD = {\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    //env: null, // Will be set whenever leaving a scope using wrappers.snapshot()\n    finalize: function () {\n        this.unhandleds.forEach(function (uh) {\n            try {\n                globalError(uh[0], uh[1]);\n            } catch (e) {}\n        });\n    }\n};\n\nvar PSD = globalPSD;\n\nvar microtickQueue = []; // Callbacks to call in this or next physical tick.\nvar numScheduledCalls = 0; // Number of listener-calls left to do in this physical tick.\nvar tickFinalizers = []; // Finalizers to call when there are no more async calls scheduled within current physical tick.\n\n// Wrappers are not being used yet. Their framework is functioning and can be used\n// to replace environment during a PSD scope (a.k.a. 'zone').\n/* **KEEP** export var wrappers = (() => {\r\n    var wrappers = [];\r\n\r\n    return {\r\n        snapshot: () => {\r\n            var i = wrappers.length,\r\n                result = new Array(i);\r\n            while (i--) result[i] = wrappers[i].snapshot();\r\n            return result;\r\n        },\r\n        restore: values => {\r\n            var i = wrappers.length;\r\n            while (i--) wrappers[i].restore(values[i]);\r\n        },\r\n        wrap: () => wrappers.map(w => w.wrap()),\r\n        add: wrapper => {\r\n            wrappers.push(wrapper);\r\n        }\r\n    };\r\n})();\r\n*/\n\nfunction Promise(fn) {\n    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop; // Deprecate in next major. Not needed. Better to use global error handler.\n\n    // A library may set `promise._lib = true;` after promise is created to make resolve() or reject()\n    // execute the microtask engine implicitely within the call to resolve() or reject().\n    // To remain A+ compliant, a library must only set `_lib=true` if it can guarantee that the stack\n    // only contains library code when calling resolve() or reject().\n    // RULE OF THUMB: ONLY set _lib = true for promises explicitely resolving/rejecting directly from\n    // global scope (event handler, timer etc)!\n    this._lib = false;\n    // Current async scope\n    var psd = this._PSD = PSD;\n\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0; // Number of previous promises (for long stacks)\n        linkToPreviousPromise(this, currentFulfiller);\n    }\n\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL) throw new TypeError('Not a function');\n        // Private constructor (INTERNAL, state, value).\n        // Used internally by Promise.resolve() and Promise.reject().\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false) handleRejection(this, this._value); // Map error, set stack and addPossiblyUnhandledError().\n        return;\n    }\n\n    this._state = null; // null (=pending), false (=rejected) or true (=resolved)\n    this._value = null; // error or result\n    ++psd.ref; // Refcounting current scope\n    executePromiseTask(this, fn);\n}\n\nprops(Promise.prototype, {\n\n    then: function (onFulfilled, onRejected) {\n        var _this = this;\n\n        var rv = new Promise(function (resolve, reject) {\n            propagateToListener(_this, new Listener(onFulfilled, onRejected, resolve, reject));\n        });\n        debug && (!this._prev || this._state === null) && linkToPreviousPromise(rv, this);\n        return rv;\n    },\n\n    _then: function (onFulfilled, onRejected) {\n        // A little tinier version of then() that don't have to create a resulting promise.\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected));\n    },\n\n    catch: function (onRejected) {\n        if (arguments.length === 1) return this.then(null, onRejected);\n        // First argument is the Error type to catch\n        var type = arguments[0],\n            handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, function (err) {\n            return (\n                // Catching errors by its constructor type (similar to java / c++ / c#)\n                // Sample: promise.catch(TypeError, function (e) { ... });\n                err instanceof type ? handler(err) : PromiseReject(err)\n            );\n        }) : this.then(null, function (err) {\n            return (\n                // Catching errors by the error.name property. Makes sense for indexedDB where error type\n                // is always DOMError but where e.name tells the actual error type.\n                // Sample: promise.catch('ConstraintError', function (e) { ... });\n                err && err.name === type ? handler(err) : PromiseReject(err)\n            );\n        });\n    },\n\n    finally: function (onFinally) {\n        return this.then(function (value) {\n            onFinally();\n            return value;\n        }, function (err) {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n\n    // Deprecate in next major. Needed only for db.on.error.\n    uncaught: function (uncaughtHandler) {\n        var _this2 = this;\n\n        // Be backward compatible and use \"onuncatched\" as the event name on this.\n        // Handle multiple subscribers through reverseStoppableEventChain(). If a handler returns `false`, bubbling stops.\n        this.onuncatched = reverseStoppableEventChain(this.onuncatched, uncaughtHandler);\n        // In case caller does this on an already rejected promise, assume caller wants to point out the error to this promise and not\n        // a previous promise. Reason: the prevous promise may lack onuncatched handler. \n        if (this._state === false && unhandledErrors.indexOf(this) === -1) {\n            // Replace unhandled error's destinaion promise with this one!\n            unhandledErrors.some(function (p, i, l) {\n                return p._value === _this2._value && (l[i] = _this2);\n            });\n            // Actually we do this shit because we need to support db.on.error() correctly during db.open(). If we deprecate db.on.error, we could\n            // take away this piece of code as well as the onuncatched and uncaught() method.\n        }\n        return this;\n    },\n\n    stack: {\n        get: function () {\n            if (this._stack) return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null) this._stack = stack; // Stack may be updated on reject.\n                return stack;\n            } finally {\n                stack_being_generated = false;\n            }\n        }\n    }\n});\n\nfunction Listener(onFulfilled, onRejected, resolve, reject) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = PSD;\n}\n\n// Promise Static Properties\nprops(Promise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments); // Supports iterables, implicit arguments and array-like.\n        return new Promise(function (resolve, reject) {\n            if (values.length === 0) resolve([]);\n            var remaining = values.length;\n            values.forEach(function (a, i) {\n                return Promise.resolve(a).then(function (x) {\n                    values[i] = x;\n                    if (! --remaining) resolve(values);\n                }, reject);\n            });\n        });\n    },\n\n    resolve: function (value) {\n        if (value instanceof Promise) return value;\n        if (value && typeof value.then === 'function') return new Promise(function (resolve, reject) {\n            value.then(resolve, reject);\n        });\n        return new Promise(INTERNAL, true, value);\n    },\n\n    reject: PromiseReject,\n\n    race: function () {\n        var values = getArrayOf.apply(null, arguments);\n        return new Promise(function (resolve, reject) {\n            values.map(function (value) {\n                return Promise.resolve(value).then(resolve, reject);\n            });\n        });\n    },\n\n    PSD: {\n        get: function () {\n            return PSD;\n        },\n        set: function (value) {\n            return PSD = value;\n        }\n    },\n\n    newPSD: newScope,\n\n    usePSD: usePSD,\n\n    scheduler: {\n        get: function () {\n            return asap$1;\n        },\n        set: function (value) {\n            asap$1 = value;\n        }\n    },\n\n    rejectionMapper: {\n        get: function () {\n            return rejectionMapper;\n        },\n        set: function (value) {\n            rejectionMapper = value;\n        } // Map reject failures\n    },\n\n    follow: function (fn) {\n        return new Promise(function (resolve, reject) {\n            return newScope(function (resolve, reject) {\n                var psd = PSD;\n                psd.unhandleds = []; // For unhandled standard- or 3rd party Promises. Checked at psd.finalize()\n                psd.onunhandled = reject; // Triggered directly on unhandled promises of this library.\n                psd.finalize = callBoth(function () {\n                    var _this3 = this;\n\n                    // Unhandled standard or 3rd part promises are put in PSD.unhandleds and\n                    // examined upon scope completion while unhandled rejections in this Promise\n                    // will trigger directly through psd.onunhandled\n                    run_at_end_of_this_or_next_physical_tick(function () {\n                        _this3.unhandleds.length === 0 ? resolve() : reject(_this3.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, resolve, reject);\n        });\n    },\n\n    on: Events(null, { \"error\": [reverseStoppableEventChain, defaultErrorHandler] // Default to defaultErrorHandler\n    })\n\n});\n\nvar PromiseOnError = Promise.on.error;\nPromiseOnError.subscribe = deprecated(\"Promise.on('error')\", PromiseOnError.subscribe);\nPromiseOnError.unsubscribe = deprecated(\"Promise.on('error').unsubscribe\", PromiseOnError.unsubscribe);\n\n/**\r\n* Take a potentially misbehaving resolver function and make sure\r\n* onFulfilled and onRejected are only called once.\r\n*\r\n* Makes no guarantees about asynchrony.\r\n*/\nfunction executePromiseTask(promise, fn) {\n    // Promise Resolution Procedure:\n    // https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    try {\n        fn(function (value) {\n            if (promise._state !== null) return;\n            if (value === promise) throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, function (resolve, reject) {\n                    value instanceof Promise ? value._then(resolve, reject) : value.then(resolve, reject);\n                });\n            } else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick) endMicroTickScope();\n        }, handleRejection.bind(null, promise)); // If Function.bind is not supported. Exception is handled in catch below\n    } catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\n\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null) return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: function () {\n                return stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack;\n            }\n        });\n    });\n    // Add the failure to a list of possibly uncaught errors\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick) endMicroTickScope();\n}\n\nfunction propagateAllListeners(promise) {\n    //debug && linkToPreviousPromise(promise);\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize(); // if psd.ref reaches zero, call psd.finalize();\n    if (numScheduledCalls === 0) {\n        // If numScheduledCalls is 0, it means that our stack is not in a callback of a scheduled call,\n        // and that no deferreds where listening to this rejection or success.\n        // Since there is a risk that our stack can contain application code that may\n        // do stuff after this code is finished that may generate new calls, we cannot\n        // call finalizers here.\n        ++numScheduledCalls;\n        asap$1(function () {\n            if (--numScheduledCalls === 0) finalizePhysicalTick(); // Will detect unhandled errors\n        }, []);\n    }\n}\n\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        // This Listener doesnt have a listener for the event being triggered (onFulfilled or onReject) so lets forward the event to any eventual listeners on the Promise instance returned by then() or catch()\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    var psd = listener.psd;\n    ++psd.ref;\n    ++numScheduledCalls;\n    asap$1(callListener, [cb, promise, listener]);\n}\n\nfunction callListener(cb, promise, listener) {\n    var outerScope = PSD;\n    var psd = listener.psd;\n    try {\n        if (psd !== outerScope) {\n            // **KEEP** outerScope.env = wrappers.snapshot(); // Snapshot outerScope's environment.\n            PSD = psd;\n            // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.\n        }\n\n        // Set static variable currentFulfiller to the promise that is being fullfilled,\n        // so that we connect the chain of promises (for long stacks support)\n        currentFulfiller = promise;\n\n        // Call callback and resolve our listener with it's return value.\n        var value = promise._value,\n            ret;\n        if (promise._state) {\n            ret = cb(value);\n        } else {\n            if (rejectingErrors.length) rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1) markErrorAsHandled(promise); // Callback didnt do Promise.reject(err) nor reject(err) onto another promise.\n        }\n        listener.resolve(ret);\n    } catch (e) {\n        // Exception thrown in callback. Reject our listener.\n        listener.reject(e);\n    } finally {\n        // Restore PSD, env and currentFulfiller.\n        if (psd !== outerScope) {\n            PSD = outerScope;\n            // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment\n        }\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n        --psd.ref || psd.finalize();\n    }\n}\n\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit) return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value,\n            errorName,\n            message;\n\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        } else {\n            errorName = failure; // If error is undefined or null, show that.\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1) stacks.push(stack);\n        if (promise._prev) getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\n\nfunction linkToPreviousPromise(promise, prev) {\n    // Support long stacks by linking to previous completed promise.\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        // Prohibit infinite Promise loops to get an infinite long memory consuming \"tail\".\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\n\n/* The callback to schedule with setImmediate() or setTimeout().\r\n   It runs a virtual microtick and executes any callback registered in microtickQueue.\r\n */\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\n\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\n\n/* Executes micro-ticks without doing try..catch.\r\n   This can be possible because we only use this internally and\r\n   the registered functions are exception-safe (they do try..catch\r\n   internally before calling any external method). If registering\r\n   functions in the microtickQueue that are not exception-safe, this\r\n   would destroy the framework and make it instable. So we don't export\r\n   our asap method.\r\n*/\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\n\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(function (p) {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0); // Clone first because finalizer may remove itself from list.\n    var i = finalizers.length;\n    while (i) {\n        finalizers[--i]();\n    }\n}\n\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap$1(function () {\n        if (--numScheduledCalls === 0) finalizePhysicalTick();\n    }, []);\n}\n\nfunction addPossiblyUnhandledError(promise) {\n    // Only add to unhandledErrors if not already there. The first one to add to this list\n    // will be upon the first rejection so that the root cause (first promise in the\n    // rejection chain) is the one listed.\n    if (!unhandledErrors.some(function (p) {\n        return p._value === promise._value;\n    })) unhandledErrors.push(promise);\n}\n\nfunction markErrorAsHandled(promise) {\n    // Called when a reject handled is actually being called.\n    // Search in unhandledErrors for any promise whos _value is this promise_value (list\n    // contains only rejected promises, and only one item per error)\n    var i = unhandledErrors.length;\n    while (i) {\n        if (unhandledErrors[--i]._value === promise._value) {\n            // Found a promise that failed with this same error object pointer,\n            // Remove that since there is a listener that actually takes care of it.\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n    }\n}\n\n// By default, log uncaught errors to the console\nfunction defaultErrorHandler(e) {\n    console.warn('Unhandled rejection: ' + (e.stack || e));\n}\n\nfunction PromiseReject(reason) {\n    return new Promise(INTERNAL, false, reason);\n}\n\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(),\n            outerScope = PSD;\n\n        try {\n            if (outerScope !== psd) {\n                // **KEEP** outerScope.env = wrappers.snapshot(); // Snapshot outerScope's environment\n                PSD = psd;\n                // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.\n            }\n            return fn.apply(this, arguments);\n        } catch (e) {\n            errorCatcher && errorCatcher(e);\n        } finally {\n            if (outerScope !== psd) {\n                PSD = outerScope;\n                // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment\n            }\n            if (wasRootExec) endMicroTickScope();\n        }\n    };\n}\n\nfunction newScope(fn, a1, a2, a3) {\n    var parent = PSD,\n        psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    // **KEEP** psd.env = wrappers.wrap(psd);\n\n    // unhandleds and onunhandled should not be specifically set here.\n    // Leave them on parent prototype.\n    // unhandleds.push(err) will push to parent's prototype\n    // onunhandled() will call parents onunhandled (with this scope's this-pointer though!)\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2, a3);\n    if (psd.ref === 0) psd.finalize();\n    return rv;\n}\n\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        if (psd !== outerScope) {\n            // **KEEP** outerScope.env = wrappers.snapshot(); // snapshot outerScope's environment.\n            PSD = psd;\n            // **KEEP** wrappers.restore(psd.env); // Restore PSD's environment.\n        }\n        return fn(a1, a2, a3);\n    } finally {\n        if (psd !== outerScope) {\n            PSD = outerScope;\n            // **KEEP** wrappers.restore(outerScope.env); // Restore outerScope's environment.\n        }\n    }\n}\n\nvar UNHANDLEDREJECTION = \"unhandledrejection\";\n\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    } catch (e) {}\n    if (rv !== false) try {\n        var event,\n            eventData = { promise: promise, reason: err };\n        if (_global.document && document.createEvent) {\n            event = document.createEvent('Event');\n            event.initEvent(UNHANDLEDREJECTION, true, true);\n            extend(event, eventData);\n        } else if (_global.CustomEvent) {\n            event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n            extend(event, eventData);\n        }\n        if (event && _global.dispatchEvent) {\n            dispatchEvent(event);\n            if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                // No native support for PromiseRejectionEvent but user has set window.onunhandledrejection. Manually call it.\n                try {\n                    _global.onunhandledrejection(event);\n                } catch (_) {}\n        }\n        if (!event.defaultPrevented) {\n            // Backward compatibility: fire to events registered at Promise.on.error\n            Promise.on.error.fire(err, promise);\n        }\n    } catch (e) {}\n}\n\n/* **KEEP** \r\n\r\nexport function wrapPromise(PromiseClass) {\r\n    var proto = PromiseClass.prototype;\r\n    var origThen = proto.then;\r\n    \r\n    wrappers.add({\r\n        snapshot: () => proto.then,\r\n        restore: value => {proto.then = value;},\r\n        wrap: () => patchedThen\r\n    });\r\n\r\n    function patchedThen (onFulfilled, onRejected) {\r\n        var promise = this;\r\n        var onFulfilledProxy = wrap(function(value){\r\n            var rv = value;\r\n            if (onFulfilled) {\r\n                rv = onFulfilled(rv);\r\n                if (rv && typeof rv.then === 'function') rv.then(); // Intercept that promise as well.\r\n            }\r\n            --PSD.ref || PSD.finalize();\r\n            return rv;\r\n        });\r\n        var onRejectedProxy = wrap(function(err){\r\n            promise._$err = err;\r\n            var unhandleds = PSD.unhandleds;\r\n            var idx = unhandleds.length,\r\n                rv;\r\n            while (idx--) if (unhandleds[idx]._$err === err) break;\r\n            if (onRejected) {\r\n                if (idx !== -1) unhandleds.splice(idx, 1); // Mark as handled.\r\n                rv = onRejected(err);\r\n                if (rv && typeof rv.then === 'function') rv.then(); // Intercept that promise as well.\r\n            } else {\r\n                if (idx === -1) unhandleds.push(promise);\r\n                rv = PromiseClass.reject(err);\r\n                rv._$nointercept = true; // Prohibit eternal loop.\r\n            }\r\n            --PSD.ref || PSD.finalize();\r\n            return rv;\r\n        });\r\n        \r\n        if (this._$nointercept) return origThen.apply(this, arguments);\r\n        ++PSD.ref;\r\n        return origThen.call(this, onFulfilledProxy, onRejectedProxy);\r\n    }\r\n}\r\n\r\n// Global Promise wrapper\r\nif (_global.Promise) wrapPromise(_global.Promise);\r\n\r\n*/\n\ndoFakeAutoComplete(function () {\n    // Simplify the job for VS Intellisense. This piece of code is one of the keys to the new marvellous intellisense support in Dexie.\n    asap$1 = function (fn, args) {\n        setTimeout(function () {\n            fn.apply(null, args);\n        }, 0);\n    };\n});\n\nfunction rejection(err, uncaughtHandler) {\n    // Get the call stack and return a rejected promise.\n    var rv = Promise.reject(err);\n    return uncaughtHandler ? rv.uncaught(uncaughtHandler) : rv;\n}\n\n/*\r\n * Dexie.js - a minimalistic wrapper for IndexedDB\r\n * ===============================================\r\n *\r\n * By David Fahlander, david.fahlander@gmail.com\r\n *\r\n * Version 1.5.1, Tue Nov 01 2016\r\n *\r\n * http://dexie.org\r\n *\r\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\r\n */\n\nvar DEXIE_VERSION = '1.5.1';\nvar maxString = String.fromCharCode(65535);\nvar maxKey = function () {\n    try {\n        IDBKeyRange.only([[]]);return [[]];\n    } catch (e) {\n        return maxString;\n    }\n}();\nvar INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nvar STRING_EXPECTED = \"String expected.\";\nvar connections = [];\nvar isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\nvar dexieStackFrameFilter = function (frame) {\n    return !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\n};\n\nsetDebug(debug, dexieStackFrameFilter);\n\nfunction Dexie(dbName, options) {\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">Specify only if you wich to control which addons that should run on this instance</param>\n    var deps = Dexie.dependencies;\n    var opts = extend({\n        // Default Options\n        addons: Dexie.addons, // Pick statically registered addons by default\n        autoOpen: true, // Don't require db.open() explicitely.\n        indexedDB: deps.indexedDB, // Backend IndexedDB api. Default to IDBShim or browser env.\n        IDBKeyRange: deps.IDBKeyRange // Backend IDBKeyRange api. Default to IDBShim or browser env.\n    }, options);\n    var addons = opts.addons,\n        autoOpen = opts.autoOpen,\n        indexedDB = opts.indexedDB,\n        IDBKeyRange = opts.IDBKeyRange;\n\n    var globalSchema = this._dbSchema = {};\n    var versions = [];\n    var dbStoreNames = [];\n    var allTables = {};\n    ///<var type=\"IDBDatabase\" />\n    var idbdb = null; // Instance of IDBDatabase\n    var dbOpenError = null;\n    var isBeingOpened = false;\n    var openComplete = false;\n    var READONLY = \"readonly\",\n        READWRITE = \"readwrite\";\n    var db = this;\n    var dbReadyResolve,\n        dbReadyPromise = new Promise(function (resolve) {\n        dbReadyResolve = resolve;\n    }),\n        cancelOpen,\n        openCanceller = new Promise(function (_, reject) {\n        cancelOpen = reject;\n    });\n    var autoSchema = true;\n    var hasNativeGetDatabaseNames = !!getNativeGetDatabaseNamesFn(indexedDB),\n        hasGetAll;\n\n    function init() {\n        // Default subscribers to \"versionchange\" and \"blocked\".\n        // Can be overridden by custom handlers. If custom handlers return false, these default\n        // behaviours will be prevented.\n        db.on(\"versionchange\", function (ev) {\n            // Default behavior for versionchange event is to close database connection.\n            // Caller can override this behavior by doing db.on(\"versionchange\", function(){ return false; });\n            // Let's not block the other window from making it's delete() or open() call.\n            // NOTE! This event is never fired in IE,Edge or Safari.\n            if (ev.newVersion > 0) console.warn('Another connection wants to upgrade database \\'' + db.name + '\\'. Closing db now to resume the upgrade.');else console.warn('Another connection wants to delete database \\'' + db.name + '\\'. Closing db now to resume the delete request.');\n            db.close();\n            // In many web applications, it would be recommended to force window.reload()\n            // when this event occurs. To do that, subscribe to the versionchange event\n            // and call window.location.reload(true) if ev.newVersion > 0 (not a deletion)\n            // The reason for this is that your current web app obviously has old schema code that needs\n            // to be updated. Another window got a newer version of the app and needs to upgrade DB but\n            // your window is blocking it unless we close it here.\n        });\n        db.on(\"blocked\", function (ev) {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion) console.warn('Dexie.delete(\\'' + db.name + '\\') was blocked');else console.warn('Upgrade \\'' + db.name + '\\' blocked by other connection holding version ' + ev.oldVersion / 10);\n        });\n    }\n\n    //\n    //\n    //\n    // ------------------------- Versioning Framework---------------------------\n    //\n    //\n    //\n\n    this.version = function (versionNumber) {\n        /// <param name=\"versionNumber\" type=\"Number\"></param>\n        /// <returns type=\"Version\"></returns>\n        if (idbdb || isBeingOpened) throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        var versionInstance = versions.filter(function (v) {\n            return v._cfg.version === versionNumber;\n        })[0];\n        if (versionInstance) return versionInstance;\n        versionInstance = new Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        return versionInstance;\n    };\n\n    function Version(versionNumber) {\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n        this.stores({}); // Derive earlier schemas by default.\n    }\n\n    extend(Version.prototype, {\n        stores: function (stores) {\n            /// <summary>\n            ///   Defines the schema for a particular version\n            /// </summary>\n            /// <param name=\"stores\" type=\"Object\">\n            /// Example: <br/>\n            ///   {users: \"id++,first,last,&amp;username,*email\", <br/>\n            ///   passwords: \"id++,&amp;username\"}<br/>\n            /// <br/>\n            /// Syntax: {Table: \"[primaryKey][++],[&amp;][*]index1,[&amp;][*]index2,...\"}<br/><br/>\n            /// Special characters:<br/>\n            ///  \"&amp;\"  means unique key, <br/>\n            ///  \"*\"  means value is multiEntry, <br/>\n            ///  \"++\" means auto-increment and only applicable for primary key <br/>\n            /// </param>\n            this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;\n\n            // Derive stores from earlier versions if they are not explicitely specified as null or a new syntax.\n            var storesSpec = {};\n            versions.forEach(function (version) {\n                // 'versions' is always sorted by lowest version first.\n                extend(storesSpec, version._cfg.storesSource);\n            });\n\n            var dbschema = this._cfg.dbschema = {};\n            this._parseStoresSpec(storesSpec, dbschema);\n            // Update the latest schema to this version\n            // Update API\n            globalSchema = db._dbSchema = dbschema;\n            removeTablesApi([allTables, db, Transaction.prototype]);\n            setApiOnPlace([allTables, db, Transaction.prototype, this._cfg.tables], keys(dbschema), READWRITE, dbschema);\n            dbStoreNames = keys(dbschema);\n            return this;\n        },\n        upgrade: function (upgradeFunction) {\n            /// <param name=\"upgradeFunction\" optional=\"true\">Function that performs upgrading actions.</param>\n            var self = this;\n            fakeAutoComplete(function () {\n                upgradeFunction(db._createTransaction(READWRITE, keys(self._cfg.dbschema), self._cfg.dbschema)); // BUGBUG: No code completion for prev version's tables wont appear.\n            });\n            this._cfg.contentUpgrade = upgradeFunction;\n            return this;\n        },\n        _parseStoresSpec: function (stores, outSchema) {\n            keys(stores).forEach(function (tableName) {\n                if (stores[tableName] !== null) {\n                    var instanceTemplate = {};\n                    var indexes = parseIndexSyntax(stores[tableName]);\n                    var primKey = indexes.shift();\n                    if (primKey.multi) throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                    if (primKey.keyPath) setByKeyPath(instanceTemplate, primKey.keyPath, primKey.auto ? 0 : primKey.keyPath);\n                    indexes.forEach(function (idx) {\n                        if (idx.auto) throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                        if (!idx.keyPath) throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                        setByKeyPath(instanceTemplate, idx.keyPath, idx.compound ? idx.keyPath.map(function () {\n                            return \"\";\n                        }) : \"\");\n                    });\n                    outSchema[tableName] = new TableSchema(tableName, primKey, indexes, instanceTemplate);\n                }\n            });\n        }\n    });\n\n    function runUpgraders(oldVersion, idbtrans, reject) {\n        var trans = db._createTransaction(READWRITE, dbStoreNames, globalSchema);\n        trans.create(idbtrans);\n        trans._completion.catch(reject);\n        var rejectTransaction = trans._reject.bind(trans);\n        newScope(function () {\n            PSD.trans = trans;\n            if (oldVersion === 0) {\n                // Create tables:\n                keys(globalSchema).forEach(function (tableName) {\n                    createTable(idbtrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n                });\n                Promise.follow(function () {\n                    return db.on.populate.fire(trans);\n                }).catch(rejectTransaction);\n            } else updateTablesAndIndexes(oldVersion, trans, idbtrans).catch(rejectTransaction);\n        });\n    }\n\n    function updateTablesAndIndexes(oldVersion, trans, idbtrans) {\n        // Upgrade version to version, step-by-step from oldest to newest version.\n        // Each transaction object will contain the table set that was current in that version (but also not-yet-deleted tables from its previous version)\n        var queue = [];\n        var oldVersionStruct = versions.filter(function (version) {\n            return version._cfg.version === oldVersion;\n        })[0];\n        if (!oldVersionStruct) throw new exceptions.Upgrade(\"Dexie specification of currently installed DB version is missing\");\n        globalSchema = db._dbSchema = oldVersionStruct._cfg.dbschema;\n        var anyContentUpgraderHasRun = false;\n\n        var versToRun = versions.filter(function (v) {\n            return v._cfg.version > oldVersion;\n        });\n        versToRun.forEach(function (version) {\n            /// <param name=\"version\" type=\"Version\"></param>\n            queue.push(function () {\n                var oldSchema = globalSchema;\n                var newSchema = version._cfg.dbschema;\n                adjustToExistingIndexNames(oldSchema, idbtrans);\n                adjustToExistingIndexNames(newSchema, idbtrans);\n                globalSchema = db._dbSchema = newSchema;\n                var diff = getSchemaDiff(oldSchema, newSchema);\n                // Add tables           \n                diff.add.forEach(function (tuple) {\n                    createTable(idbtrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n                });\n                // Change tables\n                diff.change.forEach(function (change) {\n                    if (change.recreate) {\n                        throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                    } else {\n                        var store = idbtrans.objectStore(change.name);\n                        // Add indexes\n                        change.add.forEach(function (idx) {\n                            addIndex(store, idx);\n                        });\n                        // Update indexes\n                        change.change.forEach(function (idx) {\n                            store.deleteIndex(idx.name);\n                            addIndex(store, idx);\n                        });\n                        // Delete indexes\n                        change.del.forEach(function (idxName) {\n                            store.deleteIndex(idxName);\n                        });\n                    }\n                });\n                if (version._cfg.contentUpgrade) {\n                    anyContentUpgraderHasRun = true;\n                    return Promise.follow(function () {\n                        version._cfg.contentUpgrade(trans);\n                    });\n                }\n            });\n            queue.push(function (idbtrans) {\n                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                    // Dont delete old tables if ieBug is present and a content upgrader has run. Let tables be left in DB so far. This needs to be taken care of.\n                    var newSchema = version._cfg.dbschema;\n                    // Delete old tables\n                    deleteRemovedTables(newSchema, idbtrans);\n                }\n            });\n        });\n\n        // Now, create a queue execution engine\n        function runQueue() {\n            return queue.length ? Promise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : Promise.resolve();\n        }\n\n        return runQueue().then(function () {\n            createMissingTables(globalSchema, idbtrans); // At last, make sure to create any missing tables. (Needed by addons that add stores to DB without specifying version)\n        });\n    }\n\n    function getSchemaDiff(oldSchema, newSchema) {\n        var diff = {\n            del: [], // Array of table names\n            add: [], // Array of [tableName, newDefinition]\n            change: [] // Array of {name: tableName, recreate: newDefinition, del: delIndexNames, add: newIndexDefs, change: changedIndexDefs}\n        };\n        for (var table in oldSchema) {\n            if (!newSchema[table]) diff.del.push(table);\n        }\n        for (table in newSchema) {\n            var oldDef = oldSchema[table],\n                newDef = newSchema[table];\n            if (!oldDef) {\n                diff.add.push([table, newDef]);\n            } else {\n                var change = {\n                    name: table,\n                    def: newDef,\n                    recreate: false,\n                    del: [],\n                    add: [],\n                    change: []\n                };\n                if (oldDef.primKey.src !== newDef.primKey.src) {\n                    // Primary key has changed. Remove and re-add table.\n                    change.recreate = true;\n                    diff.change.push(change);\n                } else {\n                    // Same primary key. Just find out what differs:\n                    var oldIndexes = oldDef.idxByName;\n                    var newIndexes = newDef.idxByName;\n                    for (var idxName in oldIndexes) {\n                        if (!newIndexes[idxName]) change.del.push(idxName);\n                    }\n                    for (idxName in newIndexes) {\n                        var oldIdx = oldIndexes[idxName],\n                            newIdx = newIndexes[idxName];\n                        if (!oldIdx) change.add.push(newIdx);else if (oldIdx.src !== newIdx.src) change.change.push(newIdx);\n                    }\n                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                        diff.change.push(change);\n                    }\n                }\n            }\n        }\n        return diff;\n    }\n\n    function createTable(idbtrans, tableName, primKey, indexes) {\n        /// <param name=\"idbtrans\" type=\"IDBTransaction\"></param>\n        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });\n        indexes.forEach(function (idx) {\n            addIndex(store, idx);\n        });\n        return store;\n    }\n\n    function createMissingTables(newSchema, idbtrans) {\n        keys(newSchema).forEach(function (tableName) {\n            if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n            }\n        });\n    }\n\n    function deleteRemovedTables(newSchema, idbtrans) {\n        for (var i = 0; i < idbtrans.db.objectStoreNames.length; ++i) {\n            var storeName = idbtrans.db.objectStoreNames[i];\n            if (newSchema[storeName] == null) {\n                idbtrans.db.deleteObjectStore(storeName);\n            }\n        }\n    }\n\n    function addIndex(store, idx) {\n        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n    }\n\n    function dbUncaught(err) {\n        return db.on.error.fire(err);\n    }\n\n    //\n    //\n    //      Dexie Protected API\n    //\n    //\n\n    this._allTables = allTables;\n\n    this._tableFactory = function createTable(mode, tableSchema) {\n        /// <param name=\"tableSchema\" type=\"TableSchema\"></param>\n        if (mode === READONLY) return new Table(tableSchema.name, tableSchema, Collection);else return new WriteableTable(tableSchema.name, tableSchema);\n    };\n\n    this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) {\n        return new Transaction(mode, storeNames, dbschema, parentTransaction);\n    };\n\n    /* Generate a temporary transaction when db operations are done outside a transactino scope.\r\n    */\n    function tempTransaction(mode, storeNames, fn) {\n        // Last argument is \"writeLocked\". But this doesnt apply to oneshot direct db operations, so we ignore it.\n        if (!openComplete && !PSD.letThrough) {\n            if (!isBeingOpened) {\n                if (!autoOpen) return rejection(new exceptions.DatabaseClosed(), dbUncaught);\n                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n            }\n            return dbReadyPromise.then(function () {\n                return tempTransaction(mode, storeNames, fn);\n            });\n        } else {\n            var trans = db._createTransaction(mode, storeNames, globalSchema);\n            return trans._promise(mode, function (resolve, reject) {\n                newScope(function () {\n                    // OPTIMIZATION POSSIBLE? newScope() not needed because it's already done in _promise.\n                    PSD.trans = trans;\n                    fn(resolve, reject, trans);\n                });\n            }).then(function (result) {\n                // Instead of resolving value directly, wait with resolving it until transaction has completed.\n                // Otherwise the data would not be in the DB if requesting it in the then() operation.\n                // Specifically, to ensure that the following expression will work:\n                //\n                //   db.friends.put({name: \"Arne\"}).then(function () {\n                //       db.friends.where(\"name\").equals(\"Arne\").count(function(count) {\n                //           assert (count === 1);\n                //       });\n                //   });\n                //\n                return trans._completion.then(function () {\n                    return result;\n                });\n            }); /*.catch(err => { // Don't do this as of now. If would affect bulk- and modify methods in a way that could be more intuitive. But wait! Maybe change in next major.\r\n                 trans._reject(err);\r\n                 return rejection(err);\r\n                });*/\n        }\n    }\n\n    this._whenReady = function (fn) {\n        return new Promise(fake || openComplete || PSD.letThrough ? fn : function (resolve, reject) {\n            if (!isBeingOpened) {\n                if (!autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                db.open().catch(nop); // Open in background. If if fails, it will be catched by the final promise anyway.\n            }\n            dbReadyPromise.then(function () {\n                fn(resolve, reject);\n            });\n        }).uncaught(dbUncaught);\n    };\n\n    //\n    //\n    //\n    //\n    //      Dexie API\n    //\n    //\n    //\n\n    this.verno = 0;\n\n    this.open = function () {\n        if (isBeingOpened || idbdb) return dbReadyPromise.then(function () {\n            return dbOpenError ? rejection(dbOpenError, dbUncaught) : db;\n        });\n        debug && (openCanceller._stackHolder = getErrorWithStack()); // Let stacks point to when open() was called rather than where new Dexie() was called.\n        isBeingOpened = true;\n        dbOpenError = null;\n        openComplete = false;\n\n        // Function pointers to call when the core opening process completes.\n        var resolveDbReady = dbReadyResolve,\n\n        // upgradeTransaction to abort on failure.\n        upgradeTransaction = null;\n\n        return Promise.race([openCanceller, new Promise(function (resolve, reject) {\n            doFakeAutoComplete(function () {\n                return resolve();\n            });\n\n            // Make sure caller has specified at least one version\n            if (versions.length > 0) autoSchema = false;\n\n            // Multiply db.verno with 10 will be needed to workaround upgrading bug in IE:\n            // IE fails when deleting objectStore after reading from it.\n            // A future version of Dexie.js will stopover an intermediate version to workaround this.\n            // At that point, we want to be backward compatible. Could have been multiplied with 2, but by using 10, it is easier to map the number to the real version number.\n\n            // If no API, throw!\n            if (!indexedDB) throw new exceptions.MissingAPI(\"indexedDB API not found. If using IE10+, make sure to run your code on a server URL \" + \"(not locally). If using old Safari versions, make sure to include indexedDB polyfill.\");\n\n            var req = autoSchema ? indexedDB.open(dbName) : indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req) throw new exceptions.MissingAPI(\"IndexedDB API not available\"); // May happen in Safari private mode, see https://github.com/dfahlander/Dexie.js/issues/134\n            req.onerror = wrap(eventRejectHandler(reject));\n            req.onblocked = wrap(fireOnBlocked);\n            req.onupgradeneeded = wrap(function (e) {\n                upgradeTransaction = req.transaction;\n                if (autoSchema && !db._allowEmptyDB) {\n                    // Unless an addon has specified db._allowEmptyDB, lets make the call fail.\n                    // Caller did not specify a version or schema. Doing that is only acceptable for opening alread existing databases.\n                    // If onupgradeneeded is called it means database did not exist. Reject the open() promise and make sure that we\n                    // do not create a new database by accident here.\n                    req.onerror = preventDefault; // Prohibit onabort error from firing before we're done!\n                    upgradeTransaction.abort(); // Abort transaction (would hope that this would make DB disappear but it doesnt.)\n                    // Close database and delete it.\n                    req.result.close();\n                    var delreq = indexedDB.deleteDatabase(dbName); // The upgrade transaction is atomic, and javascript is single threaded - meaning that there is no risk that we delete someone elses database here!\n                    delreq.onsuccess = delreq.onerror = wrap(function () {\n                        reject(new exceptions.NoSuchDatabase('Database ' + dbName + ' doesnt exist'));\n                    });\n                } else {\n                    upgradeTransaction.onerror = wrap(eventRejectHandler(reject));\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion; // Safari 8 fix.\n                    runUpgraders(oldVer / 10, upgradeTransaction, reject, req);\n                }\n            }, reject);\n\n            req.onsuccess = wrap(function () {\n                // Core opening procedure complete. Now let's just record some stuff.\n                upgradeTransaction = null;\n                idbdb = req.result;\n                connections.push(db); // Used for emulating versionchange event on IE/Edge/Safari.\n\n                if (autoSchema) readGlobalSchema();else if (idbdb.objectStoreNames.length > 0) {\n                    try {\n                        adjustToExistingIndexNames(globalSchema, idbdb.transaction(safariMultiStoreFix(idbdb.objectStoreNames), READONLY));\n                    } catch (e) {\n                        // Safari may bail out if > 1 store names. However, this shouldnt be a showstopper. Issue #120.\n                    }\n                }\n\n                idbdb.onversionchange = wrap(function (ev) {\n                    db._vcFired = true; // detect implementations that not support versionchange (IE/Edge/Safari)\n                    db.on(\"versionchange\").fire(ev);\n                });\n\n                if (!hasNativeGetDatabaseNames) {\n                    // Update localStorage with list of database names\n                    globalDatabaseList(function (databaseNames) {\n                        if (databaseNames.indexOf(dbName) === -1) return databaseNames.push(dbName);\n                    });\n                }\n\n                resolve();\n            }, reject);\n        })]).then(function () {\n            // Before finally resolving the dbReadyPromise and this promise,\n            // call and await all on('ready') subscribers:\n            // Dexie.vip() makes subscribers able to use the database while being opened.\n            // This is a must since these subscribers take part of the opening procedure.\n            return Dexie.vip(db.on.ready.fire);\n        }).then(function () {\n            // Resolve the db.open() with the db instance.\n            isBeingOpened = false;\n            return db;\n        }).catch(function (err) {\n            try {\n                // Did we fail within onupgradeneeded? Make sure to abort the upgrade transaction so it doesnt commit.\n                upgradeTransaction && upgradeTransaction.abort();\n            } catch (e) {}\n            isBeingOpened = false; // Set before calling db.close() so that it doesnt reject openCanceller again (leads to unhandled rejection event).\n            db.close(); // Closes and resets idbdb, removes connections, resets dbReadyPromise and openCanceller so that a later db.open() is fresh.\n            // A call to db.close() may have made on-ready subscribers fail. Use dbOpenError if set, since err could be a follow-up error on that.\n            dbOpenError = err; // Record the error. It will be used to reject further promises of db operations.\n            return rejection(dbOpenError, dbUncaught); // dbUncaught will make sure any error that happened in any operation before will now bubble to db.on.error() thanks to the special handling in Promise.uncaught().\n        }).finally(function () {\n            openComplete = true;\n            resolveDbReady(); // dbReadyPromise is resolved no matter if open() rejects or resolved. It's just to wake up waiters.\n        });\n    };\n\n    this.close = function () {\n        var idx = connections.indexOf(db);\n        if (idx >= 0) connections.splice(idx, 1);\n        if (idbdb) {\n            try {\n                idbdb.close();\n            } catch (e) {}\n            idbdb = null;\n        }\n        autoOpen = false;\n        dbOpenError = new exceptions.DatabaseClosed();\n        if (isBeingOpened) cancelOpen(dbOpenError);\n        // Reset dbReadyPromise promise:\n        dbReadyPromise = new Promise(function (resolve) {\n            dbReadyResolve = resolve;\n        });\n        openCanceller = new Promise(function (_, reject) {\n            cancelOpen = reject;\n        });\n    };\n\n    this.delete = function () {\n        var hasArguments = arguments.length > 0;\n        return new Promise(function (resolve, reject) {\n            if (hasArguments) throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (isBeingOpened) {\n                dbReadyPromise.then(doDelete);\n            } else {\n                doDelete();\n            }\n            function doDelete() {\n                db.close();\n                var req = indexedDB.deleteDatabase(dbName);\n                req.onsuccess = wrap(function () {\n                    if (!hasNativeGetDatabaseNames) {\n                        globalDatabaseList(function (databaseNames) {\n                            var pos = databaseNames.indexOf(dbName);\n                            if (pos >= 0) return databaseNames.splice(pos, 1);\n                        });\n                    }\n                    resolve();\n                });\n                req.onerror = wrap(eventRejectHandler(reject));\n                req.onblocked = fireOnBlocked;\n            }\n        }).uncaught(dbUncaught);\n    };\n\n    this.backendDB = function () {\n        return idbdb;\n    };\n\n    this.isOpen = function () {\n        return idbdb !== null;\n    };\n    this.hasFailed = function () {\n        return dbOpenError !== null;\n    };\n    this.dynamicallyOpened = function () {\n        return autoSchema;\n    };\n\n    //\n    // Properties\n    //\n    this.name = dbName;\n\n    // db.tables - an array of all Table instances.\n    setProp(this, \"tables\", {\n        get: function () {\n            /// <returns type=\"Array\" elementType=\"WriteableTable\" />\n            return keys(allTables).map(function (name) {\n                return allTables[name];\n            });\n        }\n    });\n\n    //\n    // Events\n    //\n    this.on = Events(this, \"error\", \"populate\", \"blocked\", \"versionchange\", { ready: [promisableChain, nop] });\n    this.on.error.subscribe = deprecated(\"Dexie.on.error\", this.on.error.subscribe);\n    this.on.error.unsubscribe = deprecated(\"Dexie.on.error.unsubscribe\", this.on.error.unsubscribe);\n\n    this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n        return function (subscriber, bSticky) {\n            Dexie.vip(function () {\n                if (openComplete) {\n                    // Database already open. Call subscriber asap.\n                    if (!dbOpenError) Promise.resolve().then(subscriber);\n                    // bSticky: Also subscribe to future open sucesses (after close / reopen) \n                    if (bSticky) subscribe(subscriber);\n                } else {\n                    // Database not yet open. Subscribe to it.\n                    subscribe(subscriber);\n                    // If bSticky is falsy, make sure to unsubscribe subscriber when fired once.\n                    if (!bSticky) subscribe(function unsubscribe() {\n                        db.on.ready.unsubscribe(subscriber);\n                        db.on.ready.unsubscribe(unsubscribe);\n                    });\n                }\n            });\n        };\n    });\n\n    fakeAutoComplete(function () {\n        db.on(\"populate\").fire(db._createTransaction(READWRITE, dbStoreNames, globalSchema));\n        db.on(\"error\").fire(new Error());\n    });\n\n    this.transaction = function (mode, tableInstances, scopeFunc) {\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"mode\" type=\"String\">\"r\" for readonly, or \"rw\" for readwrite</param>\n        /// <param name=\"tableInstances\">Table instance, Array of Table instances, String or String Array of object stores to include in the transaction</param>\n        /// <param name=\"scopeFunc\" type=\"Function\">Function to execute with transaction</param>\n\n        // Let table arguments be all arguments between mode and last argument.\n        var i = arguments.length;\n        if (i < 2) throw new exceptions.InvalidArgument(\"Too few arguments\");\n        // Prevent optimzation killer (https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments)\n        // and clone arguments except the first one into local var 'args'.\n        var args = new Array(i - 1);\n        while (--i) {\n            args[i - 1] = arguments[i];\n        } // Let scopeFunc be the last argument and pop it so that args now only contain the table arguments.\n        scopeFunc = args.pop();\n        var tables = flatten(args); // Support using array as middle argument, or a mix of arrays and non-arrays.\n        var parentTransaction = PSD.trans;\n        // Check if parent transactions is bound to this db instance, and if caller wants to reuse it\n        if (!parentTransaction || parentTransaction.db !== db || mode.indexOf('!') !== -1) parentTransaction = null;\n        var onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', ''); // Ok. Will change arguments[0] as well but we wont touch arguments henceforth.\n\n        try {\n            //\n            // Get storeNames from arguments. Either through given table instances, or through given table names.\n            //\n            var storeNames = tables.map(function (table) {\n                var storeName = table instanceof Table ? table.name : table;\n                if (typeof storeName !== 'string') throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n\n            //\n            // Resolve mode. Allow shortcuts \"r\" and \"rw\".\n            //\n            if (mode == \"r\" || mode == READONLY) mode = READONLY;else if (mode == \"rw\" || mode == READWRITE) mode = READWRITE;else throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n\n            if (parentTransaction) {\n                // Basic checks\n                if (parentTransaction.mode === READONLY && mode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        // Spawn new transaction instead.\n                        parentTransaction = null;\n                    } else throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(function (storeName) {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                // Spawn new transaction instead.\n                                parentTransaction = null;\n                            } else throw new exceptions.SubTransaction(\"Table \" + storeName + \" not included in parent transaction.\");\n                        }\n                    });\n                }\n            }\n        } catch (e) {\n            return parentTransaction ? parentTransaction._promise(null, function (_, reject) {\n                reject(e);\n            }) : rejection(e, dbUncaught);\n        }\n        // If this is a sub-transaction, lock the parent and then launch the sub-transaction.\n        return parentTransaction ? parentTransaction._promise(mode, enterTransactionScope, \"lock\") : db._whenReady(enterTransactionScope);\n\n        function enterTransactionScope(resolve) {\n            var parentPSD = PSD;\n            resolve(Promise.resolve().then(function () {\n                return newScope(function () {\n                    // Keep a pointer to last non-transactional PSD to use if someone calls Dexie.ignoreTransaction().\n                    PSD.transless = PSD.transless || parentPSD;\n                    // Our transaction.\n                    //return new Promise((resolve, reject) => {\n                    var trans = db._createTransaction(mode, storeNames, globalSchema, parentTransaction);\n                    // Let the transaction instance be part of a Promise-specific data (PSD) value.\n                    PSD.trans = trans;\n\n                    if (parentTransaction) {\n                        // Emulate transaction commit awareness for inner transaction (must 'commit' when the inner transaction has no more operations ongoing)\n                        trans.idbtrans = parentTransaction.idbtrans;\n                    } else {\n                        trans.create(); // Create the backend transaction so that complete() or error() will trigger even if no operation is made upon it.\n                    }\n\n                    // Provide arguments to the scope function (for backward compatibility)\n                    var tableArgs = storeNames.map(function (name) {\n                        return allTables[name];\n                    });\n                    tableArgs.push(trans);\n\n                    var returnValue;\n                    return Promise.follow(function () {\n                        // Finally, call the scope function with our table and transaction arguments.\n                        returnValue = scopeFunc.apply(trans, tableArgs); // NOTE: returnValue is used in trans.on.complete() not as a returnValue to this func.\n                        if (returnValue) {\n                            if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                                // scopeFunc returned an iterator with throw-support. Handle yield as await.\n                                returnValue = awaitIterator(returnValue);\n                            } else if (typeof returnValue.then === 'function' && !hasOwn(returnValue, '_PSD')) {\n                                throw new exceptions.IncompatiblePromise(\"Incompatible Promise returned from transaction scope (read more at http://tinyurl.com/znyqjqc). Transaction scope: \" + scopeFunc.toString());\n                            }\n                        }\n                    }).uncaught(dbUncaught).then(function () {\n                        if (parentTransaction) trans._resolve(); // sub transactions don't react to idbtrans.oncomplete. We must trigger a acompletion.\n                        return trans._completion; // Even if WE believe everything is fine. Await IDBTransaction's oncomplete or onerror as well.\n                    }).then(function () {\n                        return returnValue;\n                    }).catch(function (e) {\n                        //reject(e);\n                        trans._reject(e); // Yes, above then-handler were maybe not called because of an unhandled rejection in scopeFunc!\n                        return rejection(e);\n                    });\n                    //});\n                });\n            }));\n        }\n    };\n\n    this.table = function (tableName) {\n        /// <returns type=\"WriteableTable\"></returns>\n        if (fake && autoSchema) return new WriteableTable(tableName);\n        if (!hasOwn(allTables, tableName)) {\n            throw new exceptions.InvalidTable('Table ' + tableName + ' does not exist');\n        }\n        return allTables[tableName];\n    };\n\n    //\n    //\n    //\n    // Table Class\n    //\n    //\n    //\n    function Table(name, tableSchema, collClass) {\n        /// <param name=\"name\" type=\"String\"></param>\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = allTables[name] ? allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n        this._collClass = collClass || Collection;\n    }\n\n    props(Table.prototype, {\n\n        //\n        // Table Protected Methods\n        //\n\n        _trans: function getTransaction(mode, fn, writeLocked) {\n            var trans = PSD.trans;\n            return trans && trans.db === db ? trans._promise(mode, fn, writeLocked) : tempTransaction(mode, [this.name], fn);\n        },\n        _idbstore: function getIDBObjectStore(mode, fn, writeLocked) {\n            if (fake) return new Promise(fn); // Simplify the work for Intellisense/Code completion.\n            var trans = PSD.trans,\n                tableName = this.name;\n            function supplyIdbStore(resolve, reject, trans) {\n                fn(resolve, reject, trans.idbtrans.objectStore(tableName), trans);\n            }\n            return trans && trans.db === db ? trans._promise(mode, supplyIdbStore, writeLocked) : tempTransaction(mode, [this.name], supplyIdbStore);\n        },\n\n        //\n        // Table Public Methods\n        //\n        get: function (key, cb) {\n            var self = this;\n            return this._idbstore(READONLY, function (resolve, reject, idbstore) {\n                fake && resolve(self.schema.instanceTemplate);\n                var req = idbstore.get(key);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(function () {\n                    resolve(self.hook.reading.fire(req.result));\n                }, reject);\n            }).then(cb);\n        },\n        where: function (indexName) {\n            return new WhereClause(this, indexName);\n        },\n        count: function (cb) {\n            return this.toCollection().count(cb);\n        },\n        offset: function (offset) {\n            return this.toCollection().offset(offset);\n        },\n        limit: function (numRows) {\n            return this.toCollection().limit(numRows);\n        },\n        reverse: function () {\n            return this.toCollection().reverse();\n        },\n        filter: function (filterFunction) {\n            return this.toCollection().and(filterFunction);\n        },\n        each: function (fn) {\n            return this.toCollection().each(fn);\n        },\n        toArray: function (cb) {\n            return this.toCollection().toArray(cb);\n        },\n        orderBy: function (index) {\n            return new this._collClass(new WhereClause(this, index));\n        },\n\n        toCollection: function () {\n            return new this._collClass(new WhereClause(this));\n        },\n\n        mapToClass: function (constructor, structure) {\n            /// <summary>\n            ///     Map table to a javascript constructor function. Objects returned from the database will be instances of this class, making\n            ///     it possible to the instanceOf operator as well as extending the class using constructor.prototype.method = function(){...}.\n            /// </summary>\n            /// <param name=\"constructor\">Constructor function representing the class.</param>\n            /// <param name=\"structure\" optional=\"true\">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also\n            /// know what type each member has. Example: {name: String, emailAddresses: [String], password}</param>\n            this.schema.mappedClass = constructor;\n            var instanceTemplate = Object.create(constructor.prototype);\n            if (structure) {\n                // structure and instanceTemplate is for IDE code competion only while constructor.prototype is for actual inheritance.\n                applyStructure(instanceTemplate, structure);\n            }\n            this.schema.instanceTemplate = instanceTemplate;\n\n            // Now, subscribe to the when(\"reading\") event to make all objects that come out from this table inherit from given class\n            // no matter which method to use for reading (Table.get() or Table.where(...)... )\n            var readHook = function (obj) {\n                if (!obj) return obj; // No valid object. (Value is null). Return as is.\n                // Create a new object that derives from constructor:\n                var res = Object.create(constructor.prototype);\n                // Clone members:\n                for (var m in obj) {\n                    if (hasOwn(obj, m)) try {\n                        res[m] = obj[m];\n                    } catch (_) {}\n                }return res;\n            };\n\n            if (this.schema.readHook) {\n                this.hook.reading.unsubscribe(this.schema.readHook);\n            }\n            this.schema.readHook = readHook;\n            this.hook(\"reading\", readHook);\n            return constructor;\n        },\n        defineClass: function (structure) {\n            /// <summary>\n            ///     Define all members of the class that represents the table. This will help code completion of when objects are read from the database\n            ///     as well as making it possible to extend the prototype of the returned constructor function.\n            /// </summary>\n            /// <param name=\"structure\">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also\n            /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>\n            return this.mapToClass(Dexie.defineClass(structure), structure);\n        }\n    });\n\n    //\n    //\n    //\n    // WriteableTable Class (extends Table)\n    //\n    //\n    //\n    function WriteableTable(name, tableSchema, collClass) {\n        Table.call(this, name, tableSchema, collClass || WriteableCollection);\n    }\n\n    function BulkErrorHandlerCatchAll(errorList, done, supportHooks) {\n        return (supportHooks ? hookedEventRejectHandler : eventRejectHandler)(function (e) {\n            errorList.push(e);\n            done && done();\n        });\n    }\n\n    function bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook) {\n        // If hasDeleteHook, keysOrTuples must be an array of tuples: [[key1, value2],[key2,value2],...],\n        // else keysOrTuples must be just an array of keys: [key1, key2, ...].\n        return new Promise(function (resolve, reject) {\n            var len = keysOrTuples.length,\n                lastItem = len - 1;\n            if (len === 0) return resolve();\n            if (!hasDeleteHook) {\n                for (var i = 0; i < len; ++i) {\n                    var req = idbstore.delete(keysOrTuples[i]);\n                    req.onerror = wrap(eventRejectHandler(reject));\n                    if (i === lastItem) req.onsuccess = wrap(function () {\n                        return resolve();\n                    });\n                }\n            } else {\n                var hookCtx,\n                    errorHandler = hookedEventRejectHandler(reject),\n                    successHandler = hookedEventSuccessHandler(null);\n                tryCatch(function () {\n                    for (var i = 0; i < len; ++i) {\n                        hookCtx = { onsuccess: null, onerror: null };\n                        var tuple = keysOrTuples[i];\n                        deletingHook.call(hookCtx, tuple[0], tuple[1], trans);\n                        var req = idbstore.delete(tuple[0]);\n                        req._hookCtx = hookCtx;\n                        req.onerror = errorHandler;\n                        if (i === lastItem) req.onsuccess = hookedEventSuccessHandler(resolve);else req.onsuccess = successHandler;\n                    }\n                }, function (err) {\n                    hookCtx.onerror && hookCtx.onerror(err);\n                    throw err;\n                });\n            }\n        }).uncaught(dbUncaught);\n    }\n\n    derive(WriteableTable).from(Table).extend({\n        bulkDelete: function (keys$$1) {\n            if (this.hook.deleting.fire === nop) {\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                    resolve(bulkDelete(idbstore, trans, keys$$1, false, nop));\n                });\n            } else {\n                return this.where(':id').anyOf(keys$$1).delete().then(function () {}); // Resolve with undefined.\n            }\n        },\n        bulkPut: function (objects, keys$$1) {\n            var _this = this;\n\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                if (!idbstore.keyPath && !_this.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument(\"bulkPut() with non-inbound keys requires keys array in second argument\");\n                if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n                if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                if (objects.length === 0) return resolve(); // Caller provided empty list.\n                var done = function (result) {\n                    if (errorList.length === 0) resolve(result);else reject(new BulkError(_this.name + '.bulkPut(): ' + errorList.length + ' of ' + numObjs + ' operations failed', errorList));\n                };\n                var req,\n                    errorList = [],\n                    errorHandler,\n                    numObjs = objects.length,\n                    table = _this;\n                if (_this.hook.creating.fire === nop && _this.hook.updating.fire === nop) {\n                    //\n                    // Standard Bulk (no 'creating' or 'updating' hooks to care about)\n                    //\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\n                    for (var i = 0, l = objects.length; i < l; ++i) {\n                        req = keys$$1 ? idbstore.put(objects[i], keys$$1[i]) : idbstore.put(objects[i]);\n                        req.onerror = errorHandler;\n                    }\n                    // Only need to catch success or error on the last operation\n                    // according to the IDB spec.\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\n                    req.onsuccess = eventSuccessHandler(done);\n                } else {\n                    var effectiveKeys = keys$$1 || idbstore.keyPath && objects.map(function (o) {\n                        return getByKeyPath(o, idbstore.keyPath);\n                    });\n                    // Generate map of {[key]: object}\n                    var objectLookup = effectiveKeys && arrayToObject(effectiveKeys, function (key, i) {\n                        return key != null && [key, objects[i]];\n                    });\n                    var promise = !effectiveKeys ?\n\n                    // Auto-incremented key-less objects only without any keys argument.\n                    table.bulkAdd(objects) :\n\n                    // Keys provided. Either as inbound in provided objects, or as a keys argument.\n                    // Begin with updating those that exists in DB:\n                    table.where(':id').anyOf(effectiveKeys.filter(function (key) {\n                        return key != null;\n                    })).modify(function () {\n                        this.value = objectLookup[this.primKey];\n                        objectLookup[this.primKey] = null; // Mark as \"don't add this\"\n                    }).catch(ModifyError, function (e) {\n                        errorList = e.failures; // No need to concat here. These are the first errors added.\n                    }).then(function () {\n                        // Now, let's examine which items didnt exist so we can add them:\n                        var objsToAdd = [],\n                            keysToAdd = keys$$1 && [];\n                        // Iterate backwards. Why? Because if same key was used twice, just add the last one.\n                        for (var i = effectiveKeys.length - 1; i >= 0; --i) {\n                            var key = effectiveKeys[i];\n                            if (key == null || objectLookup[key]) {\n                                objsToAdd.push(objects[i]);\n                                keys$$1 && keysToAdd.push(key);\n                                if (key != null) objectLookup[key] = null; // Mark as \"dont add again\"\n                            }\n                        }\n                        // The items are in reverse order so reverse them before adding.\n                        // Could be important in order to get auto-incremented keys the way the caller\n                        // would expect. Could have used unshift instead of push()/reverse(),\n                        // but: http://jsperf.com/unshift-vs-reverse\n                        objsToAdd.reverse();\n                        keys$$1 && keysToAdd.reverse();\n                        return table.bulkAdd(objsToAdd, keysToAdd);\n                    }).then(function (lastAddedKey) {\n                        // Resolve with key of the last object in given arguments to bulkPut():\n                        var lastEffectiveKey = effectiveKeys[effectiveKeys.length - 1]; // Key was provided.\n                        return lastEffectiveKey != null ? lastEffectiveKey : lastAddedKey;\n                    });\n\n                    promise.then(done).catch(BulkError, function (e) {\n                        // Concat failure from ModifyError and reject using our 'done' method.\n                        errorList = errorList.concat(e.failures);\n                        done();\n                    }).catch(reject);\n                }\n            }, \"locked\"); // If called from transaction scope, lock transaction til all steps are done.\n        },\n        bulkAdd: function (objects, keys$$1) {\n            var self = this,\n                creatingHook = this.hook.creating.fire;\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                if (!idbstore.keyPath && !self.schema.primKey.auto && !keys$$1) throw new exceptions.InvalidArgument(\"bulkAdd() with non-inbound keys requires keys array in second argument\");\n                if (idbstore.keyPath && keys$$1) throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n                if (keys$$1 && keys$$1.length !== objects.length) throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n                if (objects.length === 0) return resolve(); // Caller provided empty list.\n                function done(result) {\n                    if (errorList.length === 0) resolve(result);else reject(new BulkError(self.name + '.bulkAdd(): ' + errorList.length + ' of ' + numObjs + ' operations failed', errorList));\n                }\n                var req,\n                    errorList = [],\n                    errorHandler,\n                    successHandler,\n                    numObjs = objects.length;\n                if (creatingHook !== nop) {\n                    //\n                    // There are subscribers to hook('creating')\n                    // Must behave as documented.\n                    //\n                    var keyPath = idbstore.keyPath,\n                        hookCtx;\n                    errorHandler = BulkErrorHandlerCatchAll(errorList, null, true);\n                    successHandler = hookedEventSuccessHandler(null);\n\n                    tryCatch(function () {\n                        for (var i = 0, l = objects.length; i < l; ++i) {\n                            hookCtx = { onerror: null, onsuccess: null };\n                            var key = keys$$1 && keys$$1[i];\n                            var obj = objects[i],\n                                effectiveKey = keys$$1 ? key : keyPath ? getByKeyPath(obj, keyPath) : undefined,\n                                keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans);\n                            if (effectiveKey == null && keyToUse != null) {\n                                if (keyPath) {\n                                    obj = deepClone(obj);\n                                    setByKeyPath(obj, keyPath, keyToUse);\n                                } else {\n                                    key = keyToUse;\n                                }\n                            }\n                            req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\n                            req._hookCtx = hookCtx;\n                            if (i < l - 1) {\n                                req.onerror = errorHandler;\n                                if (hookCtx.onsuccess) req.onsuccess = successHandler;\n                            }\n                        }\n                    }, function (err) {\n                        hookCtx.onerror && hookCtx.onerror(err);\n                        throw err;\n                    });\n\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done, true);\n                    req.onsuccess = hookedEventSuccessHandler(done);\n                } else {\n                    //\n                    // Standard Bulk (no 'creating' hook to care about)\n                    //\n                    errorHandler = BulkErrorHandlerCatchAll(errorList);\n                    for (var i = 0, l = objects.length; i < l; ++i) {\n                        req = keys$$1 ? idbstore.add(objects[i], keys$$1[i]) : idbstore.add(objects[i]);\n                        req.onerror = errorHandler;\n                    }\n                    // Only need to catch success or error on the last operation\n                    // according to the IDB spec.\n                    req.onerror = BulkErrorHandlerCatchAll(errorList, done);\n                    req.onsuccess = eventSuccessHandler(done);\n                }\n            });\n        },\n        add: function (obj, key) {\n            /// <summary>\n            ///   Add an object to the database. In case an object with same primary key already exists, the object will not be added.\n            /// </summary>\n            /// <param name=\"obj\" type=\"Object\">A javascript object to insert</param>\n            /// <param name=\"key\" optional=\"true\">Primary key</param>\n            var creatingHook = this.hook.creating.fire;\n            return this._idbstore(READWRITE, function (resolve, reject, idbstore, trans) {\n                var hookCtx = { onsuccess: null, onerror: null };\n                if (creatingHook !== nop) {\n                    var effectiveKey = key != null ? key : idbstore.keyPath ? getByKeyPath(obj, idbstore.keyPath) : undefined;\n                    var keyToUse = creatingHook.call(hookCtx, effectiveKey, obj, trans); // Allow subscribers to when(\"creating\") to generate the key.\n                    if (effectiveKey == null && keyToUse != null) {\n                        // Using \"==\" and \"!=\" to check for either null or undefined!\n                        if (idbstore.keyPath) setByKeyPath(obj, idbstore.keyPath, keyToUse);else key = keyToUse;\n                    }\n                }\n                try {\n                    var req = key != null ? idbstore.add(obj, key) : idbstore.add(obj);\n                    req._hookCtx = hookCtx;\n                    req.onerror = hookedEventRejectHandler(reject);\n                    req.onsuccess = hookedEventSuccessHandler(function (result) {\n                        // TODO: Remove these two lines in next major release (2.0?)\n                        // It's no good practice to have side effects on provided parameters\n                        var keyPath = idbstore.keyPath;\n                        if (keyPath) setByKeyPath(obj, keyPath, result);\n                        resolve(result);\n                    });\n                } catch (e) {\n                    if (hookCtx.onerror) hookCtx.onerror(e);\n                    throw e;\n                }\n            });\n        },\n\n        put: function (obj, key) {\n            /// <summary>\n            ///   Add an object to the database but in case an object with same primary key alread exists, the existing one will get updated.\n            /// </summary>\n            /// <param name=\"obj\" type=\"Object\">A javascript object to insert or update</param>\n            /// <param name=\"key\" optional=\"true\">Primary key</param>\n            var self = this,\n                creatingHook = this.hook.creating.fire,\n                updatingHook = this.hook.updating.fire;\n            if (creatingHook !== nop || updatingHook !== nop) {\n                //\n                // People listens to when(\"creating\") or when(\"updating\") events!\n                // We must know whether the put operation results in an CREATE or UPDATE.\n                //\n                return this._trans(READWRITE, function (resolve, reject, trans) {\n                    // Since key is optional, make sure we get it from obj if not provided\n                    var effectiveKey = key !== undefined ? key : self.schema.primKey.keyPath && getByKeyPath(obj, self.schema.primKey.keyPath);\n                    if (effectiveKey == null) {\n                        // \"== null\" means checking for either null or undefined.\n                        // No primary key. Must use add().\n                        self.add(obj).then(resolve, reject);\n                    } else {\n                        // Primary key exist. Lock transaction and try modifying existing. If nothing modified, call add().\n                        trans._lock(); // Needed because operation is splitted into modify() and add().\n                        // clone obj before this async call. If caller modifies obj the line after put(), the IDB spec requires that it should not affect operation.\n                        obj = deepClone(obj);\n                        self.where(\":id\").equals(effectiveKey).modify(function () {\n                            // Replace extisting value with our object\n                            // CRUD event firing handled in WriteableCollection.modify()\n                            this.value = obj;\n                        }).then(function (count) {\n                            if (count === 0) {\n                                // Object's key was not found. Add the object instead.\n                                // CRUD event firing will be done in add()\n                                return self.add(obj, key); // Resolving with another Promise. Returned Promise will then resolve with the new key.\n                            } else {\n                                return effectiveKey; // Resolve with the provided key.\n                            }\n                        }).finally(function () {\n                            trans._unlock();\n                        }).then(resolve, reject);\n                    }\n                });\n            } else {\n                // Use the standard IDB put() method.\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = key !== undefined ? idbstore.put(obj, key) : idbstore.put(obj);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = function (ev) {\n                        var keyPath = idbstore.keyPath;\n                        if (keyPath) setByKeyPath(obj, keyPath, ev.target.result);\n                        resolve(req.result);\n                    };\n                });\n            }\n        },\n\n        'delete': function (key) {\n            /// <param name=\"key\">Primary key of the object to delete</param>\n            if (this.hook.deleting.subscribers.length) {\n                // People listens to when(\"deleting\") event. Must implement delete using WriteableCollection.delete() that will\n                // call the CRUD event. Only WriteableCollection.delete() will know whether an object was actually deleted.\n                return this.where(\":id\").equals(key).delete();\n            } else {\n                // No one listens. Use standard IDB delete() method.\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = idbstore.delete(key);\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n                });\n            }\n        },\n\n        clear: function () {\n            if (this.hook.deleting.subscribers.length) {\n                // People listens to when(\"deleting\") event. Must implement delete using WriteableCollection.delete() that will\n                // call the CRUD event. Only WriteableCollection.delete() will knows which objects that are actually deleted.\n                return this.toCollection().delete();\n            } else {\n                return this._idbstore(READWRITE, function (resolve, reject, idbstore) {\n                    var req = idbstore.clear();\n                    req.onerror = eventRejectHandler(reject);\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n                });\n            }\n        },\n\n        update: function (keyOrObject, modifications) {\n            if (typeof modifications !== 'object' || isArray(modifications)) throw new exceptions.InvalidArgument(\"Modifications must be an object.\");\n            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n                // object to modify. Also modify given object with the modifications:\n                keys(modifications).forEach(function (keyPath) {\n                    setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                });\n                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n                if (key === undefined) return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"), dbUncaught);\n                return this.where(\":id\").equals(key).modify(modifications);\n            } else {\n                // key to modify\n                return this.where(\":id\").equals(keyOrObject).modify(modifications);\n            }\n        }\n    });\n\n    //\n    //\n    //\n    // Transaction Class\n    //\n    //\n    //\n    function Transaction(mode, storeNames, dbschema, parent) {\n        var _this2 = this;\n\n        /// <summary>\n        ///    Transaction class. Represents a database transaction. All operations on db goes through a Transaction.\n        /// </summary>\n        /// <param name=\"mode\" type=\"String\">Any of \"readwrite\" or \"readonly\"</param>\n        /// <param name=\"storeNames\" type=\"Array\">Array of table names to operate on</param>\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._tables = null;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._psd = null;\n        this._dbschema = dbschema;\n        this._resolve = null;\n        this._reject = null;\n        this._completion = new Promise(function (resolve, reject) {\n            _this2._resolve = resolve;\n            _this2._reject = reject;\n        }).uncaught(dbUncaught);\n\n        this._completion.then(function () {\n            _this2.on.complete.fire();\n        }, function (e) {\n            _this2.on.error.fire(e);\n            _this2.parent ? _this2.parent._reject(e) : _this2.active && _this2.idbtrans && _this2.idbtrans.abort();\n            _this2.active = false;\n            return rejection(e); // Indicate we actually DO NOT catch this error.\n        });\n    }\n\n    props(Transaction.prototype, {\n        //\n        // Transaction Protected Methods (not required by API users, but needed internally and eventually by dexie extensions)\n        //\n        _lock: function () {\n            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n            // Temporary set all requests into a pending queue if they are called before database is ready.\n            ++this._reculock; // Recursive read/write lock pattern using PSD (Promise Specific Data) instead of TLS (Thread Local Storage)\n            if (this._reculock === 1 && !PSD.global) PSD.lockOwnerFor = this;\n            return this;\n        },\n        _unlock: function () {\n            assert(!PSD.global); // Locking and unlocking reuires to be within a PSD scope.\n            if (--this._reculock === 0) {\n                if (!PSD.global) PSD.lockOwnerFor = null;\n                while (this._blockedFuncs.length > 0 && !this._locked()) {\n                    var fnAndPSD = this._blockedFuncs.shift();\n                    try {\n                        usePSD(fnAndPSD[1], fnAndPSD[0]);\n                    } catch (e) {}\n                }\n            }\n            return this;\n        },\n        _locked: function () {\n            // Checks if any write-lock is applied on this transaction.\n            // To simplify the Dexie API for extension implementations, we support recursive locks.\n            // This is accomplished by using \"Promise Specific Data\" (PSD).\n            // PSD data is bound to a Promise and any child Promise emitted through then() or resolve( new Promise() ).\n            // PSD is local to code executing on top of the call stacks of any of any code executed by Promise():\n            //         * callback given to the Promise() constructor  (function (resolve, reject){...})\n            //         * callbacks given to then()/catch()/finally() methods (function (value){...})\n            // If creating a new independant Promise instance from within a Promise call stack, the new Promise will derive the PSD from the call stack of the parent Promise.\n            // Derivation is done so that the inner PSD __proto__ points to the outer PSD.\n            // PSD.lockOwnerFor will point to current transaction object if the currently executing PSD scope owns the lock.\n            return this._reculock && PSD.lockOwnerFor !== this;\n        },\n        create: function (idbtrans) {\n            var _this3 = this;\n\n            assert(!this.idbtrans);\n            if (!idbtrans && !idbdb) {\n                switch (dbOpenError && dbOpenError.name) {\n                    case \"DatabaseClosedError\":\n                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n                        throw new exceptions.DatabaseClosed(dbOpenError);\n                    case \"MissingAPIError\":\n                        // Errors where it is no difference whether it was caused by the user operation or an earlier call to db.open()\n                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                    default:\n                        // Make it clear that the user operation was not what caused the error - the error had occurred earlier on db.open()!\n                        throw new exceptions.OpenFailed(dbOpenError);\n                }\n            }\n            if (!this.active) throw new exceptions.TransactionInactive();\n            assert(this._completion._state === null);\n\n            idbtrans = this.idbtrans = idbtrans || idbdb.transaction(safariMultiStoreFix(this.storeNames), this.mode);\n            idbtrans.onerror = wrap(function (ev) {\n                preventDefault(ev); // Prohibit default bubbling to window.error\n                _this3._reject(idbtrans.error);\n            });\n            idbtrans.onabort = wrap(function (ev) {\n                preventDefault(ev);\n                _this3.active && _this3._reject(new exceptions.Abort());\n                _this3.active = false;\n                _this3.on(\"abort\").fire(ev);\n            });\n            idbtrans.oncomplete = wrap(function () {\n                _this3.active = false;\n                _this3._resolve();\n            });\n            return this;\n        },\n        _promise: function (mode, fn, bWriteLock) {\n            var self = this;\n            var p = self._locked() ?\n            // Read lock always. Transaction is write-locked. Wait for mutex.\n            new Promise(function (resolve, reject) {\n                self._blockedFuncs.push([function () {\n                    self._promise(mode, fn, bWriteLock).then(resolve, reject);\n                }, PSD]);\n            }) : newScope(function () {\n                var p_ = self.active ? new Promise(function (resolve, reject) {\n                    if (mode === READWRITE && self.mode !== READWRITE) throw new exceptions.ReadOnly(\"Transaction is readonly\");\n                    if (!self.idbtrans && mode) self.create();\n                    if (bWriteLock) self._lock(); // Write lock if write operation is requested\n                    fn(resolve, reject, self);\n                }) : rejection(new exceptions.TransactionInactive());\n                if (self.active && bWriteLock) p_.finally(function () {\n                    self._unlock();\n                });\n                return p_;\n            });\n\n            p._lib = true;\n            return p.uncaught(dbUncaught);\n        },\n\n        //\n        // Transaction Public Properties and Methods\n        //\n        abort: function () {\n            this.active && this._reject(new exceptions.Abort());\n            this.active = false;\n        },\n\n        tables: {\n            get: deprecated(\"Transaction.tables\", function () {\n                return arrayToObject(this.storeNames, function (name) {\n                    return [name, allTables[name]];\n                });\n            }, \"Use db.tables()\")\n        },\n\n        complete: deprecated(\"Transaction.complete()\", function (cb) {\n            return this.on(\"complete\", cb);\n        }),\n\n        error: deprecated(\"Transaction.error()\", function (cb) {\n            return this.on(\"error\", cb);\n        }),\n\n        table: deprecated(\"Transaction.table()\", function (name) {\n            if (this.storeNames.indexOf(name) === -1) throw new exceptions.InvalidTable(\"Table \" + name + \" not in transaction\");\n            return allTables[name];\n        })\n\n    });\n\n    //\n    //\n    //\n    // WhereClause\n    //\n    //\n    //\n    function WhereClause(table, index, orCollection) {\n        /// <param name=\"table\" type=\"Table\"></param>\n        /// <param name=\"index\" type=\"String\" optional=\"true\"></param>\n        /// <param name=\"orCollection\" type=\"Collection\" optional=\"true\"></param>\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            collClass: table._collClass,\n            or: orCollection\n        };\n    }\n\n    props(WhereClause.prototype, function () {\n\n        // WhereClause private methods\n\n        function fail(collectionOrWhereClause, err, T) {\n            var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause._ctx.collClass(collectionOrWhereClause) : collectionOrWhereClause;\n\n            collection._ctx.error = T ? new T(err) : new TypeError(err);\n            return collection;\n        }\n\n        function emptyCollection(whereClause) {\n            return new whereClause._ctx.collClass(whereClause, function () {\n                return IDBKeyRange.only(\"\");\n            }).limit(0);\n        }\n\n        function upperFactory(dir) {\n            return dir === \"next\" ? function (s) {\n                return s.toUpperCase();\n            } : function (s) {\n                return s.toLowerCase();\n            };\n        }\n        function lowerFactory(dir) {\n            return dir === \"next\" ? function (s) {\n                return s.toLowerCase();\n            } : function (s) {\n                return s.toUpperCase();\n            };\n        }\n        function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n            var length = Math.min(key.length, lowerNeedle.length);\n            var llp = -1;\n            for (var i = 0; i < length; ++i) {\n                var lwrKeyChar = lowerKey[i];\n                if (lwrKeyChar !== lowerNeedle[i]) {\n                    if (cmp(key[i], upperNeedle[i]) < 0) return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n                    if (cmp(key[i], lowerNeedle[i]) < 0) return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n                    if (llp >= 0) return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n                    return null;\n                }\n                if (cmp(key[i], lwrKeyChar) < 0) llp = i;\n            }\n            if (length < lowerNeedle.length && dir === \"next\") return key + upperNeedle.substr(key.length);\n            if (length < key.length && dir === \"prev\") return key.substr(0, upperNeedle.length);\n            return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);\n        }\n\n        function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n            /// <param name=\"needles\" type=\"Array\" elementType=\"String\"></param>\n            var upper,\n                lower,\n                compare,\n                upperNeedles,\n                lowerNeedles,\n                direction,\n                nextKeySuffix,\n                needlesLen = needles.length;\n            if (!needles.every(function (s) {\n                return typeof s === 'string';\n            })) {\n                return fail(whereClause, STRING_EXPECTED);\n            }\n            function initDirection(dir) {\n                upper = upperFactory(dir);\n                lower = lowerFactory(dir);\n                compare = dir === \"next\" ? simpleCompare : simpleCompareReverse;\n                var needleBounds = needles.map(function (needle) {\n                    return { lower: lower(needle), upper: upper(needle) };\n                }).sort(function (a, b) {\n                    return compare(a.lower, b.lower);\n                });\n                upperNeedles = needleBounds.map(function (nb) {\n                    return nb.upper;\n                });\n                lowerNeedles = needleBounds.map(function (nb) {\n                    return nb.lower;\n                });\n                direction = dir;\n                nextKeySuffix = dir === \"next\" ? \"\" : suffix;\n            }\n            initDirection(\"next\");\n\n            var c = new whereClause._ctx.collClass(whereClause, function () {\n                return IDBKeyRange.bound(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);\n            });\n\n            c._ondirectionchange = function (direction) {\n                // This event onlys occur before filter is called the first time.\n                initDirection(direction);\n            };\n\n            var firstPossibleNeedle = 0;\n\n            c._addAlgorithm(function (cursor, advance, resolve) {\n                /// <param name=\"cursor\" type=\"IDBCursor\"></param>\n                /// <param name=\"advance\" type=\"Function\"></param>\n                /// <param name=\"resolve\" type=\"Function\"></param>\n                var key = cursor.key;\n                if (typeof key !== 'string') return false;\n                var lowerKey = lower(key);\n                if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n                    return true;\n                } else {\n                    var lowestPossibleCasing = null;\n                    for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                        if (casing === null && lowestPossibleCasing === null) firstPossibleNeedle = i + 1;else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                            lowestPossibleCasing = casing;\n                        }\n                    }\n                    if (lowestPossibleCasing !== null) {\n                        advance(function () {\n                            cursor.continue(lowestPossibleCasing + nextKeySuffix);\n                        });\n                    } else {\n                        advance(resolve);\n                    }\n                    return false;\n                }\n            });\n            return c;\n        }\n\n        //\n        // WhereClause public methods\n        //\n        return {\n            between: function (lower, upper, includeLower, includeUpper) {\n                /// <summary>\n                ///     Filter out records whose where-field lays between given lower and upper values. Applies to Strings, Numbers and Dates.\n                /// </summary>\n                /// <param name=\"lower\"></param>\n                /// <param name=\"upper\"></param>\n                /// <param name=\"includeLower\" optional=\"true\">Whether items that equals lower should be included. Default true.</param>\n                /// <param name=\"includeUpper\" optional=\"true\">Whether items that equals upper should be included. Default false.</param>\n                /// <returns type=\"Collection\"></returns>\n                includeLower = includeLower !== false; // Default to true\n                includeUpper = includeUpper === true; // Default to false\n                try {\n                    if (cmp(lower, upper) > 0 || cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)) return emptyCollection(this); // Workaround for idiotic W3C Specification that DataError must be thrown if lower > upper. The natural result would be to return an empty collection.\n                    return new this._ctx.collClass(this, function () {\n                        return IDBKeyRange.bound(lower, upper, !includeLower, !includeUpper);\n                    });\n                } catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n            },\n            equals: function (value) {\n                return new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.only(value);\n                });\n            },\n            above: function (value) {\n                return new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.lowerBound(value, true);\n                });\n            },\n            aboveOrEqual: function (value) {\n                return new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.lowerBound(value);\n                });\n            },\n            below: function (value) {\n                return new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.upperBound(value, true);\n                });\n            },\n            belowOrEqual: function (value) {\n                return new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.upperBound(value);\n                });\n            },\n            startsWith: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                if (typeof str !== 'string') return fail(this, STRING_EXPECTED);\n                return this.between(str, str + maxString, true, true);\n            },\n            startsWithIgnoreCase: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                if (str === \"\") return this.startsWith(str);\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\n                    return x.indexOf(a[0]) === 0;\n                }, [str], maxString);\n            },\n            equalsIgnoreCase: function (str) {\n                /// <param name=\"str\" type=\"String\"></param>\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\n                    return x === a[0];\n                }, [str], \"\");\n            },\n            anyOfIgnoreCase: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0) return emptyCollection(this);\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\n                    return a.indexOf(x) !== -1;\n                }, set, \"\");\n            },\n            startsWithAnyOfIgnoreCase: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0) return emptyCollection(this);\n                return addIgnoreCaseAlgorithm(this, function (x, a) {\n                    return a.some(function (n) {\n                        return x.indexOf(n) === 0;\n                    });\n                }, set, maxString);\n            },\n            anyOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                var compare = ascending;\n                try {\n                    set.sort(compare);\n                } catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n                if (set.length === 0) return emptyCollection(this);\n                var c = new this._ctx.collClass(this, function () {\n                    return IDBKeyRange.bound(set[0], set[set.length - 1]);\n                });\n\n                c._ondirectionchange = function (direction) {\n                    compare = direction === \"next\" ? ascending : descending;\n                    set.sort(compare);\n                };\n                var i = 0;\n                c._addAlgorithm(function (cursor, advance, resolve) {\n                    var key = cursor.key;\n                    while (compare(key, set[i]) > 0) {\n                        // The cursor has passed beyond this key. Check next.\n                        ++i;\n                        if (i === set.length) {\n                            // There is no next. Stop searching.\n                            advance(resolve);\n                            return false;\n                        }\n                    }\n                    if (compare(key, set[i]) === 0) {\n                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n                        return true;\n                    } else {\n                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n                        advance(function () {\n                            cursor.continue(set[i]);\n                        });\n                        return false;\n                    }\n                });\n                return c;\n            },\n\n            notEqual: function (value) {\n                return this.inAnyRange([[-Infinity, value], [value, maxKey]], { includeLowers: false, includeUppers: false });\n            },\n\n            noneOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n                if (set.length === 0) return new this._ctx.collClass(this); // Return entire collection.\n                try {\n                    set.sort(ascending);\n                } catch (e) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n                // Transform [\"a\",\"b\",\"c\"] to a set of ranges for between/above/below: [[-Infinity,\"a\"], [\"a\",\"b\"], [\"b\",\"c\"], [\"c\",maxKey]]\n                var ranges = set.reduce(function (res, val) {\n                    return res ? res.concat([[res[res.length - 1][1], val]]) : [[-Infinity, val]];\n                }, null);\n                ranges.push([set[set.length - 1], maxKey]);\n                return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n            },\n\n            /** Filter out values withing given set of ranges.\r\n            * Example, give children and elders a rebate of 50%:\r\n            *\r\n            *   db.friends.where('age').inAnyRange([[0,18],[65,Infinity]]).modify({Rebate: 1/2});\r\n            *\r\n            * @param {(string|number|Date|Array)[][]} ranges\r\n            * @param {{includeLowers: boolean, includeUppers: boolean}} options\r\n            */\n            inAnyRange: function (ranges, options) {\n                var ctx = this._ctx;\n                if (ranges.length === 0) return emptyCollection(this);\n                if (!ranges.every(function (range) {\n                    return range[0] !== undefined && range[1] !== undefined && ascending(range[0], range[1]) <= 0;\n                })) {\n                    return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n                }\n                var includeLowers = !options || options.includeLowers !== false; // Default to true\n                var includeUppers = options && options.includeUppers === true; // Default to false\n\n                function addRange(ranges, newRange) {\n                    for (var i = 0, l = ranges.length; i < l; ++i) {\n                        var range = ranges[i];\n                        if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                            range[0] = min(range[0], newRange[0]);\n                            range[1] = max(range[1], newRange[1]);\n                            break;\n                        }\n                    }\n                    if (i === l) ranges.push(newRange);\n                    return ranges;\n                }\n\n                var sortDirection = ascending;\n                function rangeSorter(a, b) {\n                    return sortDirection(a[0], b[0]);\n                }\n\n                // Join overlapping ranges\n                var set;\n                try {\n                    set = ranges.reduce(addRange, []);\n                    set.sort(rangeSorter);\n                } catch (ex) {\n                    return fail(this, INVALID_KEY_ARGUMENT);\n                }\n\n                var i = 0;\n                var keyIsBeyondCurrentEntry = includeUppers ? function (key) {\n                    return ascending(key, set[i][1]) > 0;\n                } : function (key) {\n                    return ascending(key, set[i][1]) >= 0;\n                };\n\n                var keyIsBeforeCurrentEntry = includeLowers ? function (key) {\n                    return descending(key, set[i][0]) > 0;\n                } : function (key) {\n                    return descending(key, set[i][0]) >= 0;\n                };\n\n                function keyWithinCurrentRange(key) {\n                    return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n                }\n\n                var checkKey = keyIsBeyondCurrentEntry;\n\n                var c = new ctx.collClass(this, function () {\n                    return IDBKeyRange.bound(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers);\n                });\n\n                c._ondirectionchange = function (direction) {\n                    if (direction === \"next\") {\n                        checkKey = keyIsBeyondCurrentEntry;\n                        sortDirection = ascending;\n                    } else {\n                        checkKey = keyIsBeforeCurrentEntry;\n                        sortDirection = descending;\n                    }\n                    set.sort(rangeSorter);\n                };\n\n                c._addAlgorithm(function (cursor, advance, resolve) {\n                    var key = cursor.key;\n                    while (checkKey(key)) {\n                        // The cursor has passed beyond this key. Check next.\n                        ++i;\n                        if (i === set.length) {\n                            // There is no next. Stop searching.\n                            advance(resolve);\n                            return false;\n                        }\n                    }\n                    if (keyWithinCurrentRange(key)) {\n                        // The current cursor value should be included and we should continue a single step in case next item has the same key or possibly our next key in set.\n                        return true;\n                    } else if (cmp(key, set[i][1]) === 0 || cmp(key, set[i][0]) === 0) {\n                        // includeUpper or includeLower is false so keyWithinCurrentRange() returns false even though we are at range border.\n                        // Continue to next key but don't include this one.\n                        return false;\n                    } else {\n                        // cursor.key not yet at set[i]. Forward cursor to the next key to hunt for.\n                        advance(function () {\n                            if (sortDirection === ascending) cursor.continue(set[i][0]);else cursor.continue(set[i][1]);\n                        });\n                        return false;\n                    }\n                });\n                return c;\n            },\n            startsWithAnyOf: function () {\n                var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n\n                if (!set.every(function (s) {\n                    return typeof s === 'string';\n                })) {\n                    return fail(this, \"startsWithAnyOf() only works with strings\");\n                }\n                if (set.length === 0) return emptyCollection(this);\n\n                return this.inAnyRange(set.map(function (str) {\n                    return [str, str + maxString];\n                }));\n            }\n        };\n    });\n\n    //\n    //\n    //\n    // Collection Class\n    //\n    //\n    //\n    function Collection(whereClause, keyRangeGenerator) {\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"whereClause\" type=\"WhereClause\">Where clause instance</param>\n        /// <param name=\"keyRangeGenerator\" value=\"function(){ return IDBKeyRange.bound(0,1);}\" optional=\"true\"></param>\n        var keyRange = null,\n            error = null;\n        if (keyRangeGenerator) try {\n            keyRange = keyRangeGenerator();\n        } catch (ex) {\n            error = ex;\n        }\n\n        var whereCtx = whereClause._ctx,\n            table = whereCtx.table;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true, // True if a replayFilter is just a filter that performs a \"limit\" operation (or none at all)\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error, // If set, any promise must be rejected with this error\n            or: whereCtx.or,\n            valueMapper: table.hook.reading.fire\n        };\n    }\n\n    function isPlainKeyRange(ctx, ignoreLimitFilter) {\n        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n    }\n\n    props(Collection.prototype, function () {\n\n        //\n        // Collection Private Functions\n        //\n\n        function addFilter(ctx, fn) {\n            ctx.filter = combine(ctx.filter, fn);\n        }\n\n        function addReplayFilter(ctx, factory, isLimitFilter) {\n            var curr = ctx.replayFilter;\n            ctx.replayFilter = curr ? function () {\n                return combine(curr(), factory());\n            } : factory;\n            ctx.justLimit = isLimitFilter && !curr;\n        }\n\n        function addMatchFilter(ctx, fn) {\n            ctx.isMatch = combine(ctx.isMatch, fn);\n        }\n\n        /** @param ctx {\r\n         *      isPrimKey: boolean,\r\n         *      table: Table,\r\n         *      index: string\r\n         * }\r\n         * @param store IDBObjectStore\r\n         **/\n        function getIndexOrStore(ctx, store) {\n            if (ctx.isPrimKey) return store;\n            var indexSpec = ctx.table.schema.idxByName[ctx.index];\n            if (!indexSpec) throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + store.name + \" is not indexed\");\n            return store.index(indexSpec.name);\n        }\n\n        /** @param ctx {\r\n         *      isPrimKey: boolean,\r\n         *      table: Table,\r\n         *      index: string,\r\n         *      keysOnly: boolean,\r\n         *      range?: IDBKeyRange,\r\n         *      dir: \"next\" | \"prev\"\r\n         * }\r\n         */\n        function openCursor(ctx, store) {\n            var idxOrStore = getIndexOrStore(ctx, store);\n            return ctx.keysOnly && 'openKeyCursor' in idxOrStore ? idxOrStore.openKeyCursor(ctx.range || null, ctx.dir + ctx.unique) : idxOrStore.openCursor(ctx.range || null, ctx.dir + ctx.unique);\n        }\n\n        function iter(ctx, fn, resolve, reject, idbstore) {\n            var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n            if (!ctx.or) {\n                iterate(openCursor(ctx, idbstore), combine(ctx.algorithm, filter), fn, resolve, reject, !ctx.keysOnly && ctx.valueMapper);\n            } else (function () {\n                var set = {};\n                var resolved = 0;\n\n                function resolveboth() {\n                    if (++resolved === 2) resolve(); // Seems like we just support or btwn max 2 expressions, but there are no limit because we do recursion.\n                }\n\n                function union(item, cursor, advance) {\n                    if (!filter || filter(cursor, advance, resolveboth, reject)) {\n                        var key = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string\n                        if (!hasOwn(set, key)) {\n                            set[key] = true;\n                            fn(item, cursor, advance);\n                        }\n                    }\n                }\n\n                ctx.or._iterate(union, resolveboth, reject, idbstore);\n                iterate(openCursor(ctx, idbstore), ctx.algorithm, union, resolveboth, reject, !ctx.keysOnly && ctx.valueMapper);\n            })();\n        }\n        function getInstanceTemplate(ctx) {\n            return ctx.table.schema.instanceTemplate;\n        }\n\n        return {\n\n            //\n            // Collection Protected Functions\n            //\n\n            _read: function (fn, cb) {\n                var ctx = this._ctx;\n                if (ctx.error) return ctx.table._trans(null, function rejector(resolve, reject) {\n                    reject(ctx.error);\n                });else return ctx.table._idbstore(READONLY, fn).then(cb);\n            },\n            _write: function (fn) {\n                var ctx = this._ctx;\n                if (ctx.error) return ctx.table._trans(null, function rejector(resolve, reject) {\n                    reject(ctx.error);\n                });else return ctx.table._idbstore(READWRITE, fn, \"locked\"); // When doing write operations on collections, always lock the operation so that upcoming operations gets queued.\n            },\n            _addAlgorithm: function (fn) {\n                var ctx = this._ctx;\n                ctx.algorithm = combine(ctx.algorithm, fn);\n            },\n\n            _iterate: function (fn, resolve, reject, idbstore) {\n                return iter(this._ctx, fn, resolve, reject, idbstore);\n            },\n\n            clone: function (props$$1) {\n                var rv = Object.create(this.constructor.prototype),\n                    ctx = Object.create(this._ctx);\n                if (props$$1) extend(ctx, props$$1);\n                rv._ctx = ctx;\n                return rv;\n            },\n\n            raw: function () {\n                this._ctx.valueMapper = null;\n                return this;\n            },\n\n            //\n            // Collection Public methods\n            //\n\n            each: function (fn) {\n                var ctx = this._ctx;\n\n                if (fake) {\n                    var item = getInstanceTemplate(ctx),\n                        primKeyPath = ctx.table.schema.primKey.keyPath,\n                        key = getByKeyPath(item, ctx.index ? ctx.table.schema.idxByName[ctx.index].keyPath : primKeyPath),\n                        primaryKey = getByKeyPath(item, primKeyPath);\n                    fn(item, { key: key, primaryKey: primaryKey });\n                }\n\n                return this._read(function (resolve, reject, idbstore) {\n                    iter(ctx, fn, resolve, reject, idbstore);\n                });\n            },\n\n            count: function (cb) {\n                if (fake) return Promise.resolve(0).then(cb);\n                var ctx = this._ctx;\n\n                if (isPlainKeyRange(ctx, true)) {\n                    // This is a plain key range. We can use the count() method if the index.\n                    return this._read(function (resolve, reject, idbstore) {\n                        var idx = getIndexOrStore(ctx, idbstore);\n                        var req = ctx.range ? idx.count(ctx.range) : idx.count();\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = function (e) {\n                            resolve(Math.min(e.target.result, ctx.limit));\n                        };\n                    }, cb);\n                } else {\n                    // Algorithms, filters or expressions are applied. Need to count manually.\n                    var count = 0;\n                    return this._read(function (resolve, reject, idbstore) {\n                        iter(ctx, function () {\n                            ++count;return false;\n                        }, function () {\n                            resolve(count);\n                        }, reject, idbstore);\n                    }, cb);\n                }\n            },\n\n            sortBy: function (keyPath, cb) {\n                /// <param name=\"keyPath\" type=\"String\"></param>\n                var parts = keyPath.split('.').reverse(),\n                    lastPart = parts[0],\n                    lastIndex = parts.length - 1;\n                function getval(obj, i) {\n                    if (i) return getval(obj[parts[i]], i - 1);\n                    return obj[lastPart];\n                }\n                var order = this._ctx.dir === \"next\" ? 1 : -1;\n\n                function sorter(a, b) {\n                    var aVal = getval(a, lastIndex),\n                        bVal = getval(b, lastIndex);\n                    return aVal < bVal ? -order : aVal > bVal ? order : 0;\n                }\n                return this.toArray(function (a) {\n                    return a.sort(sorter);\n                }).then(cb);\n            },\n\n            toArray: function (cb) {\n                var ctx = this._ctx;\n                return this._read(function (resolve, reject, idbstore) {\n                    fake && resolve([getInstanceTemplate(ctx)]);\n                    if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                        // Special optimation if we could use IDBObjectStore.getAll() or\n                        // IDBKeyRange.getAll():\n                        var readingHook = ctx.table.hook.reading.fire;\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\n                        var req = ctx.limit < Infinity ? idxOrStore.getAll(ctx.range, ctx.limit) : idxOrStore.getAll(ctx.range);\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = readingHook === mirror ? eventSuccessHandler(resolve) : wrap(eventSuccessHandler(function (res) {\n                            try {\n                                resolve(res.map(readingHook));\n                            } catch (e) {\n                                reject(e);\n                            }\n                        }));\n                    } else {\n                        // Getting array through a cursor.\n                        var a = [];\n                        iter(ctx, function (item) {\n                            a.push(item);\n                        }, function arrayComplete() {\n                            resolve(a);\n                        }, reject, idbstore);\n                    }\n                }, cb);\n            },\n\n            offset: function (offset) {\n                var ctx = this._ctx;\n                if (offset <= 0) return this;\n                ctx.offset += offset; // For count()\n                if (isPlainKeyRange(ctx)) {\n                    addReplayFilter(ctx, function () {\n                        var offsetLeft = offset;\n                        return function (cursor, advance) {\n                            if (offsetLeft === 0) return true;\n                            if (offsetLeft === 1) {\n                                --offsetLeft;return false;\n                            }\n                            advance(function () {\n                                cursor.advance(offsetLeft);\n                                offsetLeft = 0;\n                            });\n                            return false;\n                        };\n                    });\n                } else {\n                    addReplayFilter(ctx, function () {\n                        var offsetLeft = offset;\n                        return function () {\n                            return --offsetLeft < 0;\n                        };\n                    });\n                }\n                return this;\n            },\n\n            limit: function (numRows) {\n                this._ctx.limit = Math.min(this._ctx.limit, numRows); // For count()\n                addReplayFilter(this._ctx, function () {\n                    var rowsLeft = numRows;\n                    return function (cursor, advance, resolve) {\n                        if (--rowsLeft <= 0) advance(resolve); // Stop after this item has been included\n                        return rowsLeft >= 0; // If numRows is already below 0, return false because then 0 was passed to numRows initially. Otherwise we wouldnt come here.\n                    };\n                }, true);\n                return this;\n            },\n\n            until: function (filterFunction, bIncludeStopEntry) {\n                var ctx = this._ctx;\n                fake && filterFunction(getInstanceTemplate(ctx));\n                addFilter(this._ctx, function (cursor, advance, resolve) {\n                    if (filterFunction(cursor.value)) {\n                        advance(resolve);\n                        return bIncludeStopEntry;\n                    } else {\n                        return true;\n                    }\n                });\n                return this;\n            },\n\n            first: function (cb) {\n                return this.limit(1).toArray(function (a) {\n                    return a[0];\n                }).then(cb);\n            },\n\n            last: function (cb) {\n                return this.reverse().first(cb);\n            },\n\n            filter: function (filterFunction) {\n                /// <param name=\"jsFunctionFilter\" type=\"Function\">function(val){return true/false}</param>\n                fake && filterFunction(getInstanceTemplate(this._ctx));\n                addFilter(this._ctx, function (cursor) {\n                    return filterFunction(cursor.value);\n                });\n                // match filters not used in Dexie.js but can be used by 3rd part libraries to test a\n                // collection for a match without querying DB. Used by Dexie.Observable.\n                addMatchFilter(this._ctx, filterFunction);\n                return this;\n            },\n\n            and: function (filterFunction) {\n                return this.filter(filterFunction);\n            },\n\n            or: function (indexName) {\n                return new WhereClause(this._ctx.table, indexName, this);\n            },\n\n            reverse: function () {\n                this._ctx.dir = this._ctx.dir === \"prev\" ? \"next\" : \"prev\";\n                if (this._ondirectionchange) this._ondirectionchange(this._ctx.dir);\n                return this;\n            },\n\n            desc: function () {\n                return this.reverse();\n            },\n\n            eachKey: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                return this.each(function (val, cursor) {\n                    cb(cursor.key, cursor);\n                });\n            },\n\n            eachUniqueKey: function (cb) {\n                this._ctx.unique = \"unique\";\n                return this.eachKey(cb);\n            },\n\n            eachPrimaryKey: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                return this.each(function (val, cursor) {\n                    cb(cursor.primaryKey, cursor);\n                });\n            },\n\n            keys: function (cb) {\n                var ctx = this._ctx;\n                ctx.keysOnly = !ctx.isMatch;\n                var a = [];\n                return this.each(function (item, cursor) {\n                    a.push(cursor.key);\n                }).then(function () {\n                    return a;\n                }).then(cb);\n            },\n\n            primaryKeys: function (cb) {\n                var ctx = this._ctx;\n                if (hasGetAll && ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                    // Special optimation if we could use IDBObjectStore.getAllKeys() or\n                    // IDBKeyRange.getAllKeys():\n                    return this._read(function (resolve, reject, idbstore) {\n                        var idxOrStore = getIndexOrStore(ctx, idbstore);\n                        var req = ctx.limit < Infinity ? idxOrStore.getAllKeys(ctx.range, ctx.limit) : idxOrStore.getAllKeys(ctx.range);\n                        req.onerror = eventRejectHandler(reject);\n                        req.onsuccess = eventSuccessHandler(resolve);\n                    }).then(cb);\n                }\n                ctx.keysOnly = !ctx.isMatch;\n                var a = [];\n                return this.each(function (item, cursor) {\n                    a.push(cursor.primaryKey);\n                }).then(function () {\n                    return a;\n                }).then(cb);\n            },\n\n            uniqueKeys: function (cb) {\n                this._ctx.unique = \"unique\";\n                return this.keys(cb);\n            },\n\n            firstKey: function (cb) {\n                return this.limit(1).keys(function (a) {\n                    return a[0];\n                }).then(cb);\n            },\n\n            lastKey: function (cb) {\n                return this.reverse().firstKey(cb);\n            },\n\n            distinct: function () {\n                var ctx = this._ctx,\n                    idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n                if (!idx || !idx.multi) return this; // distinct() only makes differencies on multiEntry indexes.\n                var set = {};\n                addFilter(this._ctx, function (cursor) {\n                    var strKey = cursor.primaryKey.toString(); // Converts any Date to String, String to String, Number to String and Array to comma-separated string\n                    var found = hasOwn(set, strKey);\n                    set[strKey] = true;\n                    return !found;\n                });\n                return this;\n            }\n        };\n    });\n\n    //\n    //\n    // WriteableCollection Class\n    //\n    //\n    function WriteableCollection() {\n        Collection.apply(this, arguments);\n    }\n\n    derive(WriteableCollection).from(Collection).extend({\n\n        //\n        // WriteableCollection Public Methods\n        //\n\n        modify: function (changes) {\n            var self = this,\n                ctx = this._ctx,\n                hook = ctx.table.hook,\n                updatingHook = hook.updating.fire,\n                deletingHook = hook.deleting.fire;\n\n            fake && typeof changes === 'function' && changes.call({ value: ctx.table.schema.instanceTemplate }, ctx.table.schema.instanceTemplate);\n\n            return this._write(function (resolve, reject, idbstore, trans) {\n                var modifyer;\n                if (typeof changes === 'function') {\n                    // Changes is a function that may update, add or delete propterties or even require a deletion the object itself (delete this.item)\n                    if (updatingHook === nop && deletingHook === nop) {\n                        // Noone cares about what is being changed. Just let the modifier function be the given argument as is.\n                        modifyer = changes;\n                    } else {\n                        // People want to know exactly what is being modified or deleted.\n                        // Let modifyer be a proxy function that finds out what changes the caller is actually doing\n                        // and call the hooks accordingly!\n                        modifyer = function (item) {\n                            var origItem = deepClone(item); // Clone the item first so we can compare laters.\n                            if (changes.call(this, item, this) === false) return false; // Call the real modifyer function (If it returns false explicitely, it means it dont want to modify anyting on this object)\n                            if (!hasOwn(this, \"value\")) {\n                                // The real modifyer function requests a deletion of the object. Inform the deletingHook that a deletion is taking place.\n                                deletingHook.call(this, this.primKey, item, trans);\n                            } else {\n                                // No deletion. Check what was changed\n                                var objectDiff = getObjectDiff(origItem, this.value);\n                                var additionalChanges = updatingHook.call(this, objectDiff, this.primKey, origItem, trans);\n                                if (additionalChanges) {\n                                    // Hook want to apply additional modifications. Make sure to fullfill the will of the hook.\n                                    item = this.value;\n                                    keys(additionalChanges).forEach(function (keyPath) {\n                                        setByKeyPath(item, keyPath, additionalChanges[keyPath]); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\n                                    });\n                                }\n                            }\n                        };\n                    }\n                } else if (updatingHook === nop) {\n                    // changes is a set of {keyPath: value} and no one is listening to the updating hook.\n                    var keyPaths = keys(changes);\n                    var numKeys = keyPaths.length;\n                    modifyer = function (item) {\n                        var anythingModified = false;\n                        for (var i = 0; i < numKeys; ++i) {\n                            var keyPath = keyPaths[i],\n                                val = changes[keyPath];\n                            if (getByKeyPath(item, keyPath) !== val) {\n                                setByKeyPath(item, keyPath, val); // Adding {keyPath: undefined} means that the keyPath should be deleted. Handled by setByKeyPath\n                                anythingModified = true;\n                            }\n                        }\n                        return anythingModified;\n                    };\n                } else {\n                    // changes is a set of {keyPath: value} and people are listening to the updating hook so we need to call it and\n                    // allow it to add additional modifications to make.\n                    var origChanges = changes;\n                    changes = shallowClone(origChanges); // Let's work with a clone of the changes keyPath/value set so that we can restore it in case a hook extends it.\n                    modifyer = function (item) {\n                        var anythingModified = false;\n                        var additionalChanges = updatingHook.call(this, changes, this.primKey, deepClone(item), trans);\n                        if (additionalChanges) extend(changes, additionalChanges);\n                        keys(changes).forEach(function (keyPath) {\n                            var val = changes[keyPath];\n                            if (getByKeyPath(item, keyPath) !== val) {\n                                setByKeyPath(item, keyPath, val);\n                                anythingModified = true;\n                            }\n                        });\n                        if (additionalChanges) changes = shallowClone(origChanges); // Restore original changes for next iteration\n                        return anythingModified;\n                    };\n                }\n\n                var count = 0;\n                var successCount = 0;\n                var iterationComplete = false;\n                var failures = [];\n                var failKeys = [];\n                var currentKey = null;\n\n                function modifyItem(item, cursor) {\n                    currentKey = cursor.primaryKey;\n                    var thisContext = {\n                        primKey: cursor.primaryKey,\n                        value: item,\n                        onsuccess: null,\n                        onerror: null\n                    };\n\n                    function onerror(e) {\n                        failures.push(e);\n                        failKeys.push(thisContext.primKey);\n                        checkFinished();\n                        return true; // Catch these errors and let a final rejection decide whether or not to abort entire transaction\n                    }\n\n                    if (modifyer.call(thisContext, item, thisContext) !== false) {\n                        // If a callback explicitely returns false, do not perform the update!\n                        var bDelete = !hasOwn(thisContext, \"value\");\n                        ++count;\n                        tryCatch(function () {\n                            var req = bDelete ? cursor.delete() : cursor.update(thisContext.value);\n                            req._hookCtx = thisContext;\n                            req.onerror = hookedEventRejectHandler(onerror);\n                            req.onsuccess = hookedEventSuccessHandler(function () {\n                                ++successCount;\n                                checkFinished();\n                            });\n                        }, onerror);\n                    } else if (thisContext.onsuccess) {\n                        // Hook will expect either onerror or onsuccess to always be called!\n                        thisContext.onsuccess(thisContext.value);\n                    }\n                }\n\n                function doReject(e) {\n                    if (e) {\n                        failures.push(e);\n                        failKeys.push(currentKey);\n                    }\n                    return reject(new ModifyError(\"Error modifying one or more objects\", failures, successCount, failKeys));\n                }\n\n                function checkFinished() {\n                    if (iterationComplete && successCount + failures.length === count) {\n                        if (failures.length > 0) doReject();else resolve(successCount);\n                    }\n                }\n                self.clone().raw()._iterate(modifyItem, function () {\n                    iterationComplete = true;\n                    checkFinished();\n                }, doReject, idbstore);\n            });\n        },\n\n        'delete': function () {\n            var _this4 = this;\n\n            var ctx = this._ctx,\n                range = ctx.range,\n                deletingHook = ctx.table.hook.deleting.fire,\n                hasDeleteHook = deletingHook !== nop;\n            if (!hasDeleteHook && isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || !range)) // if no range, we'll use clear().\n                {\n                    // May use IDBObjectStore.delete(IDBKeyRange) in this case (Issue #208)\n                    // For chromium, this is the way most optimized version.\n                    // For IE/Edge, this could hang the indexedDB engine and make operating system instable\n                    // (https://gist.github.com/dfahlander/5a39328f029de18222cf2125d56c38f7)\n                    return this._write(function (resolve, reject, idbstore) {\n                        // Our API contract is to return a count of deleted items, so we have to count() before delete().\n                        var onerror = eventRejectHandler(reject),\n                            countReq = range ? idbstore.count(range) : idbstore.count();\n                        countReq.onerror = onerror;\n                        countReq.onsuccess = function () {\n                            var count = countReq.result;\n                            tryCatch(function () {\n                                var delReq = range ? idbstore.delete(range) : idbstore.clear();\n                                delReq.onerror = onerror;\n                                delReq.onsuccess = function () {\n                                    return resolve(count);\n                                };\n                            }, function (err) {\n                                return reject(err);\n                            });\n                        };\n                    });\n                }\n\n            // Default version to use when collection is not a vanilla IDBKeyRange on the primary key.\n            // Divide into chunks to not starve RAM.\n            // If has delete hook, we will have to collect not just keys but also objects, so it will use\n            // more memory and need lower chunk size.\n            var CHUNKSIZE = hasDeleteHook ? 2000 : 10000;\n\n            return this._write(function (resolve, reject, idbstore, trans) {\n                var totalCount = 0;\n                // Clone collection and change its table and set a limit of CHUNKSIZE on the cloned Collection instance.\n                var collection = _this4.clone({\n                    keysOnly: !ctx.isMatch && !hasDeleteHook }) // load just keys (unless filter() or and() or deleteHook has subscribers)\n                .distinct() // In case multiEntry is used, never delete same key twice because resulting count\n                // would become larger than actual delete count.\n                .limit(CHUNKSIZE).raw(); // Don't filter through reading-hooks (like mapped classes etc)\n\n                var keysOrTuples = [];\n\n                // We're gonna do things on as many chunks that are needed.\n                // Use recursion of nextChunk function:\n                var nextChunk = function () {\n                    return collection.each(hasDeleteHook ? function (val, cursor) {\n                        // Somebody subscribes to hook('deleting'). Collect all primary keys and their values,\n                        // so that the hook can be called with its values in bulkDelete().\n                        keysOrTuples.push([cursor.primaryKey, cursor.value]);\n                    } : function (val, cursor) {\n                        // No one subscribes to hook('deleting'). Collect only primary keys:\n                        keysOrTuples.push(cursor.primaryKey);\n                    }).then(function () {\n                        // Chromium deletes faster when doing it in sort order.\n                        hasDeleteHook ? keysOrTuples.sort(function (a, b) {\n                            return ascending(a[0], b[0]);\n                        }) : keysOrTuples.sort(ascending);\n                        return bulkDelete(idbstore, trans, keysOrTuples, hasDeleteHook, deletingHook);\n                    }).then(function () {\n                        var count = keysOrTuples.length;\n                        totalCount += count;\n                        keysOrTuples = [];\n                        return count < CHUNKSIZE ? totalCount : nextChunk();\n                    });\n                };\n\n                resolve(nextChunk());\n            });\n        }\n    });\n\n    //\n    //\n    //\n    // ------------------------- Help functions ---------------------------\n    //\n    //\n    //\n\n    function lowerVersionFirst(a, b) {\n        return a._cfg.version - b._cfg.version;\n    }\n\n    function setApiOnPlace(objs, tableNames, mode, dbschema) {\n        tableNames.forEach(function (tableName) {\n            var tableInstance = db._tableFactory(mode, dbschema[tableName]);\n            objs.forEach(function (obj) {\n                tableName in obj || (obj[tableName] = tableInstance);\n            });\n        });\n    }\n\n    function removeTablesApi(objs) {\n        objs.forEach(function (obj) {\n            for (var key in obj) {\n                if (obj[key] instanceof Table) delete obj[key];\n            }\n        });\n    }\n\n    function iterate(req, filter, fn, resolve, reject, valueMapper) {\n\n        // Apply valueMapper (hook('reading') or mappped class)\n        var mappedFn = valueMapper ? function (x, c, a) {\n            return fn(valueMapper(x), c, a);\n        } : fn;\n        // Wrap fn with PSD and microtick stuff from Promise.\n        var wrappedFn = wrap(mappedFn, reject);\n\n        if (!req.onerror) req.onerror = eventRejectHandler(reject);\n        if (filter) {\n            req.onsuccess = trycatcher(function filter_record() {\n                var cursor = req.result;\n                if (cursor) {\n                    var c = function () {\n                        cursor.continue();\n                    };\n                    if (filter(cursor, function (advancer) {\n                        c = advancer;\n                    }, resolve, reject)) wrappedFn(cursor.value, cursor, function (advancer) {\n                        c = advancer;\n                    });\n                    c();\n                } else {\n                    resolve();\n                }\n            }, reject);\n        } else {\n            req.onsuccess = trycatcher(function filter_record() {\n                var cursor = req.result;\n                if (cursor) {\n                    var c = function () {\n                        cursor.continue();\n                    };\n                    wrappedFn(cursor.value, cursor, function (advancer) {\n                        c = advancer;\n                    });\n                    c();\n                } else {\n                    resolve();\n                }\n            }, reject);\n        }\n    }\n\n    function parseIndexSyntax(indexes) {\n        /// <param name=\"indexes\" type=\"String\"></param>\n        /// <returns type=\"Array\" elementType=\"IndexSpec\"></returns>\n        var rv = [];\n        indexes.split(',').forEach(function (index) {\n            index = index.trim();\n            var name = index.replace(/([&*]|\\+\\+)/g, \"\"); // Remove \"&\", \"++\" and \"*\"\n            // Let keyPath of \"[a+b]\" be [\"a\",\"b\"]:\n            var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n\n            rv.push(new IndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), /\\./.test(index)));\n        });\n        return rv;\n    }\n\n    function cmp(key1, key2) {\n        return indexedDB.cmp(key1, key2);\n    }\n\n    function min(a, b) {\n        return cmp(a, b) < 0 ? a : b;\n    }\n\n    function max(a, b) {\n        return cmp(a, b) > 0 ? a : b;\n    }\n\n    function ascending(a, b) {\n        return indexedDB.cmp(a, b);\n    }\n\n    function descending(a, b) {\n        return indexedDB.cmp(b, a);\n    }\n\n    function simpleCompare(a, b) {\n        return a < b ? -1 : a === b ? 0 : 1;\n    }\n\n    function simpleCompareReverse(a, b) {\n        return a > b ? -1 : a === b ? 0 : 1;\n    }\n\n    function combine(filter1, filter2) {\n        return filter1 ? filter2 ? function () {\n            return filter1.apply(this, arguments) && filter2.apply(this, arguments);\n        } : filter1 : filter2;\n    }\n\n    function readGlobalSchema() {\n        db.verno = idbdb.version / 10;\n        db._dbSchema = globalSchema = {};\n        dbStoreNames = slice(idbdb.objectStoreNames, 0);\n        if (dbStoreNames.length === 0) return; // Database contains no stores.\n        var trans = idbdb.transaction(safariMultiStoreFix(dbStoreNames), 'readonly');\n        dbStoreNames.forEach(function (storeName) {\n            var store = trans.objectStore(storeName),\n                keyPath = store.keyPath,\n                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\n            var primKey = new IndexSpec(keyPath, keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== 'string', dotted);\n            var indexes = [];\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var idbindex = store.index(store.indexNames[j]);\n                keyPath = idbindex.keyPath;\n                dotted = keyPath && typeof keyPath === 'string' && keyPath.indexOf('.') !== -1;\n                var index = new IndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== 'string', dotted);\n                indexes.push(index);\n            }\n            globalSchema[storeName] = new TableSchema(storeName, primKey, indexes, {});\n        });\n        setApiOnPlace([allTables, Transaction.prototype], keys(globalSchema), READWRITE, globalSchema);\n    }\n\n    function adjustToExistingIndexNames(schema, idbtrans) {\n        /// <summary>\n        /// Issue #30 Problem with existing db - adjust to existing index names when migrating from non-dexie db\n        /// </summary>\n        /// <param name=\"schema\" type=\"Object\">Map between name and TableSchema</param>\n        /// <param name=\"idbtrans\" type=\"IDBTransaction\"></param>\n        var storeNames = idbtrans.db.objectStoreNames;\n        for (var i = 0; i < storeNames.length; ++i) {\n            var storeName = storeNames[i];\n            var store = idbtrans.objectStore(storeName);\n            hasGetAll = 'getAll' in store;\n            for (var j = 0; j < store.indexNames.length; ++j) {\n                var indexName = store.indexNames[j];\n                var keyPath = store.index(indexName).keyPath;\n                var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n                if (schema[storeName]) {\n                    var indexSpec = schema[storeName].idxByName[dexieName];\n                    if (indexSpec) indexSpec.name = indexName;\n                }\n            }\n        }\n    }\n\n    function fireOnBlocked(ev) {\n        db.on(\"blocked\").fire(ev);\n        // Workaround (not fully*) for missing \"versionchange\" event in IE,Edge and Safari:\n        connections.filter(function (c) {\n            return c.name === db.name && c !== db && !c._vcFired;\n        }).map(function (c) {\n            return c.on(\"versionchange\").fire(ev);\n        });\n    }\n\n    extend(this, {\n        Collection: Collection,\n        Table: Table,\n        Transaction: Transaction,\n        Version: Version,\n        WhereClause: WhereClause,\n        WriteableCollection: WriteableCollection,\n        WriteableTable: WriteableTable\n    });\n\n    init();\n\n    addons.forEach(function (fn) {\n        fn(db);\n    });\n}\n\nvar fakeAutoComplete = function () {}; // Will never be changed. We just fake for the IDE that we change it (see doFakeAutoComplete())\nvar fake = false; // Will never be changed. We just fake for the IDE that we change it (see doFakeAutoComplete())\n\nfunction parseType(type) {\n    if (typeof type === 'function') {\n        return new type();\n    } else if (isArray(type)) {\n        return [parseType(type[0])];\n    } else if (type && typeof type === 'object') {\n        var rv = {};\n        applyStructure(rv, type);\n        return rv;\n    } else {\n        return type;\n    }\n}\n\nfunction applyStructure(obj, structure) {\n    keys(structure).forEach(function (member) {\n        var value = parseType(structure[member]);\n        obj[member] = value;\n    });\n    return obj;\n}\n\nfunction eventSuccessHandler(done) {\n    return function (ev) {\n        done(ev.target.result);\n    };\n}\n\nfunction hookedEventSuccessHandler(resolve) {\n    // wrap() is needed when calling hooks because the rare scenario of:\n    //  * hook does a db operation that fails immediately (IDB throws exception)\n    //    For calling db operations on correct transaction, wrap makes sure to set PSD correctly.\n    //    wrap() will also execute in a virtual tick.\n    //  * If not wrapped in a virtual tick, direct exception will launch a new physical tick.\n    //  * If this was the last event in the bulk, the promise will resolve after a physical tick\n    //    and the transaction will have committed already.\n    // If no hook, the virtual tick will be executed in the reject()/resolve of the final promise,\n    // because it is always marked with _lib = true when created using Transaction._promise().\n    return wrap(function (event) {\n        var req = event.target,\n            result = req.result,\n            ctx = req._hookCtx,\n            // Contains the hook error handler. Put here instead of closure to boost performance.\n        hookSuccessHandler = ctx && ctx.onsuccess;\n        hookSuccessHandler && hookSuccessHandler(result);\n        resolve && resolve(result);\n    }, resolve);\n}\n\nfunction eventRejectHandler(reject) {\n    return function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    };\n}\n\nfunction hookedEventRejectHandler(reject) {\n    return wrap(function (event) {\n        // See comment on hookedEventSuccessHandler() why wrap() is needed only when supporting hooks.\n\n        var req = event.target,\n            err = req.error,\n            ctx = req._hookCtx,\n            // Contains the hook error handler. Put here instead of closure to boost performance.\n        hookErrorHandler = ctx && ctx.onerror;\n        hookErrorHandler && hookErrorHandler(err);\n        preventDefault(event);\n        reject(err);\n        return false;\n    });\n}\n\nfunction preventDefault(event) {\n    if (event.stopPropagation) // IndexedDBShim doesnt support this on Safari 8 and below.\n        event.stopPropagation();\n    if (event.preventDefault) // IndexedDBShim doesnt support this on Safari 8 and below.\n        event.preventDefault();\n}\n\nfunction globalDatabaseList(cb) {\n    var val,\n        localStorage = Dexie.dependencies.localStorage;\n    if (!localStorage) return cb([]); // Envs without localStorage support\n    try {\n        val = JSON.parse(localStorage.getItem('Dexie.DatabaseNames') || \"[]\");\n    } catch (e) {\n        val = [];\n    }\n    if (cb(val)) {\n        localStorage.setItem('Dexie.DatabaseNames', JSON.stringify(val));\n    }\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = function (result) {\n        return iterator.next(result);\n    },\n        doThrow = function (error) {\n        return iterator.throw(error);\n    },\n        onSuccess = step(callNext),\n        onError = step(doThrow);\n\n    function step(getNext) {\n        return function (val) {\n            var next = getNext(val),\n                value = next.value;\n\n            return next.done ? value : !value || typeof value.then !== 'function' ? isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);\n        };\n    }\n\n    return step(callNext)();\n}\n\n//\n// IndexSpec struct\n//\nfunction IndexSpec(name, keyPath, unique, multi, auto, compound, dotted) {\n    /// <param name=\"name\" type=\"String\"></param>\n    /// <param name=\"keyPath\" type=\"String\"></param>\n    /// <param name=\"unique\" type=\"Boolean\"></param>\n    /// <param name=\"multi\" type=\"Boolean\"></param>\n    /// <param name=\"auto\" type=\"Boolean\"></param>\n    /// <param name=\"compound\" type=\"Boolean\"></param>\n    /// <param name=\"dotted\" type=\"Boolean\"></param>\n    this.name = name;\n    this.keyPath = keyPath;\n    this.unique = unique;\n    this.multi = multi;\n    this.auto = auto;\n    this.compound = compound;\n    this.dotted = dotted;\n    var keyPathSrc = typeof keyPath === 'string' ? keyPath : keyPath && '[' + [].join.call(keyPath, '+') + ']';\n    this.src = (unique ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + keyPathSrc;\n}\n\n//\n// TableSchema struct\n//\nfunction TableSchema(name, primKey, indexes, instanceTemplate) {\n    /// <param name=\"name\" type=\"String\"></param>\n    /// <param name=\"primKey\" type=\"IndexSpec\"></param>\n    /// <param name=\"indexes\" type=\"Array\" elementType=\"IndexSpec\"></param>\n    /// <param name=\"instanceTemplate\" type=\"Object\"></param>\n    this.name = name;\n    this.primKey = primKey || new IndexSpec();\n    this.indexes = indexes || [new IndexSpec()];\n    this.instanceTemplate = instanceTemplate;\n    this.mappedClass = null;\n    this.idxByName = arrayToObject(indexes, function (index) {\n        return [index.name, index];\n    });\n}\n\n// Used in when defining dependencies later...\n// (If IndexedDBShim is loaded, prefer it before standard indexedDB)\nvar idbshim = _global.idbModules && _global.idbModules.shimIndexedDB ? _global.idbModules : {};\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\n\nfunction getNativeGetDatabaseNamesFn(indexedDB) {\n    var fn = indexedDB && (indexedDB.getDatabaseNames || indexedDB.webkitGetDatabaseNames);\n    return fn && fn.bind(indexedDB);\n}\n\n// Export Error classes\nprops(Dexie, fullNameExceptions); // Dexie.XXXError = class XXXError {...};\n\n//\n// Static methods and properties\n// \nprops(Dexie, {\n\n    //\n    // Static delete() method.\n    //\n    delete: function (databaseName) {\n        var db = new Dexie(databaseName),\n            promise = db.delete();\n        promise.onblocked = function (fn) {\n            db.on(\"blocked\", fn);\n            return this;\n        };\n        return promise;\n    },\n\n    //\n    // Static exists() method.\n    //\n    exists: function (name) {\n        return new Dexie(name).open().then(function (db) {\n            db.close();\n            return true;\n        }).catch(Dexie.NoSuchDatabaseError, function () {\n            return false;\n        });\n    },\n\n    //\n    // Static method for retrieving a list of all existing databases at current host.\n    //\n    getDatabaseNames: function (cb) {\n        return new Promise(function (resolve, reject) {\n            var getDatabaseNames = getNativeGetDatabaseNamesFn(indexedDB);\n            if (getDatabaseNames) {\n                // In case getDatabaseNames() becomes standard, let's prepare to support it:\n                var req = getDatabaseNames();\n                req.onsuccess = function (event) {\n                    resolve(slice(event.target.result, 0)); // Converst DOMStringList to Array<String>\n                };\n                req.onerror = eventRejectHandler(reject);\n            } else {\n                globalDatabaseList(function (val) {\n                    resolve(val);\n                    return false;\n                });\n            }\n        }).then(cb);\n    },\n\n    defineClass: function (structure) {\n        /// <summary>\n        ///     Create a javascript constructor based on given template for which properties to expect in the class.\n        ///     Any property that is a constructor function will act as a type. So {name: String} will be equal to {name: new String()}.\n        /// </summary>\n        /// <param name=\"structure\">Helps IDE code completion by knowing the members that objects contain and not just the indexes. Also\n        /// know what type each member has. Example: {name: String, emailAddresses: [String], properties: {shoeSize: Number}}</param>\n\n        // Default constructor able to copy given properties into this object.\n        function Class(properties) {\n            /// <param name=\"properties\" type=\"Object\" optional=\"true\">Properties to initialize object with.\n            /// </param>\n            properties ? extend(this, properties) : fake && applyStructure(this, structure);\n        }\n        return Class;\n    },\n\n    applyStructure: applyStructure,\n\n    ignoreTransaction: function (scopeFunc) {\n        // In case caller is within a transaction but needs to create a separate transaction.\n        // Example of usage:\n        //\n        // Let's say we have a logger function in our app. Other application-logic should be unaware of the\n        // logger function and not need to include the 'logentries' table in all transaction it performs.\n        // The logging should always be done in a separate transaction and not be dependant on the current\n        // running transaction context. Then you could use Dexie.ignoreTransaction() to run code that starts a new transaction.\n        //\n        //     Dexie.ignoreTransaction(function() {\n        //         db.logentries.add(newLogEntry);\n        //     });\n        //\n        // Unless using Dexie.ignoreTransaction(), the above example would try to reuse the current transaction\n        // in current Promise-scope.\n        //\n        // An alternative to Dexie.ignoreTransaction() would be setImmediate() or setTimeout(). The reason we still provide an\n        // API for this because\n        //  1) The intention of writing the statement could be unclear if using setImmediate() or setTimeout().\n        //  2) setTimeout() would wait unnescessary until firing. This is however not the case with setImmediate().\n        //  3) setImmediate() is not supported in the ES standard.\n        //  4) You might want to keep other PSD state that was set in a parent PSD, such as PSD.letThrough.\n        return PSD.trans ? usePSD(PSD.transless, scopeFunc) : // Use the closest parent that was non-transactional.\n        scopeFunc(); // No need to change scope because there is no ongoing transaction.\n    },\n\n    vip: function (fn) {\n        // To be used by subscribers to the on('ready') event.\n        // This will let caller through to access DB even when it is blocked while the db.ready() subscribers are firing.\n        // This would have worked automatically if we were certain that the Provider was using Dexie.Promise for all asyncronic operations. The promise PSD\n        // from the provider.connect() call would then be derived all the way to when provider would call localDatabase.applyChanges(). But since\n        // the provider more likely is using non-promise async APIs or other thenable implementations, we cannot assume that.\n        // Note that this method is only useful for on('ready') subscribers that is returning a Promise from the event. If not using vip()\n        // the database could deadlock since it wont open until the returned Promise is resolved, and any non-VIPed operation started by\n        // the caller will not resolve until database is opened.\n        return newScope(function () {\n            PSD.letThrough = true; // Make sure we are let through if still blocking db due to onready is firing.\n            return fn();\n        });\n    },\n\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);\n                return rv;\n            } catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function') return Promise.resolve(rv);\n            return rv;\n        } catch (e) {\n            return rejection(e);\n        }\n    },\n\n    // Dexie.currentTransaction property\n    currentTransaction: {\n        get: function () {\n            return PSD.trans || null;\n        }\n    },\n\n    // Export our Promise implementation since it can be handy as a standalone Promise implementation\n    Promise: Promise,\n\n    // Dexie.debug proptery:\n    // Dexie.debug = false\n    // Dexie.debug = true\n    // Dexie.debug = \"dexie\" - don't hide dexie's stack frames.\n    debug: {\n        get: function () {\n            return debug;\n        },\n        set: function (value) {\n            setDebug(value, value === 'dexie' ? function () {\n                return true;\n            } : dexieStackFrameFilter);\n        }\n    },\n\n    // Export our derive/extend/override methodology\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    // Export our Events() function - can be handy as a toolkit\n    Events: Events,\n    events: { get: deprecated(function () {\n            return Events;\n        }) }, // Backward compatible lowercase version.\n    // Utilities\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    asap: asap,\n    maxKey: maxKey,\n    // Addon registry\n    addons: [],\n    // Global DB connection list\n    connections: connections,\n\n    MultiModifyError: exceptions.Modify, // Backward compatibility 0.9.8. Deprecate.\n    errnames: errnames,\n\n    // Export other static classes\n    IndexSpec: IndexSpec,\n    TableSchema: TableSchema,\n\n    //\n    // Dependencies\n    //\n    // These will automatically work in browsers with indexedDB support, or where an indexedDB polyfill has been included.\n    //\n    // In node.js, however, these properties must be set \"manually\" before instansiating a new Dexie().\n    // For node.js, you need to require indexeddb-js or similar and then set these deps.\n    //\n    dependencies: {\n        // Required:\n        indexedDB: idbshim.shimIndexedDB || _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: idbshim.IDBKeyRange || _global.IDBKeyRange || _global.webkitIDBKeyRange\n    },\n\n    // API Version Number: Type Number, make sure to always set a version number that can be comparable correctly. Example: 0.9, 0.91, 0.92, 1.0, 1.01, 1.1, 1.2, 1.21, etc.\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.').map(function (n) {\n        return parseInt(n);\n    }).reduce(function (p, c, i) {\n        return p + c / Math.pow(10, i * 2);\n    }),\n    fakeAutoComplete: fakeAutoComplete,\n\n    // https://github.com/dfahlander/Dexie.js/issues/186\n    // typescript compiler tsc in mode ts-->es5 & commonJS, will expect require() to return\n    // x.default. Workaround: Set Dexie.default = Dexie.\n    default: Dexie\n});\n\ntryCatch(function () {\n    // Optional dependencies\n    // localStorage\n    Dexie.dependencies.localStorage = (typeof chrome !== \"undefined\" && chrome !== null ? chrome.storage : void 0) != null ? null : _global.localStorage;\n});\n\n// Map DOMErrors and DOMExceptions to corresponding Dexie errors. May change in Dexie v2.0.\nPromise.rejectionMapper = mapError;\n\n// Fool IDE to improve autocomplete. Tested with Visual Studio 2013 and 2015.\ndoFakeAutoComplete(function () {\n    Dexie.fakeAutoComplete = fakeAutoComplete = doFakeAutoComplete;\n    Dexie.fake = fake = true;\n});\n\nreturn Dexie;\n\n})));\n//# sourceMappingURL=dexie.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/dexie/dist/dexie.js\n// module id = 32\n// module chunks = 0","'use strict';\nvar childProcess = require('child_process');\nvar crossSpawnAsync = require('cross-spawn-async');\nvar stripEof = require('strip-eof');\nvar objectAssign = require('object-assign');\nvar npmRunPath = require('npm-run-path');\nvar isStream = require('is-stream');\nvar pathKey = require('path-key')();\nvar TEN_MEBIBYTE = 1024 * 1024 * 10;\n\nfunction handleArgs(cmd, args, opts) {\n\tvar parsed;\n\n\tif (opts && opts.__winShell === true) {\n\t\tdelete opts.__winShell;\n\t\tparsed = {\n\t\t\tcommand: cmd,\n\t\t\targs: args,\n\t\t\toptions: opts,\n\t\t\tfile: cmd,\n\t\t\toriginal: cmd\n\t\t};\n\t} else {\n\t\tparsed = crossSpawnAsync._parse(cmd, args, opts);\n\t}\n\n\topts = objectAssign({\n\t\tmaxBuffer: TEN_MEBIBYTE,\n\t\tstripEof: true,\n\t\tpreferLocal: true,\n\t\tencoding: 'utf8'\n\t}, parsed.options);\n\n\tif (opts.preferLocal) {\n\t\topts.env = objectAssign({}, opts.env || process.env);\n\t\topts.env[pathKey] = npmRunPath({\n\t\t\tcwd: opts.cwd,\n\t\t\tpath: opts.env[pathKey]\n\t\t});\n\t}\n\n\treturn {\n\t\tcmd: parsed.command,\n\t\targs: parsed.args,\n\t\topts: opts\n\t};\n}\n\nfunction handleInput(spawned, opts) {\n\tvar input = opts.input;\n\n\tif (input === null || input === undefined) {\n\t\treturn;\n\t}\n\n\tif (isStream(input)) {\n\t\tinput.pipe(spawned.stdin);\n\t} else {\n\t\tspawned.stdin.end(input);\n\t}\n}\n\nfunction handleOutput(opts, val) {\n\tif (opts.stripEof) {\n\t\tval = stripEof(val);\n\t}\n\n\treturn val;\n}\n\nfunction handleShell(fn, cmd, opts) {\n\tvar file;\n\tvar args;\n\n\topts = objectAssign({}, opts);\n\n\tif (process.platform === 'win32') {\n\t\topts.__winShell = true;\n\t\tfile = process.env.comspec || 'cmd.exe';\n\t\targs = ['/s', '/c', '\"' + cmd + '\"'];\n\t\topts.windowsVerbatimArguments = true;\n\t} else {\n\t\tfile = '/bin/sh';\n\t\targs = ['-c', cmd];\n\t}\n\n\tif (opts.shell) {\n\t\tfile = opts.shell;\n\t}\n\n\treturn fn(file, args, opts);\n}\n\nmodule.exports = function (cmd, args, opts) {\n\tvar spawned;\n\n\tvar promise = new Promise(function (resolve, reject) {\n\t\tvar parsed = handleArgs(cmd, args, opts);\n\n\t\tspawned = childProcess.execFile(parsed.cmd, parsed.args, parsed.opts, function (err, stdout, stderr) {\n\t\t\tif (err) {\n\t\t\t\terr.stdout = stdout;\n\t\t\t\terr.stderr = stderr;\n\t\t\t\terr.message += stdout;\n\t\t\t\treject(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve({\n\t\t\t\tstdout: handleOutput(parsed.opts, stdout),\n\t\t\t\tstderr: handleOutput(parsed.opts, stderr)\n\t\t\t});\n\t\t});\n\n\t\tcrossSpawnAsync._enoent.hookChildProcess(spawned, parsed);\n\n\t\thandleInput(spawned, parsed.opts);\n\t});\n\n\tspawned.then = promise.then.bind(promise);\n\tspawned.catch = promise.catch.bind(promise);\n\n\treturn spawned;\n};\n\nmodule.exports.stdout = function () {\n\t// TODO: set `stderr: 'ignore'` when that option is implemented\n\treturn module.exports.apply(null, arguments).then(function (x) {\n\t\treturn x.stdout;\n\t});\n};\n\nmodule.exports.stderr = function () {\n\t// TODO: set `stdout: 'ignore'` when that option is implemented\n\treturn module.exports.apply(null, arguments).then(function (x) {\n\t\treturn x.stderr;\n\t});\n};\n\nmodule.exports.shell = function (cmd, opts) {\n\treturn handleShell(module.exports, cmd, opts);\n};\n\nmodule.exports.spawn = function (cmd, args, opts) {\n\tvar parsed = handleArgs(cmd, args, opts);\n\tvar spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);\n\n\tcrossSpawnAsync._enoent.hookChildProcess(spawned, parsed);\n\n\treturn spawned;\n};\n\nmodule.exports.sync = function (cmd, args, opts) {\n\tvar parsed = handleArgs(cmd, args, opts);\n\n\tif (isStream(parsed.opts.input)) {\n\t\tthrow new TypeError('The `input` option cannot be a stream in sync mode');\n\t}\n\n\tvar result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);\n\n\tif (parsed.opts.stripEof) {\n\t\tresult.stdout = stripEof(result.stdout);\n\t\tresult.stderr = stripEof(result.stderr);\n\t}\n\n\treturn result;\n};\n\nmodule.exports.shellSync = function (cmd, opts) {\n\treturn handleShell(module.exports.sync, cmd, opts);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/execa/index.js\n// module id = 33\n// module chunks = 0","\n/**\n * Module dependencies.\n */\n\nvar sep = require('path').sep || '/';\n\n/**\n * Module exports.\n */\n\nmodule.exports = fileUriToPath;\n\n/**\n * File URI to Path function.\n *\n * @param {String} uri\n * @return {String} path\n * @api public\n */\n\nfunction fileUriToPath (uri) {\n  if ('string' != typeof uri ||\n      uri.length <= 7 ||\n      'file://' != uri.substring(0, 7)) {\n    throw new TypeError('must pass in a file:// URI to convert to a file path');\n  }\n\n  var rest = unescape(uri.substring(7));\n  var firstSlash = rest.indexOf('/');\n  var host = rest.substring(0, firstSlash);\n  var path = rest.substring(firstSlash + 1);\n\n  // 2.  Scheme Definition\n  // As a special case, <host> can be the string \"localhost\" or the empty\n  // string; this is interpreted as \"the machine from which the URL is\n  // being interpreted\".\n  if ('localhost' == host) host = '';\n\n  if (host) {\n    host = sep + sep + host;\n  }\n\n  // 3.2  Drives, drive letters, mount points, file system root\n  // Drive letters are mapped into the top of a file URI in various ways,\n  // depending on the implementation; some applications substitute\n  // vertical bar (\"|\") for the colon after the drive letter, yielding\n  // \"file:///c|/tmp/test.txt\".  In some cases, the colon is left\n  // unchanged, as in \"file:///c:/tmp/test.txt\".  In other cases, the\n  // colon is simply omitted, as in \"file:///c/tmp/test.txt\".\n  path = path.replace(/^(.+)\\|/, '$1:');\n\n  // for Windows, we need to invert the path separators from what a URI uses\n  if (sep == '\\\\') {\n    path = path.replace(/\\//g, '\\\\');\n  }\n\n  if (/^.+\\:/.test(path)) {\n    // has Windows drive at beginning of path\n  } else {\n    // unix path\n    path = sep + path;\n  }\n\n  return host + path;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/file-uri-to-path/index.js\n// module id = 34\n// module chunks = 0","'use strict';\n\nvar isStream = module.exports = function (stream) {\n\treturn stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';\n};\n\nisStream.writable = function (stream) {\n\treturn isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';\n};\n\nisStream.readable = function (stream) {\n\treturn isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';\n};\n\nisStream.duplex = function (stream) {\n\treturn isStream.writable(stream) && isStream.readable(stream);\n};\n\nisStream.transform = function (stream) {\n\treturn isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/is-stream/index.js\n// module id = 35\n// module chunks = 0","var fs = require('fs')\nvar core\nif (process.platform === 'win32' || global.TESTING_WINDOWS) {\n  core = require('./windows.js')\n} else {\n  core = require('./mode.js')\n}\n\nmodule.exports = isexe\nisexe.sync = sync\n\nfunction isexe (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  if (!cb) {\n    if (typeof Promise !== 'function') {\n      throw new TypeError('callback not provided')\n    }\n\n    return new Promise(function (resolve, reject) {\n      isexe(path, options || {}, function (er, is) {\n        if (er) {\n          reject(er)\n        } else {\n          resolve(is)\n        }\n      })\n    })\n  }\n\n  core(path, options || {}, function (er, is) {\n    // ignore EACCES because that just means we aren't allowed to run it\n    if (er) {\n      if (er.code === 'EACCES' || options && options.ignoreErrors) {\n        er = null\n        is = false\n      }\n    }\n    cb(er, is)\n  })\n}\n\nfunction sync (path, options) {\n  // my kingdom for a filtered catch\n  try {\n    return core.sync(path, options || {})\n  } catch (er) {\n    if (options && options.ignoreErrors || er.code === 'EACCES') {\n      return false\n    } else {\n      throw er\n    }\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/isexe/index.js\n// module id = 36\n// module chunks = 0","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), options)\n}\n\nfunction checkStat (stat, options) {\n  return stat.isFile() && checkMode(stat, options)\n}\n\nfunction checkMode (stat, options) {\n  var mod = stat.mode\n  var uid = stat.uid\n  var gid = stat.gid\n\n  var myUid = options.uid !== undefined ?\n    options.uid : process.getuid && process.getuid()\n  var myGid = options.gid !== undefined ?\n    options.gid : process.getgid && process.getgid()\n\n  var u = parseInt('100', 8)\n  var g = parseInt('010', 8)\n  var o = parseInt('001', 8)\n  var ug = u | g\n\n  var ret = (mod & o) ||\n    (mod & g) && gid === myGid ||\n    (mod & u) && uid === myUid ||\n    (mod & ug) && myUid === 0\n\n  return ret\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/isexe/mode.js\n// module id = 37\n// module chunks = 0","module.exports = isexe\nisexe.sync = sync\n\nvar fs = require('fs')\n\nfunction checkPathExt (path, options) {\n  var pathext = options.pathExt !== undefined ?\n    options.pathExt : process.env.PATHEXT\n\n  if (!pathext) {\n    return true\n  }\n\n  pathext = pathext.split(';')\n  if (pathext.indexOf('') !== -1) {\n    return true\n  }\n  for (var i = 0; i < pathext.length; i++) {\n    var p = pathext[i].toLowerCase()\n    if (p && path.substr(-p.length).toLowerCase() === p) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction checkStat (stat, path, options) {\n  if (!stat.isSymbolicLink() && !stat.isFile()) {\n    return false\n  }\n  return checkPathExt(path, options)\n}\n\nfunction isexe (path, options, cb) {\n  fs.stat(path, function (er, stat) {\n    cb(er, er ? false : checkStat(stat, path, options))\n  })\n}\n\nfunction sync (path, options) {\n  return checkStat(fs.statSync(path), path, options)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/isexe/windows.js\n// module id = 38\n// module chunks = 0","var keytar = require('../build/Release/keytar.node')\n\nfunction checkRequired(val, name) {\n  if (!val || val.length <= 0) {\n    throw new Error(name + ' is required.');\n  }\n}\n\nfunction callbackPromise(callback) {\n  if (typeof callback === 'function') {\n    return new Promise(function(resolve, reject) {\n      callback((err, val) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(val)\n        }\n      })\n    })\n  } else {\n    throw new Error('Callback required')\n  }\n}\n\nmodule.exports = {\n  getPassword: function (service, account) {\n    checkRequired(service, 'Service')\n    checkRequired(account, 'Account')\n\n    return callbackPromise(callback => keytar.getPassword(service, account, callback))\n  },\n\n  setPassword: function (service, account, password) {\n    checkRequired(service, 'Service')\n    checkRequired(account, 'Account')\n    checkRequired(password, 'Password')\n\n    return callbackPromise(callback => keytar.setPassword(service, account, password, callback))\n  },\n\n  deletePassword: function (service, account) {\n    checkRequired(service, 'Service')\n    checkRequired(account, 'Account')\n\n    return callbackPromise(callback => keytar.deletePassword(service, account, callback))\n  },\n\n  findPassword: function (service) {\n    checkRequired(service, 'Service')\n\n    return callbackPromise(callback => keytar.findPassword(service, callback))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/keytar/lib/keytar.js\n// module id = 39\n// module chunks = 0","'use strict';\nmodule.exports = function (fn, opts) {\n\topts = opts || {};\n\n\tvar cacheKey = opts.cacheKey || function (x) {\n\t\tif (arguments.length === 1 && (x === null || x === undefined || (typeof x !== 'function' && typeof x !== 'object'))) {\n\t\t\treturn x;\n\t\t}\n\n\t\treturn JSON.stringify(arguments);\n\t};\n\n\tvar memoized = function () {\n\t\tvar cache = memoized.__cache__;\n\t\tvar key = cacheKey.apply(null, arguments);\n\n\t\tif (cache.has(key)) {\n\t\t\tvar c = cache.get(key);\n\n\t\t\tif (typeof opts.maxAge !== 'number' || Date.now() < c.maxAge) {\n\t\t\t\treturn c.data;\n\t\t\t}\n\t\t}\n\n\t\tvar ret = fn.apply(null, arguments);\n\n\t\tcache.set(key, {\n\t\t\tdata: ret,\n\t\t\tmaxAge: Date.now() + (opts.maxAge || 0)\n\t\t});\n\n\t\treturn ret;\n\t};\n\n\tmemoized.displayName = fn.displayName || fn.name;\n\tmemoized.__cache__ = opts.cache || new Map();\n\n\treturn memoized;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/mem/index.js\n// module id = 40\n// module chunks = 0","'use strict';\nvar path = require('path');\nvar pathKey = require('path-key');\n\nmodule.exports = function (opts) {\n\topts = opts || {};\n\n\tvar prev;\n\tvar pth = path.resolve(opts.cwd || '.');\n\n\tvar ret = [];\n\n\twhile (prev !== pth) {\n\t\tret.push(path.join(pth, 'node_modules/.bin'));\n\t\tprev = pth;\n\t\tpth = path.resolve(pth, '..');\n\t}\n\n\t// ensure the running `node` binary is used\n\tret.push(path.dirname(process.execPath));\n\n\treturn ret.concat(opts.path || process.env[pathKey()]).join(path.delimiter);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/npm-run-path/index.js\n// module id = 41\n// module chunks = 0","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/object-assign/index.js\n// module id = 42\n// module chunks = 0","if (process.env.npm_package_name === 'pseudomap' &&\n    process.env.npm_lifecycle_script === 'test')\n  process.env.TEST_PSEUDOMAP = 'true'\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map\n} else {\n  module.exports = require('./pseudomap')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/pseudomap/map.js\n// module id = 43\n// module chunks = 0","var hasOwnProperty = Object.prototype.hasOwnProperty\n\nmodule.exports = PseudoMap\n\nfunction PseudoMap (set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\")\n\n  this.clear()\n\n  if (set) {\n    if ((set instanceof PseudoMap) ||\n        (typeof Map === 'function' && set instanceof Map))\n      set.forEach(function (value, key) {\n        this.set(key, value)\n      }, this)\n    else if (Array.isArray(set))\n      set.forEach(function (kv) {\n        this.set(kv[0], kv[1])\n      }, this)\n    else\n      throw new TypeError('invalid argument')\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size')\n      fn.call(thisp, this._data[k].value, this._data[k].key)\n  }, this)\n}\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k)\n}\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k)\n  return res && res.value\n}\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v)\n}\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k)\n  if (res) {\n    delete this._data[res._index]\n    this._data.size--\n  }\n}\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null)\n  data.size = 0\n\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  })\n}\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n})\n\nPseudoMap.prototype.values =\nPseudoMap.prototype.keys =\nPseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version')\n}\n\n// Either identical, or both NaN\nfunction same (a, b) {\n  return a === b || a !== a && b !== b\n}\n\nfunction Entry (k, v, i) {\n  this.key = k\n  this.value = v\n  this._index = i\n}\n\nfunction find (data, k) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k))\n      return data[key]\n  }\n}\n\nfunction set (data, k, v) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v\n      return\n    }\n  }\n  data.size++\n  data[key] = new Entry(k, v, key)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/pseudomap/pseudomap.js\n// module id = 44\n// module chunks = 0","var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = null;\n  if (!fs) {\n    // Use SJAX if we are in the browser\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', path, false);\n    xhr.send(null);\n    var contents = null\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      contents = xhr.responseText\n    }\n  } else if (fs.existsSync(path)) {\n    // Otherwise, use the filesystem\n    contents = fs.readFileSync(path, 'utf8');\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = new Buffer(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map) {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame) {\n  if(frame.isNative()) {\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    if (line === 1 && !isInBrowser() && !frame.isEval()) {\n      column -= 62;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    frame = cloneCallSite(frame);\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  return error + stack.map(function(frame) {\n    return '\\n    at ' + wrapCallSite(frame);\n  }).join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      contents = fs.readFileSync(source, 'utf8');\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = require('module');\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map-support/source-map-support.js\n// module id = 45\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/base64.js\n// module id = 46\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/binary-search.js\n// module id = 47\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/mapping-list.js\n// module id = 48\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/quick-sort.js\n// module id = 49\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/source-map-consumer.js\n// module id = 50\n// module chunks = 0","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are removed from this array, by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var shiftNextLine = function() {\n      var lineContents = remainingLines.shift();\n      // The last line of a file might not have a newline.\n      var newLine = remainingLines.shift() || \"\";\n      return lineContents + newLine;\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[0];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[0] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[0];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLines.length > 0) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/lib/source-node.js\n// module id = 51\n// module chunks = 0","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/source-map/source-map.js\n// module id = 52\n// module chunks = 0","'use strict';\nmodule.exports = function (x) {\n\tvar lf = typeof x === 'string' ? '\\n' : '\\n'.charCodeAt();\n\tvar cr = typeof x === 'string' ? '\\r' : '\\r'.charCodeAt();\n\n\tif (x[x.length - 1] === lf) {\n\t\tx = x.slice(0, x.length - 1);\n\t}\n\n\tif (x[x.length - 1] === cr) {\n\t\tx = x.slice(0, x.length - 1);\n\t}\n\n\treturn x;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/strip-eof/index.js\n// module id = 53\n// module chunks = 0","'use strict';\nconst os = require('os');\nconst execa = require('execa');\nconst mem = require('mem');\n\nfunction getEnvVar() {\n\tconst env = process.env;\n\n\treturn env.SUDO_USER ||\n\t\tenv.C9_USER /* Cloud9 */ ||\n\t\tenv.LOGNAME ||\n\t\tenv.USER ||\n\t\tenv.LNAME ||\n\t\tenv.USERNAME;\n}\n\nfunction cleanWinCmd(x) {\n\treturn x.replace(/^.*\\\\/, '');\n}\n\nfunction noop() {}\n\nmodule.exports = mem(() => {\n\tif (os.userInfo) {\n\t\treturn Promise.resolve(os.userInfo().username);\n\t}\n\n\tconst envVar = getEnvVar();\n\n\tif (envVar) {\n\t\treturn Promise.resolve(envVar);\n\t}\n\n\tif (process.platform === 'darwin' || process.platform === 'linux') {\n\t\treturn execa('id', ['-un']).then(x => x.stdout).catch(noop);\n\t} else if (process.platform === 'win32') {\n\t\treturn execa('whoami').then(x => cleanWinCmd(x.stdout)).catch(noop);\n\t}\n\n\treturn Promise.resolve();\n});\n\nmodule.exports.sync = mem(() => {\n\tif (os.userInfo) {\n\t\treturn os.userInfo().username;\n\t}\n\n\tconst envVar = getEnvVar();\n\n\tif (envVar) {\n\t\treturn envVar;\n\t}\n\n\ttry {\n\t\tif (process.platform === 'darwin' || process.platform === 'linux') {\n\t\t\treturn execa.sync('id', ['-un']).stdout;\n\t\t} else if (process.platform === 'win32') {\n\t\t\treturn cleanWinCmd(execa.sync('whoami').stdout);\n\t\t}\n\t} catch (err) {}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/username/index.js\n// module id = 54\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/uuid/lib/bytesToUuid.js\n// module id = 55\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is prett straight-forward - we use the crypto API.\n\nvar rb = require('crypto').randomBytes;\n\nfunction rng() {\n  return rb(16);\n};\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/uuid/lib/rng.js\n// module id = 56\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/uuid/v4.js\n// module id = 57\n// module chunks = 0","module.exports = which\nwhich.sync = whichSync\n\nvar isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nvar path = require('path')\nvar COLON = isWindows ? ';' : ':'\nvar isexe = require('isexe')\n\nfunction getNotFoundError (cmd) {\n  var er = new Error('not found: ' + cmd)\n  er.code = 'ENOENT'\n\n  return er\n}\n\nfunction getPathInfo (cmd, opt) {\n  var colon = opt.colon || COLON\n  var pathEnv = opt.path || process.env.PATH || ''\n  var pathExt = ['']\n\n  pathEnv = pathEnv.split(colon)\n\n  var pathExtExe = ''\n  if (isWindows) {\n    pathEnv.unshift(process.cwd())\n    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')\n    pathExt = pathExtExe.split(colon)\n\n\n    // Always test the cmd itself first.  isexe will check to make sure\n    // it's found in the pathExt set.\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  if (cmd.match(/\\//) || isWindows && cmd.match(/\\\\/))\n    pathEnv = ['']\n\n  return {\n    env: pathEnv,\n    ext: pathExt,\n    extExe: pathExtExe\n  }\n}\n\nfunction which (cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  ;(function F (i, l) {\n    if (i === l) {\n      if (opt.all && found.length)\n        return cb(null, found)\n      else\n        return cb(getNotFoundError(cmd))\n    }\n\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && (/^\\.[\\\\\\/]/).test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    ;(function E (ii, ll) {\n      if (ii === ll) return F(i + 1, l)\n      var ext = pathExt[ii]\n      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {\n        if (!er && is) {\n          if (opt.all)\n            found.push(p + ext)\n          else\n            return cb(null, p + ext)\n        }\n        return E(ii + 1, ll)\n      })\n    })(0, pathExt.length)\n  })(0, pathEnv.length)\n}\n\nfunction whichSync (cmd, opt) {\n  opt = opt || {}\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  for (var i = 0, l = pathEnv.length; i < l; i ++) {\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    for (var j = 0, ll = pathExt.length; j < ll; j ++) {\n      var cur = p + pathExt[j]\n      var is\n      try {\n        is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  throw getNotFoundError(cmd)\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/which/which.js\n// module id = 58\n// module chunks = 0","module.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/yallist/yallist.js\n// module id = 59\n// module chunks = 0","const authenticatorAppWelcomeText = 'Open the two-factor authentication app on your device to view your authentication code and verify your identity.'\nconst smsMessageWelcomeText = 'We just sent you a message via SMS with your authentication code. Enter the code in the form below to verify your identity.'\n\n/**\n * When authentication is requested via 2FA, the endpoint provides\n * a hint in the response header as to where the user should look\n * to retrieve the token.\n */\nexport enum AuthenticationMode {\n  /*\n   * User should authenticate via a received text message.\n   */\n  Sms,\n  /*\n   * User should open TOTP mobile application and obtain code.\n   */\n  App,\n}\n\nexport function getWelcomeMessage(type: AuthenticationMode): string {\n  return type === AuthenticationMode.Sms\n      ? smsMessageWelcomeText\n      : authenticatorAppWelcomeText\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/2fa.ts","import { Account } from '../models/account'\n\n/** Get the auth key for the user. */\nexport function getKeyForAccount(account: Account): string {\n  return getKeyForEndpoint(account.endpoint)\n}\n\n/** Get the auth key for the endpoint. */\nexport function getKeyForEndpoint(endpoint: string): string {\n  const appName = __DEV__\n    ? 'GitHub Desktop Dev'\n    : 'GitHub'\n\n  return `${appName} - ${endpoint}`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/auth.ts","const deepEquals: (actual: object, expected: object, opts?: { strict: boolean }) => boolean = require('deep-equal')\n\nexport function structuralEquals<T extends object>(actual: T, expected: T): boolean {\n  return deepEquals(actual, expected, { strict: true })\n}\n\n/**\n * Performs a shallow equality comparison on the two objects, iterating over\n * their keys (non-recursively) and compares their values.\n * \n * This method is functionally identical to that of React's shallowCompare\n * function and is intended to be used where we need to test for the same\n * kind of equality comparisons that a PureComponent performs.\n * \n * Note that for Arrays and primitive types this method will follow the same\n * semantics as Object.is, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nexport function shallowEquals(x: any, y: any) {\n  if (Object.is(x, y)) {\n    return true\n  }\n\n  // After this we know that neither side is null or undefined\n  if (x === null || y === null || typeof x !== 'object' || typeof y !== 'object') {\n    return false\n  }\n\n  const xKeys = Object.keys(x)\n  const yKeys = Object.keys(y)\n\n  if (xKeys.length !== yKeys.length) {\n    return false\n  }\n\n  for (let i = 0; i < xKeys.length; i++) {\n    const key = xKeys[i]\n    if (!Object.prototype.hasOwnProperty.call(y, key) || !Object.is(x[key], y[key])) {\n      return false\n    }\n  }\n\n  return true\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/equality.ts","/** Throw an error. */\nexport function fatalError(msg: string): never {\n  throw new Error(msg)\n}\n\n/**\n * Utility function used to achieve exhaustive type checks at compile time.\n *\n * If the type system is bypassed or this method will throw an exception\n * using the second parameter as the message.\n *\n * @param {x}       Placeholder parameter in order to leverage the type\n *                  system. Pass the variable which has been type narrowed\n *                  in an exhaustive check.\n *\n * @param {message} The message to be used in the runtime exception.\n *\n */\nexport function assertNever(x: never, message: string): never {\n  throw new Error(message)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/fatal-error.ts","import * as appProxy from '../ui/lib/app-proxy'\n\n/** The HTTP methods available. */\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'HEAD'\n\n/**\n * The structure of error messages returned from the GitHub API.\n *\n * Details: https://developer.github.com/v3/#client-errors\n */\nexport interface IError {\n  readonly message: string\n  readonly resource: string\n  readonly field: string\n}\n\n/**\n * The partial server response when an error has been returned.\n *\n * Details: https://developer.github.com/v3/#client-errors\n */\nexport interface IAPIError {\n  readonly errors?: IError[]\n  readonly message?: string\n}\n\n/** An error from getting an unexpected response to an API call. */\nexport class APIError extends Error {\n  /** The error as sent from the API, if one could be parsed. */\n  public readonly apiError: IAPIError | null\n\n  public constructor(response: Response, apiError: IAPIError | null) {\n    let message\n    if (apiError && apiError.message) {\n      message = apiError.message\n\n      const errors = apiError.errors\n      const additionalMessages = errors && errors.map(e => e.message).join(', ')\n      if (additionalMessages) {\n        message = `${message} (${additionalMessages})`\n      }\n    } else {\n      message = `API error ${response.url}: ${response.statusText} (${response.status})`\n    }\n\n    super(message)\n\n    this.apiError = apiError\n  }\n}\n\n/**\n * Deserialize the HTTP response body into an expected object shape\n *\n * Note: this doesn't validate the expected shape, and will only fail if it\n * encounters invalid JSON.\n */\nasync function deserialize<T>(response: Response): Promise<T> {\n  try {\n    const json = await response.json()\n    return json as T\n  } catch (e) {\n    log.warn(`Unable to deserialize JSON string to object ${response}`, e)\n    throw e\n  }\n}\n\n/**\n * Make an API request.\n *\n * @param endpoint      - The API endpoint.\n * @param token         - The token to use for authentication.\n * @param method        - The HTTP method.\n * @param path          - The path, including any query string parameters.\n * @param jsonBody      - The JSON body to send.\n * @param customHeaders - Any optional additional headers to send.\n */\nexport function request(endpoint: string, token: string | null, method: HTTPMethod, path: string, jsonBody?: Object, customHeaders?: Object): Promise<Response> {\n  const relativePath = path[0] === '/' ? path.substr(1) : path\n  const url = encodeURI(`${endpoint}/${relativePath}`)\n\n  let headers: any = {\n    'Accept': 'application/vnd.github.v3+json, application/json',\n    'Content-Type': 'application/json',\n    'User-Agent': getUserAgent(),\n  }\n\n  if (token) {\n    headers['Authorization'] = `token ${token}`\n  }\n\n  headers = {\n    ...headers,\n    ...customHeaders,\n  }\n\n  const options = {\n    headers,\n    method,\n    body: JSON.stringify(jsonBody),\n  }\n\n  return fetch(url, options)\n}\n\n/** Get the user agent to use for all requests. */\nfunction getUserAgent() {\n  const platform = __DARWIN__ ? 'Macintosh' : 'Windows'\n  return `GitHubDesktop/${appProxy.getVersion()} (${platform})`\n}\n\n/**\n * If the response was OK, parse it as JSON and return the result. If not, parse\n * the API error and throw it.\n */\nexport async function parsedResponse<T>(response: Response): Promise<T> {\n  if (response.ok) {\n    return deserialize<T>(response)\n  } else {\n    let apiError: IAPIError | null\n    // Deserializing the API error could throw. If it does, we'll throw a more\n    // general API error.\n    try {\n      apiError = await deserialize<IAPIError>(response)\n    } catch (e) {\n      throw new APIError(response, null)\n    }\n\n    throw apiError\n  }\n}\n\n/**\n * Appends the parameters provided to the url as query string parameters.\n *\n * If the url already has a query the new parameters will be appended.\n */\nexport function urlWithQueryString(url: string, params: { [key: string]: string }): string {\n  const qs = Object.keys(params)\n    .map(key => `${key}=${encodeURIComponent(params[key])}`)\n    .join('&')\n\n  if (!qs.length) {\n    return url\n  }\n\n  if (url.indexOf('?') === -1) {\n    return `${url}?${qs}`\n  } else {\n    return `${url}&${qs}`\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/http.ts","import { withSourceMappedStack } from '../source-map-support'\n\n/**\n * Formats an error for log file output. Use this instead of\n * multiple calls to log.error.\n */\nexport function formatError(error: Error, title?: string) {\n  error = withSourceMappedStack(error)\n\n  if (error.stack) {\n    return title\n      ? `${title}\\n${error.stack}`\n      : error.stack.trim()\n  } else {\n    return title\n      ? `${title}\\n${error.name}: ${error.message}`\n      : `${error.name}: ${error.message}`\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/format-error.ts","import { formatError } from './format-error'\n\nexport function formatLogMessage(message: string, error?: Error) {\n  return error\n    ? formatError(error, message)\n    : message\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/logging/format-log-message.ts","import { randomBytes as nodeCryptoGetRandomBytes } from 'crypto'\n\n// Work around synchronously seeding of random buffer in the v1\n// version of uuid by explicitly only requiring v4. As far as I'm\n// aware we cannot use an import statement here without causing webpack\n// to load the v1 version as well.\n//\n// See\n//  https://github.com/kelektiv/node-uuid/issues/189\nconst guid = require('uuid/v4') as (options?: { random?: Buffer }) => string\n\n/**\n * Fills a buffer with the required number of random bytes.\n * \n * Attempt to use the Chromium-provided crypto library rather than\n * Node.JS. For some reason the Node.JS randomBytes function adds\n * _considerable_ (1s+) synchronous load time to the start up.\n *\n * See\n *  https://developer.mozilla.org/en-US/docs/Web/API/Window/crypto\n *  https://github.com/kelektiv/node-uuid/issues/189\n */\nfunction getRandomBytes(count: number): Buffer {\n  if (window.crypto) {\n    const rndBuf = new Uint8Array(count)\n    crypto.getRandomValues(rndBuf)\n\n    return Buffer.from(rndBuf.buffer)\n  }\n\n  return nodeCryptoGetRandomBytes(count)\n}\n\n/**\n * Wrapper function over uuid's v4 method that attempts to source\n * entropy using the window Crypto instance rather than through\n * Node.JS.\n */\nexport function uuid() {\n  return guid({ random: getRandomBytes(16) })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/lib/uuid.ts","import '../lib/logging/renderer/install'\n\nimport * as TokenStore from '../shared-process/token-store'\nimport { AccountsStore } from './accounts-store'\nimport { Account } from '../models/account'\nimport { Database } from './database'\nimport { RepositoriesStore } from './repositories-store'\nimport { Repository, IRepository } from '../models/repository'\nimport { register, broadcastUpdate as broadcastUpdate_ } from './communication'\nimport {\n  IAddRepositoriesAction,\n  IUpdateGitHubRepositoryAction,\n  IRemoveRepositoriesAction,\n  IAddAccountAction,\n  IRemoveAccountAction,\n  IUpdateRepositoryMissingAction,\n  IUpdateRepositoryPathAction,\n} from '../lib/dispatcher'\nimport { API } from '../lib/api'\nimport { sendErrorReport, reportUncaughtException } from '../ui/main-process-proxy'\nimport { enableSourceMaps, withSourceMappedStack } from '../lib/source-map-support'\n\nenableSourceMaps()\n\nprocess.on('uncaughtException', (error: Error) => {\n  error = withSourceMappedStack(error)\n\n  console.error('Uncaught exception', error)\n\n  sendErrorReport(error)\n  reportUncaughtException(error)\n})\n\nconst accountsStore = new AccountsStore(localStorage, TokenStore)\nconst database = new Database('Database')\nconst repositoriesStore = new RepositoriesStore(database)\n\nconst broadcastUpdate = () => broadcastUpdate_(accountsStore, repositoriesStore)\n\nupdateAccounts()\n\nasync function updateAccounts() {\n  await accountsStore.map(async (account: Account) => {\n    const api = API.fromAccount(account)\n    const newAccount = await api.fetchAccount()\n    const emails = await api.fetchEmails()\n    return new Account(account.login, account.endpoint, account.token, emails, newAccount.avatar_url, newAccount.id, newAccount.name)\n  })\n  broadcastUpdate()\n}\n\nregister('ping', () => {\n  return Promise.resolve('pong')\n})\n\nregister('get-accounts', () => accountsStore.getAll())\n\nregister('add-account', async ({ account }: IAddAccountAction) => {\n  await accountsStore.addAccount(Account.fromJSON(account))\n  await updateAccounts()\n})\n\nregister('remove-account', async ({ account }: IRemoveAccountAction) => {\n  await accountsStore.removeAccount(Account.fromJSON(account))\n  broadcastUpdate()\n})\n\nregister('add-repositories', async ({ paths }: IAddRepositoriesAction) => {\n  const addedRepos: Repository[] = []\n  for (const path of paths) {\n    const addedRepo = await repositoriesStore.addRepository(path)\n    addedRepos.push(addedRepo)\n  }\n\n  broadcastUpdate()\n  return addedRepos\n})\n\nregister('remove-repositories', async ({ repositoryIDs }: IRemoveRepositoriesAction) => {\n  const removedRepoIDs: number[] = []\n  for (const repoID of repositoryIDs) {\n    await repositoriesStore.removeRepository(repoID)\n    removedRepoIDs.push(repoID)\n  }\n\n  broadcastUpdate()\n  return removedRepoIDs\n})\n\nregister('get-repositories', () => {\n  return repositoriesStore.getRepositories()\n})\n\nregister('update-github-repository', async ({ repository }: IUpdateGitHubRepositoryAction) => {\n  const inflatedRepository = Repository.fromJSON(repository as IRepository)\n  const updatedRepository = await repositoriesStore.updateGitHubRepository(inflatedRepository)\n\n  broadcastUpdate()\n\n  return updatedRepository\n})\n\nregister('update-repository-missing', async ({ repository, missing }: IUpdateRepositoryMissingAction) => {\n  const inflatedRepository = Repository.fromJSON(repository)\n  const updatedRepository = await repositoriesStore.updateRepositoryMissing(inflatedRepository, missing)\n\n  broadcastUpdate()\n\n  return updatedRepository\n})\n\nregister('update-repository-path', async ({ repository, path }: IUpdateRepositoryPathAction) => {\n  const inflatedRepository = Repository.fromJSON(repository)\n  const updatedRepository = await repositoriesStore.updateRepositoryPath(inflatedRepository, path)\n  const newUpdatedRepository = await repositoriesStore.updateRepositoryMissing(updatedRepository, false)\n\n  broadcastUpdate()\n\n  return newUpdatedRepository\n})\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/shared-process/index.ts","import { remote } from 'electron'\n\nlet app: Electron.App | null = null\nlet version: string | null = null\nlet name: string | null = null\nlet path: string | null = null\nlet userDataPath: string | null = null\nlet documentsPath: string | null = null\n\nfunction getApp(): Electron.App {\n  if (!app) {\n    app = remote.app\n  }\n\n  return app\n}\n\n/**\n * Get the version of the app.\n *\n * This is preferrable to using `remote` directly because we cache the result.\n */\nexport function getVersion(): string {\n  if (!version) {\n    version = getApp().getVersion()\n  }\n\n  return version\n}\n\n/**\n * Get the name of the app.\n *\n * This is preferrable to using `remote` directly because we cache the result.\n */\nexport function getName(): string {\n  if (!name) {\n    name = getApp().getName()\n  }\n\n  return name\n}\n\n/**\n * Get the path to the application.\n *\n * This is preferrable to using `remote` directly because we cache the result.\n */\nexport function getAppPath(): string {\n  if (!path) {\n    path = getApp().getAppPath()\n  }\n\n  return path\n}\n\n/**\n * Get the path to the user's data.\n *\n * This is preferrable to using `remote` directly because we cache the result.\n */\nexport function getUserDataPath(): string {\n  if (!userDataPath) {\n    userDataPath = getApp().getPath('userData')\n  }\n\n  return userDataPath\n}\n\n/**\n * Get the path to the user's documents path.\n *\n * This is preferrable to using `remote` directly because we cache the result.\n */\nexport function getDocumentsPath(): string {\n  if (!documentsPath) {\n    const app =  getApp()\n    try {\n      documentsPath = app.getPath('documents')\n    } catch (ex) {\n      // a user profile may not have the Documents folder defined on Windows\n      documentsPath = app.getPath('home')\n    }\n  }\n\n  return documentsPath\n}\n\n\n\n// WEBPACK FOOTER //\n// ./app/src/ui/lib/app-proxy.ts","module.exports = __non_webpack_require__(\"./keytar.node\")\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./app/~/keytar/build/Release/keytar.node\n// module id = 70\n// module chunks = 0","module.exports = require(\"module\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"module\"\n// module id = 71\n// module chunks = 0","module.exports = require(\"url\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url\"\n// module id = 72\n// module chunks = 0","module.exports = require(\"util\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"util\"\n// module id = 73\n// module chunks = 0"],"sourceRoot":""}